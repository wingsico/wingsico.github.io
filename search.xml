<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年-2020年目标规划</title>
    <url>/2019/06/11/2019-plan-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个有略微拖延症的患者，觉得清单驱动行为是很有必要的。现将一些目标规划列出来，驱动自己将其完成。</p>
<p>在完成过程中，也将把其整理成博客，希望今年还能取得更多进步！</p>
<a id="more"></a>

<h2 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h2><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="深入理解系列"><a href="#深入理解系列" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol>
<li>svg</li>
<li>canvas</li>
<li>video</li>
<li>shadow-dom</li>
<li>web-component</li>
<li>web worker</li>
<li>CSS3</li>
</ol>
<h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><h4 id="深入理解系列-1"><a href="#深入理解系列-1" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol>
<li>Proxy</li>
<li>Class</li>
<li>Generator</li>
<li>Async</li>
<li>Promise</li>
<li>Blob</li>
<li>垃圾收集</li>
<li>正则表达式</li>
<li>Iterator</li>
<li>Object.defineProperty()</li>
<li>Reflection</li>
<li>typescript</li>
<li>ES6/7/8 等新特性</li>
</ol>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="深入理解系列-2"><a href="#深入理解系列-2" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol>
<li>Fiber</li>
<li>Hooks</li>
<li>HoC</li>
<li>render function</li>
<li>immutable</li>
<li>pure function</li>
<li>更新、渲染机制</li>
<li>jsx</li>
<li>设计方案</li>
</ol>
<h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><ol>
<li>React + typescript + [状态管理方案 Mobx,Redux] + antd 重构 US</li>
<li>React + Koa2 + Mongodb 写一个自己的博客</li>
</ol>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><h4 id="深入理解系列-3"><a href="#深入理解系列-3" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol>
<li>异步 IO</li>
<li>事件驱动</li>
<li>异步并发控制</li>
<li>V8</li>
<li>Buffer</li>
<li>中间件</li>
<li>流</li>
</ol>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="深入理解系列-4"><a href="#深入理解系列-4" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol>
<li>mixins</li>
<li>observable</li>
<li>Vue.use</li>
<li>diretives</li>
<li>provide/inject</li>
<li>设计方案</li>
</ol>
<h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="理解并实践"><a href="#理解并实践" class="headerlink" title="理解并实践"></a>理解并实践</h4><ol>
<li>Webpack</li>
<li>Gulp</li>
<li>PostCSS</li>
<li>Scss</li>
<li>设计模式</li>
<li>算法</li>
<li>函数式编程</li>
<li>网络</li>
<li>数据结构</li>
<li>数据库</li>
<li>Git</li>
<li>测试</li>
<li>工程化</li>
</ol>
<h2 id="生活类"><a href="#生活类" class="headerlink" title="生活类"></a>生活类</h2><ol>
<li>减肥 15 斤</li>
<li>养成良好作息习惯</li>
<li>学会炒更多菜</li>
<li>女票考研成功！</li>
<li>坚持健身</li>
<li>存钱！</li>
<li>认识更多的人</li>
<li>读一些非技术类的书</li>
</ol>
<p>加油，为了美好青春而战，为了家人，也为了自己！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>满二叉树中树的深度、结点、分支结点、叶子结点等之间的数量关系</title>
    <url>/2017/12/16/btree-number-relation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对二叉树的简单总结</p>
<a id="more"></a>

<h2 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h2><p>对于普通的二叉树，假设<code>n</code>为总结点数，<code>n0</code>为度为 0 的结点（叶子结点）数，<code>n1</code>为度为 1 的结点数，<code>n2</code>为度为 2 的结点数。<code>m</code>为树的总度数。 有如下一般的数量关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树只含有度数为 0，1，2 的结点，因此总结点数等于他们的和</span></span><br><span class="line">n = n0 + n1 + n2</span><br><span class="line"><span class="comment">// 无需解释吧，m 为总度数</span></span><br><span class="line"><span class="number">0</span> _ n0 + <span class="number">1</span> _ n1 + <span class="number">2</span> \* n2 = m</span><br><span class="line"><span class="comment">// 除了根结点之外，每一个结点的上方都对应着一个度，因此总度数比总结点数少 1</span></span><br><span class="line">m = n - <span class="number">1</span></span><br><span class="line"><span class="comment">// 综合上面的三个式子</span></span><br><span class="line">n0 =  n2 + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>设深度为<code>h</code>，设<code>n</code>为总结点数，<code>k</code>为分支结点数，<code>m</code>为叶子结点数。 <strong>深度</strong>：树的最大层数； <strong>叶子结点</strong>：度为 0 的结点； <strong>分支结点</strong>：非叶子结点，即度不为零的结点。 则有如下的数量关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m = <span class="number">2</span> ^ (h - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + ... + <span class="number">2</span> ^ (h - <span class="number">1</span>) = <span class="number">2</span> ^ h - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k = n - m = <span class="number">2</span> ^ (h - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n = <span class="number">2</span>m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n = <span class="number">2</span>k + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>十一月碎语</title>
    <url>/2020/12/07/202011-summary/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>11 月算是一个比较重要的时间段了，在这段时期内，对幸福里又或者是对我，都发生了很多事情。</p>
<p>11月份，我们的工区从中兴大厦搬到了天作国际，离开了工作了大概半年的老工区（算上实习那段时间），回想一下，这已经是第二次搬工区了。从天使的小矮楼，搬到经常要爬10层楼梯锻炼身体的中兴大厦，再到现在得更高的没法爬楼的天作国际，也许在暗示着我们幸福里的步步高升吧~</p>
<p>每每到了一个新环境，我都会想方设法地让自己变得跟以前不一样，我这人有些喜新厌旧，对自己也是。购置了新的键盘，买了显示器支架，以及一直想买却不敢买的二次元桌垫，虽然羞耻但是满心欢喜。可能是身为处女座的特质，看见整整齐齐的桌面每天的心情就会非常不错，所以我开始整理和收纳自己的桌面，让它和周围的环境和我一样，都是崭新的。</p>
<p>来到的新的大楼，工位也是坐在了自己非常喜欢的窗边，而且在幽静的角落我可以安心专注地做我想做的事情，一个人听歌，专心地感受指尖与键盘之间的美妙触感，沉浸在自己的小世界里，偶尔可以忘却工作上的疲惫与烦恼…</p>
<p>可能是刚入职场的缘故吧，对于职场上的人员更替还不是那么习惯，从天使时代 一直呆到现在的“天使孟春”也离开了我们这个小团体，和当初的薛超相比，至少他是笑着和我们挥手告别的。虽然对于整个团队来说少一个人也许并不会改变什么，但对于现阶段的我来说，心里总是会感觉有一丝落空的感觉，再没有天使孟春，也没有两万块彩礼的梗了。</p>
<p>撇开这些似乎是职场青春期的烦恼，其余的工作生活也是挺美好的。</p>
<p>女朋友趁着我双休飞过来小聚了一下。天气微凉，戴着围巾的她笑起来格外温暖，像一只冬天里举着小火炬的雪精灵，温暖着我这略有些孤寂的北漂的心。这次，我们也没有计划去得太远，在几个商场逛逛街，去尝尝我给她说了好多次的锦府盐帮，也去了她想去了很久的满地枫叶的林荫小道。平淡而简单，又好像回到了学生时代。</p>
<p>短暂的几天过得很快，但也弥足珍贵，能够每两个月见她一次，我觉得已经很满足了，不过这当然比不了阿彪小两口的热恋状态（笑）。</p>
<p>女朋友是暂时见不到了，但生活还是得继续。一次偶然的机会，我站上了许久未使用的体重秤，秤上惊人的数字让沉寂的我顿时清醒了，开始意识到自己这一段时间的懒散和堕落。我开始重新审视这段时间的自己：相比于毕业刚来北京的那两个月，10月到11月中旬这段时间可以说是相对懒散了许多，以前信誓旦旦地说的每周打扫卫生也很久没进行，减肥计划也搁置着，体重在不经意见就增长到了144斤，作息也开始不规律了，也吃了不少韩式炸鸡，这一切仿佛与当初斗志昂扬的自己有些格格不入，我意识到了，是时候该改变了。</p>
<p>于是趁着一次双休，我先从整理屋子开始，再到自我思考，冷清的出租屋似乎格外地适合冥想，特别是在周围环境是干净且整齐的。我想到了自己该做的事情和方向，虽然不知道是否正确，但这些事情能让我在一天结束时躺在床上能感觉到实实在在的充实感，我想这样，应该足够了。</p>
<p>12月，似乎会非常繁忙，不管是工作上，还是那些我打算做的事情。但我期盼着，未来越来越崭新的自己。</p>
<p>于此自勉<br>2020年12月06日</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《猫鼠游戏》有感</title>
    <url>/2020/04/04/catch-me-if-you-can/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>看完这部电影，对于结局我是非常喜欢的，我不喜欢悲剧，也不喜欢作为主人公的纯喜剧，对于 猫鼠游戏 中的双方共赢的具有教育意义的结局，让我在观影后不单纯只是了解了弗兰克的结局，而沉浸在这种略微喜悦的感觉中，而是也会让我去平静下来，去真正的作为一个旁观者的一个思考。</p>
<p>弗兰克的经历我觉得是很现实的，父亲由于税务问题导致破产，母亲也因此出轨。父亲对弗兰克影响颇深，他尊重父亲，也记住父亲说的每一句话和做的每一件事。只有父亲是真正关心他的，父子关心亲如朋友，这点从记住弗兰克生日和父子两的交谈中可以看出。在弗兰克心中，父亲占有很重要的地位。以至于后面父母的离婚，让他开始想要报复银行和政府，因为在它看来，是他们的不公平对待让父亲破产，家庭破裂。因此，他走上了支票诈骗的路。</p>
<p>在这条路上，弗兰克充分的展现了他的聪明才智和敏锐的观察力，情商更是超高。在一次次成功的欺骗背后，是对细节和人心的把控。不管是当飞行员前在电视上看的相关飞行员的谈话，还是当医生时在电视上的一些谈话，这些对细节的注意和提前规划让他顺利的实施这一切。</p>
<p>在这趟旅途中，警官卡尔这个角色，我觉得他既是一个抓捕罪犯的警官，其实也是弗兰克唯一可以说真话的朋友。在这场猫鼠游戏中，双方都对对方产生了奇妙的感情，卡尔虽然在追捕弗兰克，但同时也在保护他。</p>
<p>这场猫鼠游戏，由家庭开始，也由家庭结束，父亲的死，母亲的改嫁，让他最终放弃了这场游戏，这场游戏对于弗兰克来说，也就失去了它的意义。</p>
<p>在影片的最后的前一段，弗兰克为什么要离开，离开后去了哪里，我无从而知。但从他裁掉记录在档案中的弗兰克被捕的照片可以找到一些蛛丝马迹。被FBI聘用后，压抑的工作和卡尔的无视让他想要回到从前，回到那场猫鼠游戏，也许那样，他才有和卡尔或者其他相互信任的人交流的机会。</p>
<p>影片的最后，弗兰克和卡尔一起讨论，一起工作，内容依旧是支票诈骗，依旧是那场猫鼠游戏。只是，老鼠搅动奶油变成了黄油，从桶里逃出，最终变成猫了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>代码片段理解(1)</title>
    <url>/2018/03/13/codes-understanding-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">arg</span> =&gt;</span></span><br><span class="line">  fns.reduce(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在学习 react 过程中碰到这样的一段代码，勉强能知道这是一段函数式的代码，并且配合 es6 的箭头函数以及扩展运算符组合而成的，但最初看到这段代码的时候还是把我难住了，主要问题有三个：</p>
<ol>
<li>两个箭头函数写法</li>
<li>函数作为参数传递</li>
<li><code>Array.prototype.reduce</code> 用法</li>
</ol>
<h3 id="gt-gt-console-log-1"><a href="#gt-gt-console-log-1" class="headerlink" title="() =&gt; () =&gt; console.log(1)"></a>() =&gt; () =&gt; console.log(1)</h3><p>这个不难理解，箭头函数可以省略大括号，则箭头后跟着的就是其返回值，在这里他的返回值就是一个函数，<strong>这里也就是一个函数式编程的思想，函数作为一等公民，和其他类型的值用法可以一致</strong>。用 es5 重写一下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">test(); <span class="comment">// 返回: function () &#123;console.log(1)&#125;</span></span><br><span class="line">test()(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="fn-gt-fn-‘我被参数执行了’"><a href="#fn-gt-fn-‘我被参数执行了’" class="headerlink" title="(fn) =&gt; fn(‘我被参数执行了’)"></a>(fn) =&gt; fn(‘我被参数执行了’)</h3><p>这个也比较好理解，根据第一点，函数可以作为返回值，也能作为参数，用一个简单的例子表示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">text</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(text)(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">&quot;我被参数执行了&quot;</span>;</span><br><span class="line">    fn(text);</span><br><span class="line">  &#125;)(); <span class="comment">// 打印出: 我被参数执行了</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p>至于<code>reduce</code>，之前对他的了解只有是<strong>累加器，把数组前面的值与目前的值进行运算，并作为一个值与数组的下一项的值进行运算</strong>，是从这样一个例子得到的认知:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>对 reduce 有一个模糊的认识，且不清楚他拥有的参数及其含义。查阅相关资料后，了解了： <strong><code>reduce</code> 共有两个参数，第一个参数为<code>callback</code>，即回调函数，用于对数组内的值进行操作，且必须有返回值;第二个参数为<code>initialValue</code>，是一个可选的参数，即初始值，即第一个 pre 的值初始化，如果没有设置这个参数，则 pre 默认为第一个数组的值，需要注意的是，初始值的类型决定了最后得到的结果的类型，这两者是保持一致的</strong></p>
<p>拿上面的那个例子来说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际执行过程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. pre === 0, cur === 1</span></span><br><span class="line"><span class="comment">        2. pre === 0 + 1, cur === 2</span></span><br><span class="line"><span class="comment">        3. pre === 0 + 1 + 2, cur === 3</span></span><br><span class="line"><span class="comment">        4. pre === 0 + 1 + 2 + 3, cur === &quot;&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 比数组的长度多执行一次</span></span><br><span class="line"><span class="comment">// 若没有设置初始值，则和数组的长度的执行次数一致</span></span><br></pre></td></tr></table></figure>

<p>这个也很好理解，将前面 return 的值给下一次使用，但是，为了理解我们最开始给出的那段代码，这个值就是一个问题，这个也同样是和第一点和第二点一样, 甚至是第一点和第二点的结合，函数式编程思想，函数作为参数传递进来，又作为返回值给下一次使用。 <strong>这里只用到第二点，函数作为参数传递。</strong> 至此，解决了三个问题，为了读懂这一段代码，需要把这三个知识串在一起使用。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>首先，要理解第一个参数<code>fns</code>，从参数的命名上看，我们可以知道<code>fns</code>应该表示成数组，然后需要注意的是：<strong>传递的参数不应该以数组的形式传递（这也是我一开始遇到的问题，并且困扰到最后，也是对扩展运算符的了解不够或者误解），而应该以多个参数的形式传递。具体详情查看<code>es6 数组的扩展</code></strong> 再者是连续的两个双箭头，<code>() =&gt; ... =&gt; ...</code>意味着他是一个会返回函数的函数，第一次调用的结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arg =&gt; fns.reduce(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br></pre></td></tr></table></figure>

<p>通过对<code>reduce</code>的理解，<code>composed</code>为数组的前一个 return 的值(在 arg 缺省的情况下，数组的第一项作为 composed)，<code>cur</code>为当前的值。</p>
<p>注意这里对<strong>值</strong>的定义，对于 reduce 来说，值可以是任何一种类型（当没有初始值限制的时候），当然也包括<strong>函数</strong>，对于我们这一段代码来说，当初始值缺省时，第一项的返回值可以不为函数，最后一项的返回值也可以不为函数，也可以没有返回值，但中间部分的返回值必须为一个函数，由<code>f(composed)</code>可以了解到这一点；</p>
<p>当初始值存在时，则从第一项到倒数第二项的参数的返回值必须为函数（因为第一项需要接受初始值作为参数的传递）。</p>
<p>之前还是没看懂，现在终于了解了，对于这个代码，每一个参数必须为函数，且均要有参数（如果没有给 arg 赋值的话，第一个可以没有参数），这个函数的返回值与参数 <code>arg</code> 有关，arg 是一直存在的，之前没搞懂这一点，就算调用时不赋值，也为 <code>undefined</code>，因此第一个 <code>pre</code> 永远为 <code>undefined</code>（除非你给 arg 赋值），且除了最后一个函数外，均必须要有返回值，若最后一个函数没有返回值，则整体就没有返回值。 由此，可以得到这个<code>compose</code>函数的用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="function">() =&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> last = <span class="function"><span class="params">b</span> =&gt;</span> <span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">let</span> result = compose(first, second, last)(); <span class="comment">// 打印出 2，不是返回值为2</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// undefined</span></span><br><span class="line">last = <span class="function"><span class="params">b</span> =&gt;</span> b + <span class="number">1</span>;</span><br><span class="line">result = compose(first, second, last)(); <span class="comment">// 返回值为3</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">last(second(first())); <span class="comment">// 返回值为2</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，终于搞明白了<code>compose</code>函数的作用，就是为了以一个简明的方式实现函数的嵌套，即<strong>组合嵌套函数</strong>，有多个参数，实参为函数的形式存在，其返回值也为函数，即组合之后的函数。</p>
]]></content>
      <categories>
        <category>深入理解</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title>代码片段理解(2)</title>
    <url>/2018/03/14/codes-understanding-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pick = <span class="function">(<span class="params">field = <span class="string">&quot;&quot;</span>, object = &#123;&#125;</span>) =&gt;</span> object[field];</span><br><span class="line"><span class="keyword">const</span> pluck = <span class="function">(<span class="params">field, array</span>) =&gt;</span> array.map(<span class="function"><span class="params">object</span> =&gt;</span> pick(field, object));</span><br><span class="line"><span class="keyword">const</span> deepPluck = <span class="function">(<span class="params">field, array</span>) =&gt;</span></span><br><span class="line">  array.map(<span class="function"><span class="params">object</span> =&gt;</span> deepPick(field, object));</span><br><span class="line"><span class="keyword">const</span> deepPick = <span class="function">(<span class="params">fields, object = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [first, ...remaining] = fields.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> remaining.length</span><br><span class="line">    ? deepPick(remaining.join(<span class="string">&quot;.&quot;</span>), object[first])</span><br><span class="line">    : object[first];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>接着之前那一段 <code>函数嵌套</code> 的代码，这一段我觉得简单许多，至少不会在一开始就比较懵逼，这里需要了解的知识主要有以下几个:</p>
<ol>
<li>默认参数</li>
<li>Array.prototype.map</li>
<li>箭头函数</li>
<li>扩展运算符</li>
</ol>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数没什么好说的，详情看<a href="http://es6.ruanyifeng.com/#docs/function" title="ES6 函数的扩展">ES6 函数的扩展</a></p>
<h3 id="Array-proptotype-map"><a href="#Array-proptotype-map" class="headerlink" title="Array.proptotype.map"></a>Array.proptotype.map</h3><p><code>Array.prototype.map</code>，参数为函数，函数的参数为数组中的一个值，对数组的每一个值执行一个操作，并把需要的值 return 出来，每一项 return 出来的值构成一个新的数组，不改变原数组。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数这里也没有用到特殊的操作，与上一节一致 （</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>主要是数组的解构赋值以及扩展运算符的结合。</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h3><p>第一行代码还是比较好理解的，平常也用的比较多，即提取出对象对应 key 的 value，用 es5 重写:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">key, object</span>) </span>&#123;</span><br><span class="line">  key = key === <span class="literal">undefined</span> ? <span class="string">&quot;&quot;</span> : key;</span><br><span class="line">  object = object || &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> object[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但 es6 的写法清晰很多，<strong>默认参数可以让代码阅读更加明了，可以一目了然的看出哪些参数必须传，哪些参数可以不传，不需要查看函数内部，除此之外，还可以便于后期的迭代，如果之后不需要这个参数了，在对外接口中彻底拿掉这个函数，也不会导致不可用的问题出现。对于是否设置默认参数，要根据当前实际情况来看，如果参数有被遗漏的情况，则最好加上默认参数。</strong></p>
<h3 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h3><p>作用：将一个由对象组成的数组中的每一项(<code>object</code>)中对应的(<code>field</code>)取出，并组成一个新的数组，需要注意的一点，对于数组中某一项没有对应的 key 的时候，不会跳过而是得到<code>undefined</code>，即长度始终保持与对象数组一致。</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objs = [&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">c</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">pluck(key, objs); <span class="comment">// [1, undefined, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h3><p>与第二行形式结构一致，唯一不同的是 map 内参数函数的返回值。因此只需了解第四行代码即可。</p>
<h3 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h3><p>首先要注意的就是参数的命名，从<code>pick</code>中的<code>field</code>变为了<code>fields</code>，从函数体可以了解到该函数的功能： <strong>采用递归的形式，取得对象更深层对象的属性值</strong></p>
<p>用一个例子就很好解释:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个具有多重对象嵌套的对象</span></span><br><span class="line"><span class="keyword">let</span> example = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="string">&quot;a.b.c&quot;</span>; <span class="comment">// 即点操作符，取出c的值</span></span><br><span class="line">deepPluck(keys, example); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析代码的过程就是一个拆解代码的过程，将一个看似复杂的代码段逐步拆解，分解成一个个的小的易懂的片段，最后将其组合即可。分析后最好再自己实现一遍以加深印象。</p>
]]></content>
      <categories>
        <category>深入理解</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理（二）—— base</title>
    <url>/2017/09/29/comb-base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>何为 base？</p>
<a id="more"></a>

<p><code>&lt;base&gt;</code> 是一个标签，必须写在 <code>&lt;head&gt;&lt;/head&gt;</code> 内</p>
<p>有什么用？</p>
<hr>
<p>引用 w3school 的原话：</p>
<blockquote>
<p><code>&lt;base&gt;</code> 标签为页面上的所有链接规定默认地址或默认目标。 通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。 使用 <code>&lt;base&gt;</code> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 <code>&lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt;</code> 标签中的 URL。</p>
</blockquote>
<p>也就是说，假如我们有一张图片，文件名为 <code>demo.jpg</code>，处于与 html 的同级目录，我们在 html 文件内这样引入 <code>&lt;img src=&quot;./demo.jpg&quot;&gt;</code>，在未设置<code>&lt;base&gt;</code>的时候，浏览器自动帮我们解析成绝对路径，假设域名为: <code>blog.wingsico.org,</code> html 文件处于 <code>blog.wingsico.org/index.html</code>, 则我们在 html 内部引用的图片的路径被自动补充为  <code>blog.wingsico.org/demo.jpg</code>。但是当我们设置<code>&lt;base href=&quot;www.w3school.com.cn/i/&quot; /&gt;</code> 则 html 文件内的图片路径被自动补充为  <code>www.w3school.com.cn/i/demo.jpg</code>。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>href(required)</code> 其值为一个 URL，用于规定页面中所有相对链接的基准 URL。 <code>target(可选)</code> 其值与锚标签中的一致，有</p>
<ul>
<li>_blank</li>
<li>_parent</li>
<li>_self</li>
<li>_top</li>
</ul>
<p>规定在何处打开页面中所有的链接。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前没有见过这个标签，所以就专门去查看了一番，不过也是一个不常用的标签，使用不当容易造成一些路径丢失，资源无法找到的一些情况。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>w3school , 相关链接：<a href="http://www.w3school.com.cn/tags/tag_base.asp">http://www.w3school.com.cn/tags/tag_base.asp</a></li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>知识梳理</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理（四）—— DOCTYPE 深入剖析</title>
    <url>/2017/10/09/comb-doctype/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前写代码的时候，编辑器曾报了一个很诡异的错误，不知道为什么，总是有各种红色的波浪线遍布代码，那时候一头雾水，完全不知道发生了什么。</p>
<a id="more"></a>

<p>经过一番查找，发现把 <code>&lt;!DOCTYPE html&gt;</code>加上后就正常了，当时也没有细想，反正 bug 解决了（=。=）现在回过头来，觉得需要弄懂这个东西。</p>
<p>那么问题来了，何为 <code>doctype</code> ？在我们搞懂这个之前，我们需要先来了解一下 <code>DTD</code></p>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><p>DTD（ Document Type Definition）意思是文档类型声明或者文档类型定义，诶这都是英译过来的，无关紧要。但说到 DTD，又得延伸一个概念叫做 SGML.</p>
<h2 id="SGML"><a href="#SGML" class="headerlink" title="SGML"></a>SGML</h2><p>SGML(Standard Generalized Markup Language，SGML），翻译过来是标准通用标记语言，引用来自维基百科的概述：</p>
<blockquote>
<p><strong>标准通用标记语言</strong>（Standard Generalized Markup Language，<strong>SGML</strong>）是现时常用的<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC" title="超文本">超文本</a>格式的最高层次标准，是可以定义标记语言的<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E8%AA%9E%E8%A8%80" title="元语言">元语言</a>，甚至可以定义不必采用&lt; &gt;的常规方式。由于它的复杂，因而难以普及。</p>
</blockquote>
<p>虽然 SGML 在翻译上翻译过来是一种语言，但根据我查阅相关资料以及思考觉得，SGML 更像是一个规范或者称为标准。 在之后的翻阅中，又看到了之前忽略的在维基百科上的一句话：</p>
<blockquote>
<p>同时它（SGML）也是一个 ISO 标准：”ISO 8879:1986 Information processing – Text and office systems – Standard Generalized Markup Language (SGML)”</p>
</blockquote>
<p>至于 ISO 是什么，这里直接引用一段<a href="https://www.iso.org/about-us.html">ISO 官网</a>的介绍：</p>
<blockquote>
<p>ISO is an independent, non-governmental international organization with a membership of 162 <a href="https://www.iso.org/members.html" title="An alphabetically ordered list of all ISO members">national standards bodies</a>. Through its members, it brings together experts to share knowledge and develop voluntary, consensus-based, market relevant International Standards that support innovation and provide solutions to global challenges.</p>
</blockquote>
<p>大概意思就是说明 ISO 是一个独立的非政府国际组织，拥有 162 个 <a href="https://www.iso.org/members.html" title="所有ISO成员的按字母顺序排列的列表">国家标准机构</a>。通过其成员汇集专家，分享知识，制定自愿的，基于共识的市场相关的国际标准，支持创新并为全球挑战提供解决方案。说白了就是一个制定标准的一个组织，其制定的标准一般拥有一个编号，像 SGML 就是 ISO 8879。 ISO 不是我们这里介绍的重点，暂且跳过他，继续阐明 SGML 为何物。 下面看一个 SGML 的一个具体的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">QUOTE</span> <span class="attr">TYPE</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">typically something like <span class="tag">&lt;<span class="name">ITALICS</span>&gt;</span>this<span class="tag">&lt;/<span class="name">ITALICS</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">QUOTE</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实从上面引用的那张图片也可以看出来一些端详。它的结构一般由以下四个部分组成：</p>
<ol>
<li>SGML 声明，设定基本情况；</li>
<li>定义 DTD 文档类型，设定标记语言结构的语法；</li>
<li>描述用于标记的语义规格说明，做出了 DTD 表达的语法限制；</li>
<li>包含数据和标记的文档实例。</li>
</ol>
<p>像 HTML 的前身就是 SGML，你会发现 HTML 的结构与 SGML 十分相似，SGML 可以规范如何开始一个元素以及元素如何结束（或者称之为闭合），这是 SGML 的一种结构化的特点，至于其他的我就不一一举例，太繁琐，我这里直接给出它的特点的总结：</p>
<ol>
<li>正式的，能允许验证文档的正确性；</li>
<li>结构化的，能够处理复杂的文档；</li>
<li>可扩充的，能够支持大型信息存储的管理。</li>
</ol>
<p>像它的可扩充的特点，我们延伸出了 HTML（超文本标记语言），XML （扩展标记语言）。他们其实都是基于 SGML 标准的。 关于 XML，可以这样说：</p>
<blockquote>
<p>一方面，虽然 XML 源于 SGML，但它并不是 SGML 的替代物，XML 省去了 SGML 的许多功能，但 XML 可以和 SGML 兼容，使用 SGML 的人可以直接使用 XML 在网络上交换数据，而不必转换已有的 SGML 文档；另一方面，XML 和 HTML 是互相补充的，HTML 关于用户的界面，XML 关于数据链路，动态的 HTML 描述显示界面和用户交互活动，XML 描述信息，所以两者结合，XML 可以向 HTML 文档增加信息，而 HTML 可以显示以 XML 格式表达的信息。一般认为，XML 的目标就是：能在 INTERNET 上直接使用；与 SGML 兼容；支持大范围的应用；XML 文档易于创建、清晰易读、设计简单明了；易于编写处理 XML 文档的软件。XML 立志于在 WEB 内建立真实世界的知识影像，针对 HTML 和 INTERNET 的标准、可扩展、通用的数据格式，灵活地表示各种各样、自我描述的信息。XML 可以向 INTERNET 的数据增加结构，这有助于在 WEB 上实现任何人、任何地方的任何事物的通信。</p>
</blockquote>
<p>现在，我们有了 SGML，DTD，XML，HTML 四个（语言？）的一个定义与理解，需要把他们联系在一起了。 。。。联系个毛线，我都不懂自己在写啥玩意了。 一句话解释吧： <strong>HTML/XML 的 DOCTYPE 声明引用 DTD，DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容，DTD 概念缘于 SGML，每一份 SGML 文件，均应有相对应的 DTD，SGML 是标记语言的元语言。</strong></p>
<p>在前端日常使用 DOCTYPE 中，目前来说只需要注意标注&lt;!DOCTYPE&gt;即可，这是最新的 HTML5 的 DOCTYPE 规范标准的写法，不会有任何问题（？），由于 HTML4.01 的时代即将过去，关于 HTML4.01 的一些常用的 DOCTYPE 声明我也不一一列举，在下面给出资料链接吧，整篇博客到此结束，我或许一辈子都用不上这 SGML 这玩意，及时打住，好像才是最好的选择。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.w3school.com.cn/tags/tag_doctype.asp">http://www.w3school.com.cn/tags/tag_doctype.asp</a>  HTML &lt;!DOCTYPE&gt; 标签 - w3c</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89</a>  维基百科 DTD</li>
<li><a href="https://www.iso.org/about-us.html">https://www.iso.org/about-us.html</a> ISO 介绍</li>
<li><a href="http://tech.163.com/04/1103/21/149VOTK30009rt.html">http://tech.163.com/04/1103/21/149VOTK30009rt.html</a> 《HTML 的兄弟姐妹们》</li>
<li><a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80/10471466?fromtitle=SGML&fromid=2901416">https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80/10471466?fromtitle=SGML&amp;fromid=2901416</a>    百度百科 - SGML</li>
<li><a href="https://www.w3.org/TR/WD-html40-970708/intro/sgmltut.html">https://www.w3.org/TR/WD-html40-970708/intro/sgmltut.html</a>  《A brief SGML tutorial》</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>知识梳理</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理（一）—— 实体符号</title>
    <url>/2017/09/29/comb-entity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于 HTML 中实体符号的梳理</p>
<a id="more"></a>

<h2 id="什么是实体符号"><a href="#什么是实体符号" class="headerlink" title="什么是实体符号"></a>什么是实体符号</h2><p>实体符号被用作实现一些保留字符如(&lt;)(&gt;)或表达键盘一些无法输入的字符，在 HTML 中他们会被误认为标签。如果希望正确的显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。</p>
<h2 id="实体符号举例"><a href="#实体符号举例" class="headerlink" title="实体符号举例"></a>实体符号举例</h2><p>字符实体类似这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;entity_name;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;#entity_number;</span><br></pre></td></tr></table></figure>

<p>如 <code>&amp;copy;</code> 或 <code>&amp;#169;</code></p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ol>
<li>使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。</li>
<li>HTML 中的常用字符实体是不间断空格 <code>&amp;nbsp;</code> 。浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 <code>&amp;nbsp;</code> 字符实体。</li>
<li>实体名称对大小写敏感。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前对实体符号的认识仅限于 <code>&amp;nbsp;</code> 虽然实体符号用的地方不多，但是我觉得还是需要了解，留作此片博客，以便需要用到的时候翻阅。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>w3cschool——字符实体，地址：<a href="http://www.w3school.com.cn/tags/html_ref_entities.html">http://www.w3school.com.cn/tags/html_ref_entities.html</a></li>
<li>HTML 实体字符，地址：<a href="https://www.waitig.com/html%E5%AE%9E%E4%BD%93%E7%AC%A6%E5%8F%B7%E4%BB%A3%E7%A0%81.html">https://www.waitig.com/html%E5%AE%9E%E4%BD%93%E7%AC%A6%E5%8F%B7%E4%BB%A3%E7%A0%81.html</a></li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>知识梳理</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理（六）—— iframe</title>
    <url>/2017/10/13/comb-iframe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以前一直觉得这个 iframe 标签特别神秘，因为之前在解决设置 title 时使用<code>document.title = &quot;xxx&quot;</code>在 ios 上的微信端失效，就是使用了一段关于 iframe 的 js 代码完成的，应该是可以称为一种 <code>iframe hack</code> 吧～，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//利用iframe的onload事件刷新页面</span></span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  iframe.style.visibility = <span class="string">&quot;hidden&quot;</span>;</span><br><span class="line">  iframe.style.width = <span class="string">&quot;1px&quot;</span>;</span><br><span class="line">  iframe.style.height = <span class="string">&quot;1px&quot;</span>;</span><br><span class="line">  iframe.src = <span class="string">&quot;./favicon&quot;</span>; <span class="comment">// 这里是必须的</span></span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>不过据考证资料，该 <code>iframe hack</code> 对最新内核已经失效，不过并不影响我学习 iframe，毕竟我现在还没有在做微信，等以后再踩踩这些坑好了。</p>
<h2 id="iframe——内联框架"><a href="#iframe——内联框架" class="headerlink" title="iframe——内联框架"></a>iframe——内联框架</h2><p>引用一段 <a href="http://www.thoughtco.com/">www.thoughtco.com</a> 中的一段原文，描述了 iframe。</p>
<blockquote>
<p>Inline frames, commonly just referred to as “iframes”, are the only type of frame allowed in HTML5. These frames are essentially a section of your page that you “cut out”. In the space that you have cut out of the page, you can then feed in an external webpage. In essence, an iframe is another browser window set right inside your web page. You see iframes commonly used on websites that need to include external content like a Google map or a video from YouTube. Both of those popular websites use iframes in their embed code.</p>
</blockquote>
<p>翻译过来用我的话来说就是：<strong>iframe 是一个 HTML5 的框架元素，它允许你在一个网页内引入另一个浏览器窗口（仅作展示和使用)，相当于在一个浏览器窗口内切出了另一个窗口去展现外部网站的内容，比如，在博客内引用 codepen 中的在线代码效果演示，就是使用的 iframe，还有一些视频、音乐和地图之类的的引入也会使用 iframe，总之，iframe 在各大网站均有被使用。</strong></p>
<p>iframe 在 HTML4.01 和 HTML5 中均可使用，其共有四个基本属性：</p>
<ol>
<li><p><code>src = &quot;url&quot;</code>: 指定一条 url，表示该框架所指向的外部页面的链接，比如说：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>您的浏览器不支持iframe<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 这是一个指向百度首页的 iframe</p>
</li>
<li><p><code>width = &quot;&quot; / height = &quot;&quot;</code>: 设置 iframe 的宽高，单位为 px，举个例子：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>您的浏览器不支持iframe&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>name = &quot;&quot;</code>: 设置 iframe 的名称。 有三种用法：</p>
<ol>
<li><p>作为 javascript 的引用元素</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>您的浏览器不支持iframe&lt;/iframe</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe_a = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;iframe_a&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 同等于</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe_a = <span class="built_in">window</span>.frames[<span class="string">&quot;iframe_a&quot;</span>];</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iWindow = iframe_a.contentWindow; <span class="comment">// 拿到iframe_a的window对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> idoc = iWindow.document; <span class="comment">// 获取iframe的document</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为 a 标签和 form 标签的 target 属性的值</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>您的浏览器不支持iframe&lt;/iframe</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.ncuos.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>将iframe指向云家园<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<pre><code>3.  作为 input 和 button 的 formtarget 的值
    <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span>您的浏览器不支持iframe<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;form_action.asp&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">formtarget</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>提交数据1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">formtarget</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>提交数据2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

    点击这两个按钮不会有任何反应，因为 formtarget 的作用就是： **Specifies where to display the response that is received after submitting the form (for type=&quot;submit&quot; and type=&quot;image&quot;)** 翻译过来的意思就是 formtarget 将请求后得到的 response 在 formtarget 的值中展现出来，在这里即是在 iframe 中展示出来。</code></pre>
<p>在新增的 HTML5 中，iframe 又多了 3 个新属性，分别是<code>sandbox</code>,<code>seamless</code>,<code>srcdoc</code>.</p>
<h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><p>首先，先说一下 sandbox 属性，sandbox &lt;=&gt; 沙箱，相信用过杀毒软件的人应该知道，360 就有一个隔离沙箱，所以这个属性就是为了安全性考虑而设计的，用作隔离 iframe 和当前页面。 这个是来自菜鸟教程的一个介绍：</p>
<blockquote>
<p>如果指定了空字符串（sandbox=””），该属性对呈现在 iframe 框架中的内容启用一些额外的限制条件。 sandbox 属性的值既可以是一个空字符串（将会启用所有的限制），也可以是用空格分隔的一系列指定的字符串。 HTML 5 通过 sandbox 属性提升 iFrame 的安全性。sandbox 属性可以防止不信任的 Web 页面执行某些操作。</p>
</blockquote>
<p>具体用法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">sandbox</span>=<span class="string">&quot;value&quot;</span>&gt;</span>沙盒隔离<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>既然称之为沙盒，那他可以做些什么来提高安全性呢？</p>
<ul>
<li>将内容视为来自独特来源</li>
<li>不能发送 ajax 请求</li>
<li>阻止脚本执行</li>
<li>禁用 API（不能使用本地存储等）</li>
<li>阻止链接定位到其他浏览上下文</li>
<li>防止内容使用插件（通过<code>&lt;embed&gt;</code>，<code>&lt;object&gt;</code>，<code>&lt;applet&gt;</code>或其他）</li>
<li>阻止内容导航其顶层浏览上下文</li>
<li>阻止自动触发功能（如自动播放视频或自动对焦表单控件</li>
<li>不能发送表单</li>
</ul>
<p>具体如何限制 iframe 的操作呢？ 首先，sandbox 的值可以多值组合使用，如同 class 属性一样可以填写许多类名。其次，它的单值共有 7 个：</p>
<ul>
<li>“” (no-value)</li>
<li>allow-same-origin</li>
<li>allow-top-navigation</li>
<li>allow-pointer-lock</li>
<li>allow-popups</li>
<li>allow-scripts</li>
<li>allow-forms</li>
</ul>
<p>当为空值的时候，即<code>sandbox=&quot;&quot;</code> 或 <code>sandbox</code> 时，所有的限制都将启用； 当为<code>allow-same-origin</code>时，该嵌入的内容将会被当做同源来看待，当使用此属性时，适用于两种情况：</p>
<ol>
<li>若同一站点的内容被沙盒禁用脚本，但通过设置该值可以允许 Iframe 访问沙盒内容的 DOM</li>
<li>当嵌入的是一个第三方的站点，它可以阻止该站点打开弹窗，弹出广告等等，但不阻止该嵌入的页面回到其原始站点，或使用数据库 API 存储数据等等</li>
</ol>
<p>当为<code>allow-top-navigation</code>时，允许该嵌入的内容导航到其顶层浏览的上下文处，这是什么意思呢？即是允许 iframe 主导 window.top 进行页面跳转，还不明白？何为 window.top，就是顶层窗口，即是浏览器窗口，就是说 iframe 可以控制浏览器跳转至其他页面，也就是父级（顶级）页面被重定向至其他网页。大概就是这个么意思，还不明白我也木有办法了=。= 当含有<code>allow-pointer-lock</code>时，可以在 iframe 中锁定鼠标 当含有<code>allow-popus</code>时，允许 iframe 中弹出新窗口，比如 <code>window.open.target=&quot;_blank&quot;</code> 当含有<code>allow-scripts</code>时，允许 iframe 执行脚本 当含有<code>allow-forms</code>时，允许提交表单的操作 当然，直接使用一个 sandbox 的空值的很少的情况，我们经常使用如下代码来开放一些特定的权限：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">sandbox</span>=<span class="string">&quot;allow-scripts allow-same-origin allow-scripts&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>您的游览器不支持iframe。&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="srcdoc"><a href="#srcdoc" class="headerlink" title="srcdoc"></a>srcdoc</h2><p><code>srcdoc</code> 属性制定要在 iframe 内显示的页面的 HTML 内容 举个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">  src=&quot;https://www.baidu.com&quot;</span><br><span class="line">  width=&quot;200&quot;</span><br><span class="line">  height=&quot;200&quot;</span><br><span class="line">  sandbox=&quot;allow-scripts allow-forms allow-same-origin&quot;</span><br><span class="line">  srcdoc=&quot;<span class="tag">&lt;<span class="name">p</span>&gt;</span>hello,srcdoc!<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&quot;</span><br><span class="line">  &gt;您的浏览器不支持iframe&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="seamless"><a href="#seamless" class="headerlink" title="seamless"></a>seamless</h2><p><code>seamless</code> 属性属于逻辑属性。当设置了该属性后，它规定了 iframe 看上去像是包含文档的一部分（无边框或无滚动条) 举个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">  src=&quot;https://www.baidu.com&quot;</span><br><span class="line">  width=&quot;200&quot;</span><br><span class="line">  height=&quot;200&quot;</span><br><span class="line">  sandbox=&quot;allow-scripts allow-forms allow-same-origin&quot;</span><br><span class="line">  &gt;您的浏览器不支持iframe&lt;/iframe</span><br><span class="line">&gt;</span><br><span class="line">&lt;iframe</span><br><span class="line">  src=&quot;https://www.baidu.com&quot;</span><br><span class="line">  width=&quot;200&quot;</span><br><span class="line">  height=&quot;200&quot;</span><br><span class="line">  sandbox=&quot;allow-scripts allow-forms allow-same-origin&quot;</span><br><span class="line">  seamless</span><br><span class="line">  &gt;您的浏览器不支持iframe&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下: 您的浏览器不支持 iframe 您的浏览器不支持 iframe ！看起来没有效果，不对啊，Chrome 浏览器不是支持该属性吗！不是很理解这个属性，标记一下！</p>
<hr>
<p>内容略多，待跟进，由于 iframe 使用方面略少，以及还有一些安全性的问题的深究，暂且对我目前学习意义不大，待有时间可以学习一下 iframe 跨域以及轮询（感觉 iframe 真是一个很牛掰的东西），有时间再补充吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.w3.org/TR/2010/WD-html5-20100624/the-iframe-element.html#attr-iframe-sandbox">https://www.w3.org/TR/2010/WD-html5-20100624/the-iframe-element.html#attr-iframe-sandbox</a></li>
<li><a href="https://segmentfault.com/a/1190000004502619">https://segmentfault.com/a/1190000004502619</a></li>
<li><a href="http://www.w3school.com.cn/tags/tag_iframe.asp">http://www.w3school.com.cn/tags/tag_iframe.asp</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>知识梳理</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理（三）—— lang</title>
    <url>/2017/09/29/comb-lang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对 html 中 lang 属性做简单的梳理</p>
<h2 id="lang-是什么"><a href="#lang-是什么" class="headerlink" title="lang 是什么"></a>lang 是什么</h2><p>lang 是元素的一个属性，它相当于 language（语言）的意思。</p>
<h2 id="lang-有什么用"><a href="#lang-有什么用" class="headerlink" title="lang 有什么用"></a>lang 有什么用</h2><p>lang 属性规定元素内容的语言。比如谷歌浏览器根据你的代码<code>&lt;html lang=&quot;en&quot;&gt;</code>就会知道你的网页是英文的，就会问你是否需要翻译成中文。 总之，lang 是给搜素引擎使用的，并不影响页面内容，因此设置了<code>&lt;html lang=&quot;en&quot;&gt;</code>你的页面还是能够显示各种语言，但是我们仍应该遵守标准，毕竟这个属性对浏览器和搜索引擎还是有作用的。</p>
<h2 id="为什么要设计-lang-属性"><a href="#为什么要设计-lang-属性" class="headerlink" title="为什么要设计 lang 属性"></a>为什么要设计 lang 属性</h2><p>引用于另一篇博客：</p>
<blockquote>
<p>设计 lang 属性是为了向用户提供语言特有的显示，尽管它对主要的浏览器具有较小的影响。使用 lang 属性后，真正受益的是搜索引擎(搜索引擎利用它能够告诉用户采用哪一种语言编写文档)、屏幕阅读器(屏幕阅读器利用它能够以不同的方式发音不同的语言)以及一些应用程序(应用程序能够在它们不支持所提供的语言或者该语言与它们的默认语言不同时向用户发出警报)。当 lang 属性用于 <code>&lt;html&gt;</code> 元素中时，它将作用于整个文档；而在用于其他元素中时，它将仅作用于这些元素的内容。</p>
</blockquote>
<h2 id="如何使用-lang-属性"><a href="#如何使用-lang-属性" class="headerlink" title="如何使用 lang 属性"></a>如何使用 lang 属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">lang</span>=<span class="string">&quot;language_code&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 element 代指元素名称，language_code 代表语言编码，如 en 表示英语，zh-CN 表示简体中文等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个看似不起眼的小属性其实涵盖了国际语言规范的许多东西，在这里 mark 一下，以便以后需要用到的时候再使用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong><a href="https://www.zhihu.com/question/20797118">网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？</a></strong> ——来自知乎</li>
<li>**<a href="https://www.w3.org/International/articles/language-tags/">Language tags in HTML and XML</a> **——来自 w3c</li>
<li><a href="http://www.ruanyifeng.com/blog/2008/02/codes_for_language_names.html"><strong>语种名称代码</strong></a>——来自阮一峰</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>知识梳理</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理（五）—— 语义化的深入剖析</title>
    <url>/2017/10/11/comb-semanticization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近代码写的较少了，于是回顾了一下自己以前的代码，看了一看自己第一次写的网页——百度首页，许多标签混用，无意义的 div 标签嵌套，img 无 alt 属性，class 命名（拼音首字母）之类的，极其缺失语义化以及结构化。</p>
<a id="more"></a>

<p>自己步入前端也有一年了，自己在写代码的时候也总是有意无意的使用 div 标签，甚至心里有一种这样的想法：</p>
<p><strong>标题干嘛要用 h1~h6 啊，我并不想要标题加粗，直接用 p 吧，还省事，不要去设置 css。什么 header、footer 完全没必要啊，又没有加任何特殊的样式。</strong></p>
<p>在之后了解过一些 html 语义化之后才知道之前的这些想法有多么肤浅和愚蠢，但在之前的认知中中，对于语义化的认识也仅仅是这样：</p>
<p><strong>语义化就是为了让标签做他该做的事情，使结构更加清晰，方便代码的阅读和维护。</strong></p>
<p>但在经过一下午的学习过程中，我发现语义化并没有那么的简单。</p>
<h2 id="HTML-语义化历史"><a href="#HTML-语义化历史" class="headerlink" title="HTML 语义化历史"></a>HTML 语义化历史</h2><p>我们先来说说 HTML 吧，HTML 一般被我们称之为网页，是与网络相关在一起的，当下时代网络是以 World Wide Web （Web， 万维网）为主导的，我们通过一串 URL 来定位到资源，通过特定的协议来访问以获取我们所需要的资源。这样的资源均是(?)通过 HTML 来展示的，所以 HTML 最初的目的就是为了发布 web 的资源内容以及方便人们进行索引。 目前，HTML 主要用来：</p>
<ol>
<li>发布文档（文本，表格，列表…）</li>
<li>通过超链接获取信息</li>
<li>建立用来访问远程服务的表单</li>
<li>发布 web 应用</li>
</ol>
<p>但慢慢的随着 Web 规模不断的扩大，信息量之大已经不在人工处理的范围之内了，搜索引擎就应景而生，人们又设计了各种程序来对结构良好，索引好的内容进行处理和挖掘。这时候，为了能让机器更好的读懂 web 上的各种内容，语义化就显得越来越重要了。 最初的 HTML 是有一定的语义化的，比如说 h1~h6 是代指标题，img 表示图片，table 表示表格，p 表示段落等等，但这些更多的只是为了让 UA（User Agent）对这些元素进行更好的处理，并没有明确语义化的重要性，由于现在许多内容是为了网页的可视化设计的，机器对于这些是很难与有用的信息区分开来的，于是现在就提出了两种途径来解决这个问题：</p>
<ol>
<li>提高技术，让机器越来越能够像人类思考，读懂人能够看懂，读懂的东西。</li>
<li>推广规范，让在编码之初就以一种能让机器读懂的方式来进行编码，即使用被广泛认可的语义信息来描述内容。（很显然，XML 和 HTML5 就是往这个方向上进发）</li>
</ol>
<p>第一条途径就是横轴，把 AI 的水平提升到人类的水平，第二条途径是纵轴，朝着语义化的方向前进，也就是万维网创始人 Tim Berners-Lee 爵士提出的美好愿景：语义网。</p>
<blockquote>
<p>语义网：简单来说就是让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读。</p>
</blockquote>
<p>两条路都很艰难，但实际上我们正在以第二条途径进行努力，这也是 HTML5 出现的原因之一，删除了一些纯表现的标签，以及为一些标签丰富了语义，还有增加了许多富有语义的新标签。其实不仅是标签，同样的，许多属性，如 rel，如 role 等等都是为了更好的去促成语义化的实现。 同时，HTML5 并不是语义化规范的唯一依仗，除了 W3C 和 WHATWG 外，还有其他组织在为 web 语义化、标准化作出努力。</p>
<blockquote>
<p>例如 microformats 社区以及 <a href="https://link.zhihu.com/?target=http://Schema.org">http://Schema.org</a> 上都有对 HTML 以及 Microdata（<a href="https://link.zhihu.com/?target=http://www.w3.org/TR/html5/microdata.html">http://www.w3.org/TR/html5/microdata.html</a>） 规范的扩展词汇表，Google、Bing、Yahoo! 等搜索引擎以及各个主流浏览器都不同程度地接纳了其中定义的语义扩展，并应用在了生产中。</p>
<p>作者：顾轶灵 链接：<a href="https://www.zhihu.com/question/20455165/answer/15176745">https://www.zhihu.com/question/20455165/answer/15176745</a> 来源：知乎</p>
</blockquote>
<p>这些都是语义化的一些背景，那么我们可以从哪些方面来更好的语义化呢？</p>
<h2 id="更好的语义化"><a href="#更好的语义化" class="headerlink" title="更好的语义化"></a>更好的语义化</h2><ol>
<li><p>尽量避免无意义的 div 嵌套</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- not good --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>一段描述性的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一段描述性的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每一个标签做他该做的事情</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.head-title</span> &#123;</span></span><br><span class="line">    font-weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-title&quot;</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- not good --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;head-title&quot;</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用更加有语义化的标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Warning!<span class="tag">&lt;/<span class="name">b</span>&gt;<span class="name">There</span></span> is a meeting...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- not good --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Warning!<span class="tag">&lt;/<span class="name">strong</span>&gt;<span class="name">There</span></span> is a meeting...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>清晰的了解每一个标签所代表的具体语义，不随意使用标签</p>
</li>
<li><p>更加清晰的 class，id 命名</p>
<p>关于这一点，这里有个链接，专门说的是 class 的类名在语义化上的使用：<a href="http://www.oschina.net/translate/about-html-semantics-front-end-architecture">http://www.oschina.net/translate/about-html-semantics-front-end-architecture</a> 我自己的理解大概就是： <strong>每一个类名都要有目的，有意义，不取无意义的类名，类名与内容解耦，往往大多数可重用的组件它的类名与内容是没有太大关联的，同时，我们应多使用“多类”模式，使它更有收缩性，以及可维护性，而不是把所有的样式堆积在一个类名上。</strong></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一番学习，我对语义化有了更深层的认识：</p>
<p><strong>语义化</strong>在目前来说更多的是为了让机器能读懂网页的内容，使 HTML 更加结构化、规范化，便于搜索引擎的爬虫的抓取，爬虫依赖标记来获取上下文以及关键字的权重，利于 SEO；同时代码更加容易维护，方便他人阅读；在 CSS 加载失败后扔能保持一定的良好的结构，不会造成页面内容缺失等等。</p>
<p>由于现在已经步入 HTML5 的时代，了解新增以及改变的元素的语义显得十分重要，我查阅资料后找到一篇，对每一个语义化的元素都讲述的比较清楚，同时还介绍了目前在语义化比较火的微数据(micro data)，写的很好，这里我就不一一列举语义元素了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/semantic-html.html">https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/semantic-html.html</a>    前端工程师开发手册</li>
<li><a href="https://www.zhihu.com/question/20455165">https://www.zhihu.com/question/20455165 </a> 如何理解 Web 语义化</li>
<li><a href="http://justineo.github.io/slideshows/semantic-html/#/">http://justineo.github.io/slideshows/semantic-html/#/</a>  Semantic HTML</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>知识梳理</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识梳理 —— this的深入理解</title>
    <url>/2017/10/20/comp-this/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>勾起我有想法去写这样一个文章，一是因为我从来没有总结过 this 的用法，也经常对这个概念有些模糊；二是在学习 ES6 的时候，被一个简单的例子给弄懵了，感觉自己之前学的好像是假的？</p>
<a id="more"></a>

<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">doSomething(); <span class="comment">// 很明显，打印的是Window对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnother = doSomething.bind(obj);</span><br><span class="line">doAnother(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">doSomething.call(obj); <span class="comment">// Window</span></span><br><span class="line">doSomething.apply(obj); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>这下我就很懵逼了，在我之前的认知中 this 是这样的：</p>
<p><strong>在函数内部时，this 指向的是函数运行时所在的上下文，<br>且通过 <code>bind/call/apply</code> 可以改变函数内部的 <code>this</code> 指向，指向其第一个参数(type =&gt; Object).</strong></p>
<p>这让我很慌，于是将代码改成了这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">doSomething(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnother = doSomething.bind(obj);</span><br><span class="line">doAnother(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line">doSomething.call(obj); <span class="comment">// obj</span></span><br><span class="line">doSomething.apply(obj); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>

<p>诶，这个时候又很正常，跟我的理解来看没有偏差，于是认定是箭头函数的关系。 于是去阮一峰看了一下箭头函数的相关描述，又参考了另外几篇博客以及一些例子之后，我觉得自己已经弄得比较明白了，关于上面那题，容我先卖个关子，这篇博客主要目的不在于解决这个问题，而更多的是为了彻底理清 this 在各种情况以及在普通函数和箭头函数之间表现的差别。所以，我们一步步从简单的开始。</p>
<hr>
<h2 id="理解-this"><a href="#理解-this" class="headerlink" title="理解 this"></a>理解 this</h2><p>什么是 this 呢？很久以前，大概刚学 js 没多久，我知道 js 不像 c/c++，他是没有指针的，但我记得有人跟我说过，this 就相当于一个指针，且这个指针是根据其所处的执行环境不同而指向不同，且<strong>this 永远指向的都是一个对象</strong></p>
<p>这条性质决定了我们如何使用 this，在定义类中，也就是构造器函数中，我们通常使用<code>this.xxx</code>来定义公共实例变量。在使用对象的时候，我们也经常使用<code>obj.xxx</code>来使用其属性，从用法上来看，点操作符一般只存在于对象中，也可以从侧面再说明 this 指向的就是一个对象。我们来举个例子来说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="keyword">typeof</span> <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jack = <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>); <span class="comment">// Person &#123; name: &quot;jack&quot; &#125; &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，还要理解的就是一个概念就是：</p>
<p><strong>在绝大多数情况下，在普通函数内部，this 的指向由函数执行的环境决定。<br>也就是说，this 在函数执行期间才被绑定到调用该函数时所处的上下文中，而不是声明时候所处的上下文。</strong></p>
<p>可能上面这句话还不是特别好理解，那么我来举几个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wtf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// Window</span></span><br><span class="line">wtf(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>可能有人又会有疑问了： 直接调用 fn()很容易理解，因为调用 fn 所处的上下文为 Window 对象，所以打印 Window，但是调用 wtf 时，fn 明明在 wtf 的内部调用的啊，为什么不指向 wtf 呢？ 这很容易理解，我们来把上述函数更改一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wtf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.fn === fn); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">window</span>.fn(); <span class="comment">// Window</span></span><br><span class="line">  fn(); <span class="comment">// Window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下就很清晰易懂了，在 wtf 函数内部调用 fn()，他的实际执行上下文仍然为 Window 对象。 我们再来看一个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为普通函数调用时,this必须指向一个对象。那就是全局对象（在浏览器内是Window对象）。</span></span><br><span class="line"><span class="keyword">var</span> getA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">getA(); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象属性调用时，this指向的就是该对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getOtherA = obj.getA; <span class="comment">// 这里将 function() &#123; console.log(this.a) &#125; 赋给了getOtherA，但它的执行环境仍是全局环境中，其this指向Window</span></span><br><span class="line">getOtherA(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>根据以上的例子我们可以总结出：<strong>在普通函数内部，this 总是指向其执行环境上下文中，即要关注该函数的直接调用位置，再换种说法，即关注函数是如何调用的</strong></p>
<hr>
<p>那么，我们都有哪些调用方法呢？</p>
<h3 id="一、函数调用"><a href="#一、函数调用" class="headerlink" title="一、函数调用"></a>一、函数调用</h3><hr>
<p>来看一个简单的例子介绍函数调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = hello(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样一个函数名加上一个左开括号加上一个逗号分隔的参数表达式再加上一个右开括号，就会执行该函数对象的函数调用。 还有一个高级的是 IIFE，立即调用的函数表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello &#x27;</span> + name</span><br><span class="line">&#125;)(<span class="string">&#x27;world)</span></span><br><span class="line"><span class="string">console.log(message) // &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>IIFE 也是一个函数调用：第一对括号(function(name) {…})是一个表达式，它计算为一个函数对象，后跟一对带括号的’world’参数：(‘world’)。 理解了函数调用，我们再来看一下 this 在函数调用中的指向情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>);</span><br><span class="line">  <span class="built_in">this</span>.number = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>这里的 test()为 js 的函数调用，在执行期间，js 将函数内部的 this 绑定到了全局对象上，即 window 所以我们可以用一句话总结：<strong>this 在函数直接调用中总指向全局对象，全局对象是由执行环境决定的，在浏览器里，他是 window 对象</strong></p>
<p>再举个例子，更深的理解这句话：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">  action: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  doIt: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">strConcat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.action + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strConcat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = obj.doIt(); <span class="comment">// true, false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">// &quot;hello jack&quot;</span></span><br></pre></td></tr></table></figure>

<p>调用 obj.doIt 时，由于他是方法调用（在后面会说），显然 doIt 函数的上下文是 obj 对象，strConcat 函数是 doIt 里面定义的，你可能会想它和 doIt 一样，this 也指向 obj。 其实不然，我们在看我们的那句话，函数调用的 this 指向全局对象，而在这里就是 window，即使外部函数 doIt 有着 obj 作为函数对象，在这里也不会影响 strConcat 中 this 的指向。</p>
<p>函数调用的常见陷阱 this 是被认为在内部函数中与外部函数相同。<br>正确的应该是内部函数的上下文仅依赖于调用，而不依赖于外部函数的上下文。</p>
<hr>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程之curry</title>
    <url>/2018/03/15/functional-programming-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始学习函数式编程，对函数式编程有了更多的一点点认识，对函数的 curry 接触了一点点，以此作为记录，写下当前感悟</p>
<a id="more"></a>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>先来看一个常见的需求：</p>
<blockquote>
<p>现给定一个字符串： const STRING = “This is the mid day show with Cheryl Waters” 请将空格替换成”-“</p>
</blockquote>
<p>这是一个很简单的需求，很自然的写下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> replaceSpaceToStrike = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/ /g</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace(STRING);</span><br></pre></td></tr></table></figure>

<p>或者是写个更具有拓展性的函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> replace = <span class="function">(<span class="params">reg, replacement, str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, replacement);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;-&quot;</span>, STRING);</span><br></pre></td></tr></table></figure>

<p>发现参数多而杂乱。那么把它 curry 化我们应该如何去写:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> replace = <span class="function"><span class="params">what</span> =&gt;</span> <span class="function"><span class="params">replacement</span> =&gt;</span> <span class="function"><span class="params">str</span> =&gt;</span> str.replace(what, replacement);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> noSpaces = replace(<span class="regexp">/\s+/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cenosred = noSpaces(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">cenosred(STRING);</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>curry</code> 化在完成最终需求之前生成了许多 <code>curry 帮助函数</code>, 这里表明了一种 <strong>预加载函数</strong> 的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 相比于之前的解决方案，它需要更多的代码，但只需要参入一部分参数，就能的到一个新的函数。相对于之前的方案，它更加灵活，同时减少了同时传参的个数。 这个例子可能没有突出函数式 <code>curry</code> 化的优点，再举一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getChildren = <span class="function"><span class="params">x</span> =&gt;</span> x.childNodes; <span class="comment">// 获得一个节点的子节点</span></span><br></pre></td></tr></table></figure>

<p>这是针对一个元素的函数， 利用<code>curry</code>化，我们可以很容易扩展到数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="params">arr</span> =&gt;</span> arr.map(f);</span><br><span class="line"><span class="keyword">const</span> getAllChildren = map(getChildren);</span><br></pre></td></tr></table></figure>

<p>通常我们不定义直接操作数组的函数，因为只需内联调用 <code>map(getChildren)</code> 就能达到目的。这一点同样适用于 <code>sort</code>、<code>filter</code> 以及其他的 <strong>高阶函数（higher order function）</strong>（高阶函数：参数或返回值为函数的函数）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>curry</code> 函数用起来非常得心应手，使用它简直就是一种享受。它堪称手头必备工具，能够让函数式编程不那么繁琐和沉闷。 通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。 此外，我们还可以引入 <code>lodash</code> 和 <code>ramda</code> 中的 <code>curry</code> 函数，帮助我们更好的实现<code>curry</code>化。</p>
]]></content>
      <categories>
        <category>深入理解</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之图的应用</title>
    <url>/2018/01/02/graph/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在算法图解里看见了关于最短路径的求解，对于无权值的图，我们可以采用<code>广度优先搜索</code>算法，找出的是经过最少的边的路径，而对于含有<code>边权</code>的图，若要找到其<code>最短路径</code>（更好的称为<code>最快路径</code>），可采用另一种算法，即<code>狄克斯特拉算法</code></p>
<a id="more"></a>

<h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><p>据我所知，狄克斯特拉算法<code>只适用于有向无环图</code>，这是为什么呢？ 假设有一个环，<code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> -&gt; <code>B</code> -&gt; <code>A</code>，这意味着你可以从一结点出发，走一圈之后又回到了这个结点，假设在这个带环的图内，你要找出从起点到终点的最短路径，绕环前行是否合理呢？</p>
<p>你可以选择避开环，也可以选择包含环的路径。这两条路径都可以到达终点，但环增加了权重，所以绕环的路径不可能是最短的路径。对于无向图，意味着两个节点互相指着对方，其实就是环，在无向图中，每一条边的都是环。所以狄克斯特拉算法只适用于<code>有向无环图</code> <code>狄克斯特拉算法</code>能否找出含有负权值的边呢？</p>
<p>答案是不能:(，因为在<code>狄克斯特拉算法</code>中，对于处理过的结点，就意味着没有前往该结点的更快的路径，但若含有负权值的边，你知道如果包含负权值的话，会更快到达该结点，但是该算法不会再用负权值去处理这个结点，因此<strong>该算法只适用于不含有负权值的图</strong>。 狄克斯特拉算法的核心思想为:</p>
<ol>
<li>找出“最便宜的结点”，即可在最短时间内到达的结点</li>
<li>更新该结点的邻居，检查是或否有前往他们的更短路径，如果有，就更新其开销</li>
<li>重复这个过程，知道对图中的每个结点都这样做了</li>
<li>计算最终路径</li>
</ol>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>由上面的一些知识可得，狄克斯特拉算法适用于<code>有向无环图</code>和<code>不存在负权值的图</code>。但是实验给了一张<code>权值为正的无环图</code>，这就有一些懵逼了，那么我还如何使用<code>狄克斯特拉算法</code>去解决一个无向图呢？ 、</p>
<p>为了解决这个问题，先进入实验，从实验中得到解决的方法。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个大学校内交通咨询系统，能让旅客咨询从任一楼到其余所有楼之间的最短路径。</p>
<h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>输入：输入图的顶点数，以及边数。 输出：一幢楼到其他楼之间的最短路径。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>1.建立交通网络图的存储结构。 2.解决单源最短路径问题。</p>
<h3 id="实验分析与设计"><a href="#实验分析与设计" class="headerlink" title="实验分析与设计"></a>实验分析与设计</h3><p>由实验图我们可以看出，这是一个<code>不含有负权值边的无向图</code>，由我们有向图<code>狄克斯特拉算法</code>可以延伸出一种处理无向图的最短路径的算法。 首先，我们需要先建立一个图结构，这个图应该包含以下一些东西：</p>
<ul>
<li>图的顶点数</li>
<li>图的边数</li>
</ul>
<p>还有什么呢？因为我们处理的是<code>单源最短路径</code>，所以需要存储<strong>源点到各个点的距离</strong>；除此之外，我们需要保存一条边的顶点之间的联系，我们使用一个<code>邻接矩阵</code>来存储这之间的联系；还有就是，由算法的原理可以知道，到每一个点的最短路径会在每一轮就确定下来，因此我们需要存储已经确定了最短路径的结点。</p>
<p>综上，我们可以知道，这个图结构应该包含完整的以下内容：</p>
<ul>
<li>图的顶点数</li>
<li>图的边数</li>
<li>源点到各个顶点的初始路程</li>
<li>顶点与顶点之间的联系，即边权值</li>
<li>已经确定最短路径的结点</li>
</ul>
<p>因此，我们使用一个<code>结构体</code>作为图的结构，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_node_count = <span class="number">20</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Type AdjacencyList[max_node_count][max_node_count]; <span class="comment">// 邻接矩阵存储顶点与顶点之间的联系</span></span><br><span class="line">    Type distances[max_node_count]; <span class="comment">// distances数组，1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    Type shortPaths[max_node_count]; <span class="comment">// shortPaths数组，存放已经确定最短路径的结点</span></span><br><span class="line">    Type vertex = <span class="number">0</span>; <span class="comment">// 图的顶点数</span></span><br><span class="line">    Type edge = <span class="number">0</span>; <span class="comment">// 图的边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure>

<p>采用邻接矩阵来存储顶点之间的联系。 根据实验要求，我们需要先初始化这个图，也就是初始化部分邻接矩阵以及他的顶点数和边数。容易知道的是，每个顶点和他自身的距离为 0，因此，在初始化的时候就可以直接设为 0，另外，对于其他的点，我们先初始化为无穷大的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的顶点数和边数: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g.vertex &gt;&gt; g.edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.edge; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = <span class="number">0</span>; <span class="comment">// 顶点与自身距离为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = inf; <span class="comment">// 某个顶点与其余顶点距离默认初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">之后我们便要读入对应的顶点和边权了，对于有向图，其是有固定的指向的，因此，在邻接矩阵中，若无环，且`AdjacencyList[<span class="number">3</span>][<span class="number">4</span>] ≠ ∞`，则`AdjacencyList[<span class="number">4</span>][<span class="number">3</span>] = ∞`，是一个对立的关系，那么对于无向图呢？ 其实只要让`AdjacencyList[<span class="number">3</span>][<span class="number">4</span>] = AdjacencyList[<span class="number">4</span>][<span class="number">3</span>]`即可，这样，即可使无向图也可以使用`狄克斯特拉算法`来寻找最快路径。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">status getGraph (Graph &amp;g) &#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// 边的左顶点</span></span><br><span class="line">    <span class="keyword">int</span> v2; <span class="comment">// 边的右顶点</span></span><br><span class="line">    <span class="keyword">int</span> e; <span class="comment">// 边的权值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.edge; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;</span>, i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e;</span><br><span class="line">        g.AdjacencyList[v1][v2] = e; <span class="comment">// 填入邻接矩阵</span></span><br><span class="line">        g.AdjacencyList[v2][v1] = e; <span class="comment">// 无向图处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还要初始化两个表，一个是初始路径的表，还有一个就是已经确定最短路径的表。 初始路径的表，即源点到各个点的初始路径，有些点不与源点直接相连，即可设置为无穷大；对于与源点直接相连的点，可以查看邻接矩阵中关于源点的顶点之间的联系，然后填入表内。 已经确定最短路径的表，在最开始只有源点是确定的，其他点均尚未确定，因此，初始化也非常简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dis数组，表示1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.distances[i] = g.AdjacencyList[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line">    <span class="comment">// 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.shortPaths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.shortPaths[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要做的就是依据邻接矩阵来不断更新这两个表的数据来计算所有点距离源点的最短路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min; <span class="comment">// 存储最小值</span></span><br><span class="line">    <span class="keyword">int</span> vmin; <span class="comment">// 存储最小值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex - <span class="number">1</span>; ++i) &#123; <span class="comment">// 最后一个点无需比较</span></span><br><span class="line">        <span class="comment">// 找到距离号顶点最近的顶点</span></span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.vertex; ++j) &#123; <span class="comment">// 遍历各个顶点，找出距离最近的未确定的结点</span></span><br><span class="line">            <span class="keyword">if</span> (g.shortPaths[j] == <span class="number">0</span> &amp;&amp; g.distances[j] &lt; min) &#123;</span><br><span class="line">                min = g.distances[j];</span><br><span class="line">                vmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g.shortPaths[vmin] = <span class="number">1</span>; <span class="comment">// 确定该顶点找到最小路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= g.vertex; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.AdjacencyList[vmin][k] &lt; inf) &#123; <span class="comment">// 若两个顶点直接相邻</span></span><br><span class="line">                <span class="keyword">if</span> (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; <span class="comment">// 若该距离更小，更新最短路径的数据</span></span><br><span class="line">                    g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释如注释。</p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_node_count = <span class="number">20</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">999999</span>; <span class="comment">// 存储一个可以当做相对无穷的值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Type AdjacencyList[max_node_count][max_node_count]; <span class="comment">// 邻接矩阵存储顶点与顶点之间的联系</span></span><br><span class="line">    Type distances[max_node_count]; <span class="comment">// distances数组，1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    Type shortPaths[max_node_count]; <span class="comment">// shortPaths数组，存放已经确定最短路径的结点</span></span><br><span class="line">    Type vertex = <span class="number">0</span>; <span class="comment">// 图的顶点数</span></span><br><span class="line">    Type edge = <span class="number">0</span>; <span class="comment">// 图的边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">const</span> status ok = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> status err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化邻接表</span></span><br><span class="line"><span class="function">status <span class="title">getGraph</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 读入边</span></span><br><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化distances数组</span></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 计算得到所有节点确定最短路径长度的数组</span></span><br><span class="line"><span class="function">status <span class="title">displayClosestDistances</span> <span class="params">(Graph g)</span></span>; <span class="comment">// 输出最终得到到各个结点的最小路径数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DIJKSTRA 算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph traffic; <span class="comment">// 定义一个Graph变量</span></span><br><span class="line">    initGraph(traffic); <span class="comment">// 初始化图的邻接顺序表</span></span><br><span class="line">    getGraph(traffic); <span class="comment">// 读入边的相关信息</span></span><br><span class="line">    initDistances(traffic); <span class="comment">// 初始化各个顶点距离源点的路径顺序表</span></span><br><span class="line">    initShortPaths(traffic); <span class="comment">// 初始化各个已经确定最短顶点的顶点顺序表</span></span><br><span class="line">    makeClosestDistances(traffic);</span><br><span class="line">    displayClosestDistances(traffic);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *****************  函数库  *********************</span></span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的顶点数和边数: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g.vertex &gt;&gt; g.edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.edge; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = <span class="number">0</span>; <span class="comment">// 顶点与自身的距离为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = inf; <span class="comment">// 某个顶点与其余顶点距离默认初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">getGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// 边的左顶点</span></span><br><span class="line">    <span class="keyword">int</span> v2; <span class="comment">// 边的右顶点</span></span><br><span class="line">    <span class="keyword">int</span> e; <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.edge; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;</span>, i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e;</span><br><span class="line">        g.AdjacencyList[v1][v2] = e; <span class="comment">// 填入邻接矩阵</span></span><br><span class="line">        g.AdjacencyList[v2][v1] = e; <span class="comment">// 无向图处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dis数组，表示1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.distances[i] = g.AdjacencyList[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line">    <span class="comment">// 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.shortPaths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.shortPaths[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">displayClosestDistances</span> <span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出各个顶点的距离1号顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号顶点距离源点(1号)的最短路径的长度为 %d\n&quot;</span>, i, g.distances[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min; <span class="comment">// 存储最小值</span></span><br><span class="line">    <span class="keyword">int</span> vmin; <span class="comment">// 存储最小值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex - <span class="number">1</span>; ++i) &#123; <span class="comment">// 最后一个点无需比较</span></span><br><span class="line">        <span class="comment">// 找到距离号顶点最近的顶点</span></span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.vertex; ++j) &#123; <span class="comment">// 遍历各个顶点，找出距离最近的未确定的结点</span></span><br><span class="line">            <span class="keyword">if</span> (g.shortPaths[j] == <span class="number">0</span> &amp;&amp; g.distances[j] &lt; min) &#123;</span><br><span class="line">                min = g.distances[j];</span><br><span class="line">                vmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.shortPaths[vmin] = <span class="number">1</span>; <span class="comment">// 确定该顶点找到最小路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= g.vertex; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.AdjacencyList[vmin][k] &lt; inf) &#123; <span class="comment">// 若两个顶点直接相邻</span></span><br><span class="line">                <span class="keyword">if</span> (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; <span class="comment">// 若该距离更小，更新最短路径的数据</span></span><br><span class="line">                    g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Users/wingsico/CLionProjects/dijkstra/cmake-build-debug/dijkstra</span><br><span class="line">输入图的顶点数和边数: 5 7</span><br><span class="line">输入第1条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 2 180</span><br><span class="line">输入第2条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 3 100</span><br><span class="line">输入第3条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 4 150</span><br><span class="line">输入第4条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 4 50</span><br><span class="line">输入第5条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 5 130</span><br><span class="line">输入第6条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 3 4 80</span><br><span class="line">输入第7条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 4 5 120</span><br><span class="line">1号顶点距离源点(1号)的最短路径的长度为 0</span><br><span class="line">2号顶点距离源点(1号)的最短路径的长度为 180</span><br><span class="line">3号顶点距离源点(1号)的最短路径的长度为 100</span><br><span class="line">4号顶点距离源点(1号)的最短路径的长度为 150</span><br><span class="line">5号顶点距离源点(1号)的最短路径的长度为 270</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个代码上还有可以改进的地方，这个算法的时间复杂度为<code>O(N^2)</code>，每次找到离源点最近的定点的时间复杂度是 O(N)(一个 for 循环遍历所有结点)，这里我们可以使用<code>堆</code>来优化，可以使这一部分的时间复杂度降低到<code>O(logN)</code>。</p>
<p>另外，对于稀疏图来说，我们可以使用<code>邻接表法</code>代替邻接矩阵，使得整个时间复杂度优化到<code>O((M+N)logN)</code>，但没有仔细研究，所以也不了了之。 对于选做题，有一定难度，不过了解<code>费洛伊德算法</code>即可解决，即<code>多源最短路径的算法</code>，其核心代码只有五行，利用了动态规划的思想，实现起来很简单，但由于时间有限，加之期末临近，只好作罢。 Over。</p>
]]></content>
      <categories>
        <category>深入理解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>自动签到续篇 —— Linux定时服务</title>
    <url>/2017/11/13/linux-crontab/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux 利用 crontab 实现简单的定时任务</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>自己的电脑是 Mac OS，命令跟 linux 差不多吧，但是定时任务也不应该在自己的电脑上跑吧，因为自己的电脑总会关的，服务也会停止的。所以我选择了我的博客所在的服务器，这个是 linux centos 系统。这个是我在腾讯云花一元/月领的（现在这个活动已经结束啦），ok，自动签到 js 脚本和服务器都有了，可以开始我们的任务了。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先，服务器上还没有我们的脚本，我们需要把我们的脚本上传到服务器里，怎么上传呢？ 在 mac os 里（may linux 里也有），进入我们脚本所在目录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cd</span> ~/my-github/nodejs/util</span><br><span class="line">➜  ~ scp checkin.js root@wingsico.org:/home/checkin.js</span><br><span class="line">password:</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<p>这样就上传到我们服务器的/home 目录下，并将文件命名为 checkin.js 可以通过 ssh 进入服务器查看一下，很好，/home 目录下已经有我们的脚本文件 checkin.js 了，先尝试运行一波:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_48_13_centos ~/home]<span class="comment"># node checkin.js</span></span><br><span class="line">[root@VM_48_13_centos ~\]<span class="comment"># cd /var/spool/mail/</span></span><br><span class="line">[root@VM_48_13_centos mail]<span class="comment"># nano root</span></span><br><span class="line">// 翻到最后一行</span><br><span class="line">OK &#123;<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;签到成功&quot;</span>,<span class="string">&quot;ret&quot;</span>:1&#125;</span><br></pre></td></tr></table></figure>

<p>签到成功了，ok，那么我们就开始写定时服务。</p>
<h2 id="定时服务"><a href="#定时服务" class="headerlink" title="定时服务"></a>定时服务</h2><p>在 linux 中我们使用 crontab 这个命令来管理定时任务,我们可以使用 crontab –help(其实是靠输入错误来弹出相关提示…)来查看相关命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">(default operation is replace, per 1003.2)</span><br><span class="line">-e (edit user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">-l (list user&#x27;</span>s crontab)</span><br><span class="line">-r (delete user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">-i (prompt before deleting user&#x27;</span>s crontab)</span><br><span class="line">-s (selinux context)</span><br></pre></td></tr></table></figure>

<p>为了更好的运行脚本，我们写一个 shell 脚本来运行 js 脚本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/root/.nvm/versions/node/v8.7.0/bin/node /home/checkin.js</span><br></pre></td></tr></table></figure>

<p>发现了吗？我们这里没有直接用 node 来运行 js 脚本，因为 shell 脚本运行的环境不同，不能直接通过 node 来运行 js 脚本，我们使用<code>which node</code>来找到 node 的运行的源文件，保存在统一目录下，命名为 checkin.sh，接下来我们在定时任务里就可以直接运行这个脚本就好了，现在来编辑定时任务了，输入<code>crontab -e</code>，添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10 09 * * * sudo bash /home/checkin.sh &amp;</span><br></pre></td></tr></table></figure>

<p>前面的参数的含义就是 <strong>每天的 9 点 10 分</strong>，这个命令就是在每天 9 点 10 分运行一次 checkin.sh 脚本，记得加 sudo，不然会在日志中提示权限不够。好了，之后输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_48_13_centos ~]<span class="comment"># /sbin/service crond start</span></span><br></pre></td></tr></table></figure>

<p>开启定时服务～之后如果修改 crontab 的话使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_48_13_centos ~]<span class="comment"># /sbin/service crond restart</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 规范类型</title>
    <url>/2020/04/01/js-spec-types/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>每一种语言都有自己的类型，但基本上都是遵从语言的规范类型。对于一些规范类型，winter描述的并不详细。因此，在查阅相关资料后，对齐进行补充。</p>
<a id="more"></a>

<h2 id="规范类型"><a href="#规范类型" class="headerlink" title="规范类型"></a>规范类型</h2><p>共有以下7种规范类型：</p>
<ol>
<li><p>List和Record：List是用来描述参数列表的执行，其实跟ES中规定的数组的意义相近，但是写规范的时候还不存在ES的数组类型，所以使用List代替，写作&lt;&lt;1,2&gt;&gt;。而Record是用来描述算法中的数据聚合的，可以简单理解为ES中的对象，这类类型的话内部聚合了一个或多个命名字段（可以理解为键值对），其中命名字段的值一般是ES规范中的值或者是Record类型关联的抽象值（可以简单对应为JS中的基本类型的值或者是对象类型的值），字段的名称始终用 <code>[[name]]</code> 表示。你可以在JS对象的原型链上或原型链中的某个属性中看到类型的表示，例如 <code>[[Scopes]]</code>，但一般涉及语言实现，不会对外暴露出具体信息。</p>
</li>
<li><p>Set和Relation：Set主要是解释内存模型中使用的无序元素集合，即数学意义上的集合，其中的元素出现不超过一次，应该与ES6中的Set类型对应，在语言层面上会用于描述字符集之类的。Relation用于解释Set之间的关系，例如包含、交叉等，可以参考数学定义上的集合关系。</p>
</li>
<li><p>Completion Record：翻译过来即是完成时的记录，这里的完成时一般是指语句执行后的完成状态。这个完成状态有几种类型，例如正常的复赋值语句完成后，他的完成状态就是normal，但例如break, continue,return, throw这些语句执行完成后，其完成状态就是对应的状态（break,continue,return,throw）。ECMAScript规范中的每个运行时语义都显式或隐式返回一个报告其结果的完成Completion Record。Completion Record是一个Record，所以就可以用对象来描述它，它有三个字段：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Completion Record = &#123;</span><br><span class="line">  [[type]] <span class="comment">// Completion的类型，有 normal, break, continue, return, throw 5种类型</span></span><br><span class="line">  [[value]] <span class="comment">// 返回的值为ES语言值或空，仅当当[[type]] 为 normal,return, throw时有值</span></span><br><span class="line">  [[target]] <span class="comment">// 定向控制转移的目标label，为string或空，仅当[[type]] 为break, continue时有值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> type 对应的是完成状态的类型。而value、target从字面理解就是完成后得到的值和需要跳转的目标，这个目标的话在我们使用 break, coutinue 的时候可以在后面跟一个 label， 来指定要跳转的模板，即 <code>continue xxx</code>。</p>
<p> 只有当 type 为 <code>[[normal]]</code> 时，才是正常的完成状态，其他的类型均为 <strong>中断的完成状态</strong></p>
</li>
<li><p>Reference类型：用来解释诸如delete，typeof，赋值运算符，super关键字和其他语言特征等运算符的行为。 简单理解，就是如何去解析这些运算符的使用，有点类似词法作用域中对变量的LHS，RHS的查找。</p>
<p> Reference一般由三个部件组成</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BaseValue <span class="comment">// 值为：undefined,Object,Boolean,String,Symbol,Number,Environment Record. </span></span><br><span class="line">  ReferencedName <span class="comment">// String或Symbol值。</span></span><br><span class="line">  StrictReference <span class="comment">// 布尔值，标识是否为严格模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 举个例子：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  b: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 那么在查找b的时候就会得到一个Reference类型：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BaseValue: a,</span><br><span class="line">  ReferencedName: b,</span><br><span class="line">  StrictReference: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个类型从语言规范层面来说，可以解释为什么可以直接对字符串字面量使用字符串方法，例如 <code>&quot;ABC&quot;.toLowerCase()</code>，要执行这个语句，就要知道<code>&quot;ABC&quot;.toLowerCase</code>是什么，才能执行函数。这个语句会得到以下的Reference：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BaseValue: <span class="string">&quot;ABC&quot;</span>,</span><br><span class="line">  ReferencedName: toLowerCase,</span><br><span class="line">  StrictReference: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Reference内置了一些方法，对这个例子而言，对 <code>.</code> 运算符解释时会对 Base Value 执行 <code>[[GetValue]]</code> 内置方法，由于 “ABC” 是原始值类型的 （<code>Primitive</code>，也就是在拆箱转换的时候提到的），会对 BaseValue 进行 <code>ToObject(BaseValue)</code>, 将其变成 String 对象，再调用 <code>toLowerCase</code> 方法。</p>
<p> 还有一些其他的内置方法，就不展开描述了。</p>
</li>
<li><p>Property Descriptor类型：就是属性描述符，用来解释对象属性的特性的操作，其值为Record类型，分为数据属性描述符和访问器属性描述符。例如 <code>[[Writable]]，[[Get]]</code> 等</p>
</li>
<li><p>Lexical Environment和Environment Record类型：主要是用来描述ES里作用域，标识符绑定等等。这个要详细描述的话有点长，可以查询一下相关资料。关于作用域、闭包的解释都可以从这个层面来说明。</p>
</li>
<li><p>Data Blocks：主要是描述二进制数据，用来描述字节大小（8位）数值的不同且可变的序列。这个我也不太懂，就不详细说明了。</p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是对 winter 对规范类型的补充说明，也是我自己刨根问底的一种尝试吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 重置MySQL密码</title>
    <url>/2018/03/27/mysql-password-reset/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如何在 Mac OS 上重置 MySQL 服务密码?</p>
<a id="more"></a>

<h2 id="1-停止-MySQL-服务"><a href="#1-停止-MySQL-服务" class="headerlink" title="1. 停止 MySQL 服务"></a>1. 停止 MySQL 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server stop</span><br></pre></td></tr></table></figure>

<h2 id="2-进入安全模式"><a href="#2-进入安全模式" class="headerlink" title="2. 进入安全模式"></a>2. 进入安全模式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mysqld\_safe --skip-grant-tables</span><br></pre></td></tr></table></figure>

<p>这个地方，如果你 <code>alias</code> 了 <code>mysqlld\_safe</code> 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 <code>/usr/local/mysql/bin/mysqld/usafe</code>。</p>
<p>说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。</p>
<p>这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。</p>
<h2 id="3-新打开一个终端，进入-MySQL"><a href="#3-新打开一个终端，进入-MySQL" class="headerlink" title="3. 新打开一个终端，进入 MySQL"></a>3. 新打开一个终端，进入 MySQL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： <code>/usr/local/mysql/bin/mysql -u root -p</code> 然后输入任意密码就可以进入 MySQL 了。</p>
<h2 id="4-修改密码"><a href="#4-修改密码" class="headerlink" title="4. 修改密码"></a>4. 修改密码</h2><p>进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。</p>
<p>MySQL 的用户信息是存在 <code>mysql.user</code> 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql; <span class="comment"># 切换数据库</span></span><br><span class="line"><span class="keyword">describe</span> <span class="keyword">user</span>; <span class="comment"># 查看user表的字段</span></span><br></pre></td></tr></table></figure>

<p>然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。</p>
<p>然后修改密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">authentication</span>\_string=<span class="keyword">PASSWORD</span>(<span class="string">&#x27;123456&#x27;</span>) <span class="keyword">where</span> <span class="keyword">User</span>=<span class="string">&#x27;root&#x27;</span>; <span class="comment"># 将root用户密码改成 123456</span></span><br></pre></td></tr></table></figure>

<h2 id="5-刷新权限，使配置生效"><a href="#5-刷新权限，使配置生效" class="headerlink" title="5. 刷新权限，使配置生效"></a>5. 刷新权限，使配置生效</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>最后再启动 MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术杂文</category>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>[nginx] 服务器无法访问 + 502 bad gateway</title>
    <url>/2018/01/13/nginx-502/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在腾讯云制作镜像的时候强制关闭了服务器，后面外网就访问不了服务器了。记录一下解决过程</p>
<a id="more"></a>

<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>一开始以为是文件丢失了，后面用 vnc 上去看了之后文件都还在，然后我就又重启了好几遍，网页还是访问不了，于是我先放在一边。 第二天再看了一下，发现二级域名下的资源可以访问，但主域名的无法访问，显示 502 bad gateway。 于是觉得应该是 nginx 的问题，试图重启 nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure>

<p>失败，报了个错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Job <span class="keyword">for</span> nginx.service invalid.</span><br></pre></td></tr></table></figure>

<p>难道是没有开启？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>

<p>。。报了个更长的错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Job <span class="keyword">for</span> nginx.service failed because the control process exited with error code. See <span class="string">&quot;systemctl status nginx.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>根据它的提示我试了一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status nginx.service</span><br></pre></td></tr></table></figure>

<p>得到如下的信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● nginx.service - The nginx HTTP and reverse proxy server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Fri 2018-01-12 20:33:08 CST; 27s ago</span><br><span class="line">  Process: 2702 ExecStart=/usr/sbin/nginx (code=exited, status=1/FAILURE)</span><br><span class="line">  Process: 2698 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2697 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">Jan 12 20:33:06 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to [::]:80 failed (98: ...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (9...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to [::]:80 failed (98: ...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (9...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to [::]:80 failed (98: ...e)</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos nginx[2702]: nginx: [emerg] still could not <span class="built_in">bind</span>()</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: nginx.service: control process exited, code=e...s=1</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: Failed to start The nginx HTTP and reverse pr...er.</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: Unit nginx.service entered failed state.</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: nginx.service failed.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure>

<p>不是很看得懂，看到一堆 failed 和 disabled. 先看一下 nginx 的进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep  nginx</span><br><span class="line">root      2516     1  0 Jan12 ?        00:00:00 nginx: master process nginx</span><br><span class="line">nginx     2517  2516  0 Jan12 ?        00:00:00 nginx: worker process</span><br><span class="line">root      5308  4831  0 09:04 pts/1    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>

<p>把 nginx 进程关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill -9 nginx</span><br></pre></td></tr></table></figure>

<p>再次启动 nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>

<p>嗯，没有消息就是最好的消息，没有报错了，启动成功。但这个时候主域名还是访问不了，想到主域名上面放的是博客，博客是 wordpress 驱动的，用的 php，想到可能是 php 挂死了，那重启一下 php-fpm 吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall php-fpm</span><br><span class="line">./opt/php56/sbin/php-fpm</span><br></pre></td></tr></table></figure>

<p>再访问一下主域名，ok，博客成功显示。</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>用node实现一个每日签到脚本</title>
    <url>/2017/11/12/node-checkin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>曾在大一的时候就听田大佬写了一个每日自动签到的脚本，觉得很牛逼，不过现在看起来确实和当初田大佬说的那样简单&gt;,&lt;，话不多说，直接开始吧。</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先这个签到是我学校的一个工作室的内部网站的签到。一开始认为只需要登录了就算签到了（大一不了解的时候），现在知道了，其浏览器上的流程大概是： <strong>打开登录页面 ——&gt; 输入账号密码 ——&gt; 点击登录 ——&gt; 登录成功&amp;自动完成签到;</strong> 其内部实现为: <strong>输入网址 ——&gt; 发送 get 请求 ——&gt; 拿到返回的 html 并展示 ——&gt; 输入账号密码 ——&gt; 将账号密码放在请求体内通过 post 请求发送到对应的登录 api ——&gt; 拿到对应 api 所返回的数据（这里我们只需要 token） ——&gt; 对签到的 api 发送一个 post 请求，将 token 放入请求头中发送 ——&gt; 签到成功.</strong> 那么如何实现以上操作呢？</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先，打开 us.ncuos.com(我们内部的网站), f12 打开 chrome debugger tools，点击 network，钩上 presever log，然后输入账号密码，点击登录，成功之后右边就会出现一堆请求，我们找到 Name 为 login 的包，这里标清楚了请求的 url，method 和请求体的类型，根据这三个我们可以很简单的写一个模拟登录来拿到对应的 token：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&quot;request&quot;</span>); <span class="comment">// 引入request包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contents = &#123;</span><br><span class="line">  username: <span class="string">&quot;613*****&quot;</span>,</span><br><span class="line">  password: <span class="string">&quot;******&quot;</span>,</span><br><span class="line">  remember_me: <span class="literal">false</span></span><br><span class="line">&#125;; <span class="comment">// 请求体，目前为一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: <span class="string">&quot;http://us.ncuos.com/api/user/login&quot;</span>, <span class="comment">// 请求的url</span></span><br><span class="line">  method: <span class="string">&quot;POST&quot;</span>, <span class="comment">// 请求的方式 post</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json; charset=utf-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(contents) <span class="comment">// 对象JSON化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个请求，</span></span><br><span class="line">request(options, <span class="function">(<span class="params">error, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> token = response.headers.authorization; <span class="comment">// 响应头里存储着token</span></span><br><span class="line">    <span class="built_in">console</span>.log(token);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ok，是不是很简单呢，这样我们就拿到了 token，就可以为所欲为了啊嘎嘎，比如爬个帖子内容啥的！哦不，回归正题，签到签到，我们再次回到浏览器，我们登录之后还请求了一些别的数据，比如 Name 为 checkin 的就是我们要找的签到的 api，由于这个接口是没有请求体的，所以我们不需要类似上面的 contents 了，只需要在登录之后再发送一个 post 请求，设置好请求头就可以了，由于代码比较短，就直接放在登录成功后的 if 语句内:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request(options, <span class="function">(<span class="params">error, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> token = response.headers.authorization; <span class="comment">// 响应头里存储着token</span></span><br><span class="line">    <span class="keyword">var</span> params = &#123;</span><br><span class="line">      url: <span class="string">&quot;http://us.ncuos.com/api/checkin&quot;</span>, <span class="comment">// 请求url</span></span><br><span class="line">      method: <span class="string">&quot;POST&quot;</span>, <span class="comment">// 请求方式</span></span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="comment">// 请求头</span></span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;Application/json&quot;</span>, <span class="comment">// 请求体格式</span></span><br><span class="line">        Authorization: token <span class="comment">// auth token授权</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request(params, <span class="function">(<span class="params">error, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(body); <span class="comment">// 打印出响应体</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>写好了之后，保存为 <code>checkin.js</code>， 执行 <code>node checkin.js</code>，发现打印出来的是 null，什么情况，为了查看原因，我们将签到请求做出一些修改:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request(params, <span class="function">(<span class="params">error, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.statusCode, response.statusMessage);</span><br><span class="line">  <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(body); <span class="comment">// 打印出响应体</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>发现打印了 <code>400，forbidden，null</code>，再打印了一下整个<code>response</code>，发现在<code>error</code>里有更加详细的一个报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">body: <span class="string">&#x27;&#123;&quot;error&quot;: &quot;InvalidData&quot;, &quot;message&quot;: &quot;invalid json content&quot;, &quot;status&quot;: 400&#125;&#x27;</span> &#125; <span class="string">&#x27;&#123;&quot;error&quot;: &quot;InvalidData&quot;, &quot;message&quot;: &quot;invalid json content&quot;, &quot;status&quot;: 400&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>很容易看出，error 为非法 json 格式内容。wtf?啥情况，我这个根本不需要请求体啊，为什么还来个这个错误呢，于是走上了漫漫排查之路。</p>
<h2 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h2><p>我首先先尝试了一下<code>console.log(params)</code>，发现<code>headers</code>里的<code>Authorization</code>少了引号，难道是这个的原因吗？然后我尝试了各种方法还是不能将引号加上，不过<code>JSON.stringify(params)</code> 之后是有引号的，所以觉得不是这个问题。苦思冥想无果之后，求助了一下学长，把情况说清楚之后，学长给出了一个尝试建议： <strong>把 headers 里面的’Content-Type’去掉</strong>试试，去掉之后，我靠真的就成功了。之后探其原因是<strong>设置请求头中多余地规定了请求体的格式，但是你并没有也不需要发送请求体（对于这个 api），但设置了这个请求头之后就强制的要求了你的格式，所以导致上面的报错信息，非法的 content。</strong>为了验证这个想法，我把 Content-type 重新加上，写了一个 json 格式的请求体，里面数据随便填，果然也成功了！至此，我们的这个签到脚本就完成了。最终代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contents = &#123;</span><br><span class="line">  username: <span class="string">&quot;username&quot;</span>,</span><br><span class="line">  password: <span class="string">&quot;password&quot;</span>,</span><br><span class="line">  remember_me: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: <span class="string">&quot;http://us.ncuos.com/api/user/login&quot;</span>,</span><br><span class="line">  method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json; charset=utf-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(contents)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request(options, <span class="function">(<span class="params">error, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> token = response.headers.authorization;</span><br><span class="line">    <span class="keyword">var</span> params = &#123;</span><br><span class="line">      url: <span class="string">&quot;http://us.ncuos.com/api/checkin&quot;</span>,</span><br><span class="line">      method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        Authorization: token</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request(params, <span class="function">(<span class="params">error, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这样每天我们还是需要去自己执行一下这个脚本，还是不如自己手动去登录一下签到呢，所以等下我们就要实现的是 <strong>Linux 服务器定时任务</strong>，可以每日定时执行这个脚本，就可以每日自动签到了，这个留到下一篇博客讲吧～先去睡觉～</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>项目总结(一) —— 移动端适配</title>
    <url>/2017/12/23/mobile-adaptation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>历经好多时间= =，终于完成了一个小项目，再次更新了一些我的移动端知识，之前总是对概念有些不清晰，先梳理一下。</p>
<a id="more"></a>

<h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>CSS 像素(CSS Pixel)</p>
</blockquote>
<p>CSS 代码中的逻辑像素，是一个抽象的东西，实际并不存在。</p>
<blockquote>
<p>设备独立像素(Device Independent Pixel)</p>
</blockquote>
<p>与设备无关的逻辑像素，可以通过虚拟程序来设置，包含了 CSS 像素</p>
<blockquote>
<p>设备像素(Device Pixel)</p>
</blockquote>
<p>物理像素，设备能控制显示的最小单位，类似 1920 * 1080 像素分辨率这种的。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><blockquote>
<p>设备像素与设备独立像素</p>
</blockquote>
<p><strong>对于 PC 页面</strong>：在未缩放的情况下，<code>1设备像素 === 1设备独立像素</code>，若缩放为 200%时，可以说 <code>2设备像素 === 1设备独立像素</code>。 <strong>对于移动端页面</strong>： 根据设备不同有一些差异，其引起差异的原因主要在于一个被称之为<code>ppi(pixel per inc)</code>的东西。</p>
<blockquote>
<p>PPI</p>
</blockquote>
<p>从名字上就知道是 <code>每英寸设备有多少像素</code>，这里的像素指的是设备像素，即物理像素，其数值越高，每英寸设备里的像素就越高，画面也就越清晰。 计算方式为: <img src="http://images2015.cnblogs.com/blog/984702/201704/984702-20170412161418626-799396908.png" alt="PPI计算"> 像苹果的 Retina 屏的 ppi 就比较高，所以清晰度很高。 还有一个很重要的概念就是<code>dpr(device pixel ratio)</code></p>
<blockquote>
<p>DPR</p>
</blockquote>
<p>设备像素比，这个设备像素比就是<code>物理像素</code>与<code>独立像素</code>，独立像素之前说到，包含着<code>CSS像素</code>，所以 dpr 即提供了一个我们代码中的像素与设备实际像素之间的一个转换关系。 计算公式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpr = 设备像素 / 设备独立像素</span><br></pre></td></tr></table></figure>

<p>像苹果手机的 dpr 一般为 2，即意味着 1 长度的设备像素里有 2 长度的设备独立像素，换做面积来算的话就是 1 设备像素包含着 4 设备独立像素，即成平方关系，所以清晰明了，dpr 越高，屏幕清晰度也越高，与 ppi 有些相似，用一张图看看： <img src="http://images2015.cnblogs.com/blog/984702/201704/984702-20170412163741001-1502532540.png" alt="DPR"> 大概需要了解的就这些，我在实际运用中用到的也就如下几点：</p>
<ol>
<li>dpr</li>
<li>px</li>
<li>device-width (屏幕宽度)</li>
</ol>
<h3 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h3><p>对于 dpr，一般用于两个地方，一个是<code>字体大小</code>，一个是<code>背景图片大小</code> 对于字体，也是用 px 堆起来的，因此 dpr 也会影响到字体的显示，当 dpr 较大时，为了同比例显示字体大小，就会去检测其 dpr 的值，根据 dpr 的不同来设置不同比例的字体大小，可以用如下一段<code>sass</code>的混合宏来适配字体显示:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> font-dpr(<span class="variable">$font-size</span>) &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$font-size</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="selector-attr">[data-dpr=&quot;2&quot;]</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font-size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-attr">[data-dpr=&quot;3&quot;]</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font-size</span> * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个<code>data-dpr</code>，即根据 dpr 不同来应用不同的字体样式，此外，这里将传入的字体大小除以 2，这是因为一般设计给的视觉稿都是 iphone6 的二倍稿，因此，为了显示正常字体大小，将其标注的字体大小除以二，再根据 dpr 来适配字体大小。 移动端运用到图片几乎是必然的，一般设计师会给出两种图片，一种为@2x 图，一种为@3x 图，不过这个主要是用来出来高清屏下图片较为高清的显示，对于普通的安卓机，dpr 一直都是 1，意义不大，用普通的@2x 图即可达到高清的显示，但是对于 ios 系统，存在 dpr 为 2、dpr 为 3 的情况，为了图片的一个等比例缩放，我们根据 dpr 的不同来使用不同倍数的图片以达到与标准屏幕一致的感受。同样的，我们也可以使用<code>sass</code>的混合宏来适配背景图片：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> bg-image(<span class="variable">$url</span>) &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="variable">$url</span>+<span class="string">&quot;@2x.png&quot;</span>);</span><br><span class="line">  <span class="keyword">@media</span> (-webkit-min-device-pixel-ratio: <span class="number">3</span>), (min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="variable">$url</span>+<span class="string">&quot;@3x.png&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除这两点之外，我暂时没有用到 dpr 其他的使用方法。</p>
<h2 id="布局适配"><a href="#布局适配" class="headerlink" title="布局适配"></a>布局适配</h2><p>布局和适配其实我一直难以分辨这两个概念，我就把它罗列在一起吧。 为了达到想要的效果，我的历程如下：</p>
<ol>
<li>meta 设置 viewport -&gt; width=device-width…</li>
<li>rem 布局</li>
<li>flex-box</li>
<li>flexible.js</li>
<li>视口单位 vw,vh</li>
<li>calc 计算</li>
<li>calc + 视口单位</li>
<li>calc + 视口单位 + 媒体查询</li>
<li>百分比布局</li>
<li>删除 6、7、8, 9 重归 flexible</li>
<li>加上媒体查询，适配特殊机型，如 Nexus 5X</li>
</ol>
<p>妈耶心好累，布局适配改改改改好头疼，不过还好都解决了。</p>
<h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  name=&quot;viewport&quot;</span><br><span class="line">  content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>这行代码作用是设置<code>理想视口</code>，什么是视口？什么又是理想视口，要说明这个，对于<code>viewport</code>就要讲很多了。 这里有一个链接，我觉得写的很好，很多内容都非常清晰的表达了出来: <a href="https://www.cnblogs.com/xiaohuochai/p/5496995.html">移动端之 viewport</a></p>
<h3 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h3><p><code>rem</code>、<code>px</code>、<code>em</code>均是常用的单位，他们都是相对长度单位，在不同的地方我们需要配合起来使用。</p>
<h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p><code>px(Pixel)</code> 是相对于屏幕分辨率而言的一个单位，一般我们对于 pc 均会使用<code>px</code>作为单位，同时，一些固定大小、长度的我们同样使用 px 作为单位，这个也是我们上面说到的 CSS 像素，包含在设备独立像素内。</p>
<h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p><code>em</code>是一个相对与其父元素的字体大小的一个单位，举个例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    font-size: 18px;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">      font-size: 2em; // 18 * 2 = 36px</span><br><span class="line"><span class="css">      <span class="selector-class">.grandson</span> &#123;</span></span><br><span class="line">        font-size: 0.5em; // 36 * 0.5 = 18px</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个单位对于一整块整体变换有很好的效果，比如我们有一个按钮，当我们想要整体放大一个按钮的时候，不需要去改变每一个字体的大小，设置 em 之后可以只改变其父级元素的字体大小来达到整体缩放的效果。</p>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>为了移动端而生的单位，同样是一个相对单位，与 em 不同的是，rem 是相对于 html 根元素的字体大小，举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line">  html &#123;</span><br><span class="line">      font-size: 10px;</span><br><span class="line"><span class="css">      <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">          font-size: 2rem; // 10 * 2 = 20px</span><br><span class="line"><span class="css">          <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">              font-size： 4rem; // 10 * 4 = 40px</span><br><span class="line"><span class="css">              <span class="selector-class">.grandson</span> &#123;</span></span><br><span class="line">                  font-size： 1.6rem; // 10 * 1.6 = 16px</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有了这样一个单位，对于我们移动端上的适配来说，绝对是一大助力，我们可以使用 rem 来适配不同分辨率的屏幕。 现在假设我们有一张 750 的设计稿，我们把设计稿分成一百份，把每十份当做一个 1rem，即设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  font-size: 75px; // 750 / 100 * 10 = 75px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们在需要一个 150*150 的 div 时，我们可以使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们的屏幕不同的时候，我们只需动态的更改根元素的字体大小即可。那么如何动态更改根元素的字体大小呢？在 CSS3 有一个新增的<strong>媒体查询</strong>，可以帮我们检测设备相关信息并根据这些信息使用不同的样式。</p>
<h3 id="media-媒体查询"><a href="#media-媒体查询" class="headerlink" title="@media/媒体查询"></a>@media/媒体查询</h3><p>这里有相关的资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries">MDN 媒体查询</a> 上面只是介绍了一些概念的东西，那么我们如何去使用媒体查询在我们的移动端适配上呢? 待续</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>html</tag>
        <tag>移动端</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中 Number 有多少个?</title>
    <url>/2020/04/01/js-number-scope/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 中 Number 到底有多少个？为了弄清这个问题，并且了解 JavaScript 的 Number 类型设计，将从规范上进行探究。</p>
<p>这个问题的来源是 winter 老师的 <strong>#重学前端#</strong> 课程，在讲解 Number 类型时提到这样一句话：</p>
<blockquote>
<p>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64 - 2^53 + 3) 个值。</p>
</blockquote>
<p>对于这个 <code>2^64 - 2^53 + 3</code>，winter老师并没有给出相关的解释，为了弄清楚这个的来源去查阅相关资料后进行整理。</p>
<p>为了知道这个问题的答案，需要先了解一下在JavaScript中Number是如何表示的。</p>
<h2 id="JavaScript中的Number"><a href="#JavaScript中的Number" class="headerlink" title="JavaScript中的Number"></a>JavaScript中的Number</h2><p>从ECMAScript规范中得知, Number的值是：</p>
<blockquote>
<p>primitive value corresponding to a double-precision 64-bit binary format IEEE 754-2008 value</p>
</blockquote>
<p>意思就是：符合IEEE 754-2008 格式的 64 位双精度二进制的原始值。</p>
<p>在 IEEE 754 中，64位双精度浮点数中的64位由以下部分组成：</p>
<p><img src="http://cdn.wingsico.org/blog/js%20number.png" alt="64位双精度浮点数"></p>
<ul>
<li>s - 符号位，占 1 bit (数符)</li>
<li>e - 指数位，占 11 bit (阶码=阶码真值+偏移量)</li>
<li>f - 小数位，占 52 bit (尾数)</li>
</ul>
<p>在规范中也明确的给出了各种情况的计算方式：</p>
<p><img src="http://cdn.wingsico.org/blog/IEEE-64double.png" alt="IEEE 754计算"></p>
<ol>
<li><p>如果指数位e全为1，即 e = 11111111111，也就是十进制的2047(2^11-1)，且小数位f不为0，就超过了最大值，这样的数字无法正确表示，表示为 NaN(Not a Number)，此时会无视作为符号位的s</p>
</li>
<li><p>如果指数为e全为1，但小数位f为0的话，则根据符号位s得到两个特殊的值((-1)^s)，当s为0时，得到正无穷大，对于JS中的Infinity;当s为1时，得到负无穷大，对应-Infinity</p>
</li>
<li><p>如果指数e在 0&lt;e&lt;2^11-1 之间，这个表示 IEEE 认为的正常的浮点数区间，那么对应的数字的计算公式为：(-1)<sup>s</sup>x(2<sup>e-1023</sup>)x(1.f)<br> 对于e-1023和1.f可能会有些疑惑。其中 1023 代表指数的偏移量，那么为什么会有这个偏移量呢，首先，作为11位的阶码，如果是无符号，那么表示的范围为 <code>[0-2047]</code>, 当处于我们第三种情况时，e的范围要去掉0和2047，变成 <code>[1,2046]</code>，如果要表示正负，则需要使用一个bit去作为符号位，范围为 <code>[-1022, 1023]</code>，如果没有偏移量，那么需要引入补码，计算更加复杂，为了简化运算，则使用无符号的阶码，引入了偏移量的概念，通过偏移将其转换成 <code>[1,2046]</code>，所以偏移量为 1023。<br> 那么对于1.f来说，因为对于浮点数，在规范中采用科学计数法的方法，对于十进制12.34来说，用科学技术法表示为 1.234x10^2，不会表示为 0.1234x10^3，其首位肯定是一个不为0的数字，那么在二进制中，只有0和1，那么他的首位就只能是1（用科学计数法表示，首位不能为0）。因为对于所有的浮点数他的首位都是1，因此可以省略一位进行，不需要额外占用1位，所以f实际上的有效位数有53位（其中首位是1）。在计算时需要使用上这个隐含的1。这也是1.f的由来</p>
</li>
<li><p>当e为0且f不为0时，是非规范化的数字，用于表示那些非常接近0的数字。</p>
<blockquote>
<p>非规格化下，指数为，000 00000000 - 011 11111111 (偏移量) = - 100 00000001（转成10进制，减1取反）= - 1023<br>从指数看，得知最小值是2^-1023，然而如果尾数是0.00000000 00000000 00000000 00000000 00000000 00000000 0001 不为0的情况，52位尾数相当于小数点还能虚拟化的向右移动51，可以取得更小的 2^-51, 所以最小值为 <code>2^-1074 = Math.pow(2,-1074)</code> 约等于 5e-324<br>而JS最小值常量Number.MIN_VALUE正是5e-324<br>所以(-5e-324,5e-324)之间的数比可表示的最小数还要小，显示成0，叫反向溢出。</p>
</blockquote>
</li>
<li><p>如果指数是0且尾数也是0，则表示正负0的情况</p>
</li>
</ol>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>从上面的分类我们得知，前两种是非正常的值，第一种含有 2^52 种情况（尾数有52位），第二种含有两种情况（正无穷和负无穷），那么根据排列组合，共有 2*1*2^52 = 2^53 种情况。这些非正常的值在JS中以 NaN、+Infinity、-Infinity表示，因此在Number中多了三种情况。那么总数就是 <code>2^64-2^53+3</code>，算得有 18437736874454810627 个值。</p>
<p>其中也可以解释为什么 <code>NaN != NaN</code>，因为 NaN 代表了 2^52 种情况，不是一个固定的值，而是一批值，自然也不会等于自身了。</p>
]]></content>
      <categories>
        <category>深入理解</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>npm publish发布包</title>
    <url>/2017/10/21/npm-publish/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们编写完成一个第三方库项目时，我们往往会将包发布供别人使用，那么该如何去发布一个 npm 包呢？</p>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/learning_nodejs</span><br><span class="line">npm init <span class="comment"># 初始化package.json</span></span><br><span class="line">npm adduser <span class="comment"># 创建一个registry.npm.org的账号</span></span><br><span class="line">...</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<p>在 search.npm.org 上可以搜索找到自己的包，可以在其他计算机中使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install <span class="string">&quot;包的name&quot;</span></span><br></pre></td></tr></table></figure>

<p>若遇到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm ERR! publish Failed PUT 403</span><br><span class="line">npm ERR! code E403</span><br><span class="line">npm ERR! no_perms Private mode <span class="built_in">enable</span>, only admin can publish this module: wingsicomodule</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!   /User/....</span><br></pre></td></tr></table></figure>

<p>原因是使用了淘宝镜像，若需要发布则需要更改为原镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.npmjs.org</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术杂文</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh: REMOTE HOST IDENTIFICATION HAS CHANGED 解决方案</title>
    <url>/2017/12/16/ssh-host/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直使用<code>SSH Shell</code>来登录的服务器，用着觉得主题有点丑我就又用<code>iTerm</code>来用 ssh 登录服务器。</p>
<a id="more"></a>

<p>照常，我使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@wingsico.org</span><br></pre></td></tr></table></figure>

<p>登录服务器，突然，出现了一个错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ~ ssh root@wingsico.org</span><br><span class="line"> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"> @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @</span><br><span class="line"> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"> IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line"> Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line"> It is also possible that a host key has just been changed.</span><br><span class="line"> The fingerprint <span class="keyword">for</span> the RSA key sent by the remote host is</span><br><span class="line"> SHA256:KDg0k+7eheoSVX0/HTzlWK66OI5sLrzgWc6cgXZDE6s.</span><br><span class="line"> Please contact your system administrator.</span><br><span class="line"> Add correct host key <span class="keyword">in</span> /Users/wingsico/.ssh/known_hosts to get rid of this message.</span><br><span class="line"> Offending RSA key <span class="keyword">in</span> /Users/wingsico/.ssh/known_hosts:7</span><br><span class="line"> RSA host key <span class="keyword">for</span> wingsico.org has changed and you have requested strict checking.</span><br><span class="line"> Host key verification failed.</span><br></pre></td></tr></table></figure>

<h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>注意他的错误提示</p>
<p>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</p>
<p>意思就是：<strong>远程主机标识已更改</strong> 可能是因为我重装了一下服务器，导致远程主机标识的变化，这里就要说到服务器与客户端的连接的一些要点了。 在远程服务器上，在路径<code>/ect/ssh</code>下会有一些<code>.pub</code>后缀以及名字相同但无后缀的文件，这里存放的是服务器的指纹，目录类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_48_13_centos ssh]<span class="comment"># ls</span></span><br><span class="line">moduli ssh_host_dsa_key.pub ssh_host_ed25519_key.pub</span><br><span class="line">ssh_config ssh_host_ecdsa_key ssh_host_rsa_key</span><br><span class="line">sshd_config ssh_host_ecdsa_key.pub ssh_host_rsa_key.pub</span><br><span class="line">ssh_host_dsa_key ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>

<p>其中，文件名为 <code>ssh_host_xxx_key</code> 和 <code>ssh_host_xxx_key.pub</code>就是我们服务器的指纹，分别为<strong>私钥</strong>和<strong>公钥</strong>，私钥是唯一一份的，不能泄露给他人，而公钥可以在各个地方使用，这个可以参考 git 仓库的建立。 当我们使用客户端第一次登录服务器时，会有如下一段提示：</p>
<blockquote>
<p>The authenticity of host ‘wingsico.org (xxx.xxx.xxx.xxx)’ can’t be established.<br>ECDSA key fingerprint is SHA256:+gFx5UGMm/739ut/jKZqJDm+TYSUxfZiC7IKG2PAVpA.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘wingsico.org,xxx.xxx.xxx.xxx’ (ECDSA) to the list of known hosts.</p>
</blockquote>
<p>这时候远程服务器的指纹如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ECDSA key fingerprint is SHA256:+gFx5UGMm/739ut/jKZqJDm+TYSUxfZiC7IKG2PAVpA.</span><br></pre></td></tr></table></figure>

<p>与服务器远程验证，防止中间人攻击，这时候输入<code>yes</code>将会将指纹添加进本地的 <code>~/.ssh/know_hosts</code> 中去，远程主机和本机就拥有了一对指纹作为登录的验证，当本地的指纹与远程主机的指纹不一致时，将会弹出上面的警告信息拒绝登录。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>知道了原因，就很好处理了，因为我们重装了服务器，导致远程主机中<code>sshd</code>初始化，改变了远程主机的指纹，本地的指纹与远程主机的指纹不一致，导致登录被拒绝。所以我们只需要修改本地的指纹，也就是 <code>~/.ssh/know_hosts</code> 的内容即可，具体操作如下: 使用<code>nano</code>打开<code>know_hosts</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.ssh/know_hosts</span><br></pre></td></tr></table></figure>

<p>将对应远程主机的 ip 或者域名的指纹删除，然后重新登录。</p>
<p>重新将指纹添加进本地的<code>~/.ssh/know_hosts</code>内，即可登录成功。</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>服务器</tag>
        <tag>host</tag>
      </tags>
  </entry>
  <entry>
    <title>临别有感</title>
    <url>/2020/06/24/some-of-leave/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在刷着刷着LeetCode的时候，瞄了一眼时间，是上午9点57分，脑海里突然跳出一个词：感受孤独，不知为何眼角被泪水浸湿。可能是将要毕业的惆怅，可能是爱人离开的不舍，也可能是即将北漂的无奈。这些种种境况带给我的是孤独和惆怅。很久以前我认为自己是一个坚强的人，不在意孤独，不在意离别。可后来发现我错了，彻头彻尾地错了。表面的阳光开朗是由背地里无数次哭泣支撑着，不管是高中毕业离家的离别，还是北京出租屋里的孤独，都让我难以掩泣。孤独从四面八方涌来，好像要把我埋葬于此。不知为何，此时不管脑海里在思考着什么，那些东西全部都被孤独感侵蚀了，鼻酸的感觉时时刻刻充斥着我，视线也越来越模糊。孤独，也就是如此吧。</p>
<p>虽然我现在还在寝室，身边还有两个室友在谈论着什么，外面风和日丽，小鸟在欢快地嬉闹着。但这些却无法给我带来平静，我的孤独感充斥了我的脑海，将其他一切都沾染上了孤独的颜色。也许室友在谈论即将的离别，也许太阳也在散播着孤独的、惨白的光线，也许鸟儿也在独奏一曲忧伤的哀歌。悄悄是离别的笙箫，也许也吹奏了孤独的曲调，身边的一切，在悄悄地随着时间流逝，但这如此细微的悄悄，却让我感受到无比的孤独和惆怅。孤独，也就是如此吧。</p>
<p>我不知是害怕孤独，还是害怕离别。是即将离别给我的感伤，还是离别后的孤独让我难以承受，我已难以判断。现在似乎更能理解雨欣的眼泪了，当在以往触手可及的一切即将不复返地离你远去，我想，这似乎确实难以让人接受。离别，也就是如此吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>念</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome + shadowsocks + SwitchyOmega = 科学上网？</title>
    <url>/2017/10/08/shadowsocks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近不在机房，不能享受自动翻墙的”快感”了，呼幸好手里还有一个 ss 账号，那直接给 ubuntu 来一套科学上网的正确姿势吧～</p>
<a id="more"></a>

<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>科学上网一词我是听别人说+看到一本书《程序员的自我修养》里面的一章节，里面介绍了什么是墙，如何翻墙，以及 vpn 相关概念。根据我所了解的来说，科学上网的方式共有两种——VPN &amp; Shadowsocks。那么这两个有什么区别呢？</p>
<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><blockquote>
<p>在公用网络上建立专用网络，进行加密通讯。原理是在一个国外网络无阻的机器上与本地机器通信。</p>
<p>优点是方便设置，网络速度稳定。</p>
<p>缺点是稳定的服务价格不便宜，且本地流量全部走的是代理。</p>
</blockquote>
<p>一看到连本地流量走的都是代理，震惊了，本来价格都是按照流量来算的，如果连国内网站都走代理的话，那不是亏成翔。还好目前有解决办法。</p>
<h3 id="配合-VPN-实现国内外分流访问"><a href="#配合-VPN-实现国内外分流访问" class="headerlink" title="配合 VPN 实现国内外分流访问"></a>配合 VPN 实现国内外分流访问</h3><blockquote>
<p>“分流”，这个词不知道说的准不准确，意思就是实现对不需要翻墙的网站直接连接，需要翻墙的网站走 VPN 代理。这样国内的网站访问不受影响，又能正常访问国外站点。</p>
<p>实现方式就是修改系统的路由表，网络上有这样的开源项目，专门收集国内被“墙”的网站。利用这些数据，让 vpn 客户端在进行连接的时候自动执行.</p>
<p>通过这些路由脚本, 可以让用户在使用 vpn 作为默认网络网关的时候, 不使用 vpn 进行对中国国内 ip 的访问, 从而减轻 vpn 的负担, 和增加访问国内网站的速度.</p>
</blockquote>
<p>关于各个系统实现的方式我就不在这里赘述，详情请看这里 <a href="https://leohxj.gitbooks.io/a-programmer-prepares/effciency/great-fire-wall.html">科学上网</a></p>
<h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><p>这是另一种科学上网的姿势，我选择他！因为 vpn 的缺点他都没有～这也是我接下来要讲的，如标题一般，那么我们就以 shadowsocks 开始吧。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先，我们需要下载安装 Shadowsocks，在 linux Ubuntu16.04 中，我们使用 pip 安装。</p>
<ol>
<li>安装 pip</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 shadowsocks</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用这里介绍两种使用方法，但推荐第二种方法。 1.无配置文件，一行命令搞定</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sslocal -s server_ip -p server_port -l 1080 -k password -t 600 -m aes-256-cfb</span><br></pre></td></tr></table></figure>

<p>server_ip 请替换成对应的服务 ip， server_port 替换成对应的服务端口号， -l 是本地端口（默认 1080）， -k 后面填写密码（password）需要加双引号(“”) 如密码是 123456，则应写成 <code>-k &quot;123456&quot;</code> ， -t 是默认超时时间， -m 是加密方法，这个会由服务端给出，默认值为 aes-256-cfb。 可以简单的写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sslocal -s ip -p port -k <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure>

<p>只使用-s -p -k 这三个参数，其他的使用默认值（注意要与服务端匹配才能省略） 缺点：每次输入命令都要手动填写相关信息，比较麻烦。所以我推荐第二种。 2.添加配置文件，更加简短的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sslocal -c path/to/ss.json</span><br></pre></td></tr></table></figure>

<p>怎么样，是不是更加简短了呢？这里，我们将使用到一个配置文件，这个是由我们自己来创建，不知道放在哪里好，我自己就放在/home 目录下。 方法：选择一个目录，创建一个 json 格式的文件，名字自己定义，打开后，如下填入 ss 的相关信息.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;server&quot;</span>: <span class="string">&quot;server_ip&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;server_port&quot;</span>: server_port,</span><br><span class="line">  <span class="attr">&quot;local_address&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;local_port&quot;</span>: <span class="number">1080</span>,</span><br><span class="line">  <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;timeout&quot;</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：上面打了双引号的在实际使用的时候也需要双引号。保存之后，在命令行里使用上面那条命令就可以启动 ss 了。</p>
<p>这样就行了吗？还不行呢，使用 Shadowsocks 我们还需要设置一下浏览器端的代理设置。这里仅介绍 chrome 浏览器下的方法。</p>
<h2 id="SwitchyOmega"><a href="#SwitchyOmega" class="headerlink" title="SwitchyOmega"></a>SwitchyOmega</h2><p>这个是 Chrome 的一个插件，非常好用。之前一直在搜索如何下载 SwitchyOmega ，我靠竟然还有叫人去谷歌商店下载的。。我还没翻墙呢怎么去谷歌商店，坑爹呢这是。想想这么好的东西可能开源了吧，于是就到 github 上去找找，嘿;-)果然被我找到了，放一下下载地址～ <a href="https://github.com/FelisCatus/SwitchyOmega/releases/">https://github.com/FelisCatus/SwitchyOmega/releases/</a> 下载好了之后打开谷歌浏览器，输入<code>chrome://extensions</code>，将刚刚下载好的拖入就可以安装了。那么安装好了如何使用呢？</p>
<h3 id="使用-SwitchyOmega"><a href="#使用-SwitchyOmega" class="headerlink" title="使用 SwitchyOmega"></a>使用 SwitchyOmega</h3><p>废话少说，直接上操作：</p>
<ol>
<li>新建情景模式</li>
<li>填写名称（自定义），选择第一个代理服务器，点击创建</li>
<li>进入刚创建的情景模式，将代理协议选择至 SOCKS5，代理服务器处填写：127.0.0.1，代理端口填写 1080</li>
<li>保存，并在浏览器右上角选择到刚刚创建的情景模式。</li>
</ol>
<p>OK，这时候你就会发现谷歌能上了，youtube 能看了，世界突然变美好了（滑稽）</p>
]]></content>
      <categories>
        <category>技术杂文</category>
        <category>专治懒癌</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode 简介</title>
    <url>/2020/04/01/unicode-intro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Unicode是一种编码格式，它出现的主要原因是为了统一全球的符号编码，因为在Unicode之前，对于一些基本字符通常采用ASCII码的方式表示，但ASCII码是由一个字节组成的，最多只可以表示256个字符。</p>
<p>那么ASCII码能表示的字符是相当的有限了，且和其他的编码方式不能共同使用。因为对于同一个字符，别的编码方式可能对应的数字和ASCII中的不一致，这就导致了不通用的问题，这也是Unicode致力于解决的问题，它希望给世界上每一种文字系统的每一个字符，都分配一个唯一的整数，这些整数叫做代码点（Code Points）。</p>
<p>Unicode的数量理论上是无限的，但从中分出了 UTF-8, UTF-16, UTF-32等，其中的数字代表他可以表示的字符最少占用的bit数量。也就是 UTF-8 最少可以用一个字节表示一个字符，UTF-16 最少要用两个字节表示一个字符，UTF-32 最少要用 4 个字节来表示一个字符。</p>
<p>其中 UTF-8 是最灵活的，可以使用 1 - 8 个字节来表示字符， UTF-16 可以用两个字节或四个字节来表示一个字符，UTF-32 只能用四个字节来表达一个字符。</p>
<p>Unicode编码使用16进制，表示方法为 U+xxxx，U+0000 ~ U+FFFF 为基本多文种平面 (Base Multilingual Plane)。Unicode规范上规定了17个代码平面，分为 #0 ~ #16，其中 #0 就是 BMP，这17个平面理论上可以编码110多万个字符。</p>
<p>根据情况合理利用 UTF-8，UTF-16 等可以节省空间 (UTF-8需要占用空间来表示这个字符需要几个字节)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html">Unicode令人混淆的概念</a></li>
<li><a href="https://blog.csdn.net/zxhoo/article/details/38819517">图说我的Unicode的理解</a></li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表、链表的JS实现</title>
    <url>/2017/11/10/squence-link/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要实现顺序表和链表，首先我们需要知道的是，<strong>何为顺序表</strong>，<strong>何为链表。</strong></p>
<a id="more"></a>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>这个很简单，在 JS 中，数组就是顺序表的实例，它具有顺序表的一切性质：</p>
<ol>
<li>存放在连续的内存当中，物理位置相邻，换句话说，其数据元素都是用一组地址连续的存储单元以此存储在线性表当中；</li>
<li>只要确定了存储线性表的起始位置，顺序表中任一数据元素都可以随机存取；</li>
<li>具有线性表的性质（关于线性表，这里不作介绍，可以在这里了解<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin">线性表</a></li>
</ol>
<p>所以，在 JS，要初始化一个空的顺序表是十分简单的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> ary1 = []; <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> ary2 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 神经病方式</span></span><br><span class="line"><span class="keyword">var</span> ary3 = [...<span class="string">&quot;&quot;</span>]; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> ary4 = [...new <span class="built_in">Set</span>()]; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> ary5 = [...new <span class="built_in">Map</span>()]; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> ary6 = [...new <span class="built_in">String</span>()]; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> ary7 = <span class="string">&quot;&quot;</span>.split(<span class="string">&quot;&quot;</span>); <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> ary8 = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&quot;&quot;</span>); <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 终极神经病方式</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> ary9 = [...obj[<span class="built_in">Symbol</span>.iterator]]; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>既然是自己实现顺序表，自然不能使用 js 数组中自带的方法啦，一般来说，顺序表有以下几个基本方法：</p>
<ol>
<li>createList()</li>
<li>initList(L)</li>
<li>getLength(L)</li>
<li>insertList(L, i, e)</li>
<li>deleteList(L, i , e)</li>
<li>getListElem(L, i)</li>
<li>getElemIndex(L, e)</li>
</ol>
<p>So, 接下来一个个实现吧～</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//createList</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createList</span>(<span class="params"></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// []</span></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initList(L)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initList</span>(<span class="params">list: any[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="number">15</span>; <span class="comment">// 由于js本身不能自己输入值，所以采用自己赋值来初始化一个顺序表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      list[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getLength(L)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">list: number[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len: number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (L[len] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历每一个数据元素, 一个不为空则计数器加一</span></span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insertList(L, i, e)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertList</span>(<span class="params">list: number[], index: number, item: number</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number;</span><br><span class="line">  <span class="keyword">let</span> len = getLength(list);</span><br><span class="line">  <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= index - <span class="number">1</span>; i--) &#123;</span><br><span class="line">    list[i + <span class="number">1</span>] = list[i]; <span class="comment">// 位置index之后的元素（包括index）全部往后移一个单元</span></span><br><span class="line">  &#125;</span><br><span class="line">  list[index - <span class="number">1</span>] = item;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deleteList(L, i)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteList</span>(<span class="params">list: number[], index: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; getLength(list) + <span class="number">1</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i: number = index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> len: number = getLength(list);</span><br><span class="line">  <span class="keyword">let</span> e = list[i];</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    list[i] = list[i + <span class="number">1</span>]; <span class="comment">// index之后的每一个元素往前移一个单元</span></span><br><span class="line">  &#125;</span><br><span class="line">  list.length--; <span class="comment">// 长度减1</span></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getListElem</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getListElem</span>(<span class="params">list: number[], index: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; getLength(list) + <span class="number">1</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getElemIndex(L, e)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndex</span>(<span class="params">list: number[], value: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; getLength(list); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list[i] === value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再用一个 test 函数测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sqList = createList();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;创建空顺序表：&quot;</span> + sqList);</span><br><span class="line">  initList(sqList);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;初始化一个数字类型顺序表：&quot;</span> + sqList);</span><br><span class="line">  <span class="keyword">let</span> elem = getListElem(sqList, <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;获取第五个元素：&quot;</span> + elem);</span><br><span class="line">  <span class="keyword">let</span> index = getListIndex(sqList, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;获取值为6的游标：&quot;</span> + index);</span><br><span class="line">  insertList(sqList, <span class="number">4</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;在第四个位置插入999：&quot;</span> + sqList);</span><br><span class="line">  <span class="keyword">let</span> e = deleteList(sqList, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;删除第四个位置的元素：&quot;</span> + sqList, <span class="string">&quot;被删除的元素：&quot;</span> + e);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;表长为：&quot;</span> + getLength(sqList));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;所有元素为：&quot;</span>);</span><br><span class="line">  consAll(sqList); <span class="comment">// 输出所有元素</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>一个简单的顺序表就完成了～，接下来介绍链表。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>先介绍以下何为<strong>链表</strong> 链表也是线性表中的一元，它也是一个连续的表，不过相比于顺序表，它不要求物理位置上相邻，但要求的是逻辑位置上相邻，因此他没有顺序表所具有的弱点——删除、插入等需要移动大量的数据元素，但是也失去了顺序表随机存储的优点。</p>
<p>对于一个数据元素，我们这里把它叫做结点好了，一个<strong>结点（Node）</strong>中包含两个域，一个是存储自身信心的<strong>数据域</strong>，另一个是指向下一个结点的<strong>指针域</strong>，由于 js 里没有指针，那么我暂且称之为<strong>链域</strong>，指向的是该结点的下一个结点。从上图我们还发现了一个 head 结点，我们把它称之为 <strong>头指针</strong>，他的数据域可以不存储任何数据，也可以存储像表长等信息，其链域中存储的是指向链表的第一个结点的链。可能现在会对头指针的存在产生一个疑惑，那么我举个例子就明白了，试想一下，如果没有头指针，我们如何在第一个结点前再插入一个结点呢？这个操作很简单，就是把你新创建的结点的链域指向第一个结点，但是如果你不是插入到链表的最前面呢？你要先创建一个结点，然后让想插入的那个位置的前一个结点的链域指向你新创建的结点，再让你的链域指向你想插入的位置的那个结点。发现了吗？插入第一个和插入中间其他位置的操作是不相同的，为了简化和统一像这样的操作，于是引入头指针。链表的最后一个结点之后没有结点的存在，因此让他的链指向<code>NULL</code> 在传统语言如 c/c++中，因为有指针的存在，可以很明确的创建一个链表，而 js 中是没有指针的（this 应该不算吧）,那我们要如何去实现一个链表的结点呢？一开始想到用<code>对象Object</code>实现，但是对象复制有一些麻烦，于是转而选择了<code>类function</code>，看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LNode</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用公用属性 data 当作结点的数据域，用公有属性 next 当作链域，当新建一个结点的时候只需要 <code>new LNode()</code>即可，比较方便，当然，也可以使用 es6 的<code>class</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 typescirpt 用的有一些生疏，以及 class 用的不太熟练，先用 es5 实现那些方法。 代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LNode</span>(<span class="params"></span>) :<span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLink</span>(<span class="params">head: any, n: number</span>): <span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number;</span><br><span class="line">  head.data = n</span><br><span class="line">  <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> LNode()</span><br><span class="line">    newNode.data = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>)</span><br><span class="line">    newNode.next = head.next</span><br><span class="line">    head.next = newNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElem</span>(<span class="params">LinkList: any, i: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!LinkList.next) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p: any = LinkList.next</span><br><span class="line">  <span class="keyword">let</span> j: number = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123; p = p.next ++j &#125; <span class="keyword">if</span> (!p || j &gt; i) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndexs</span>(<span class="params">LinkList: any, value: number</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!LinkList.next) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p: any = LinkList.next</span><br><span class="line">  <span class="keyword">let</span> indexs: number[] = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">let</span> len = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> i: number = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.data === value) &#123;</span><br><span class="line">      indexs[len] = i</span><br><span class="line">      len++</span><br><span class="line">    &#125;</span><br><span class="line">    p = p.next</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> indexs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertElem</span>(<span class="params">LinkList: any, pos: number, e: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!LinkList.next) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p: any = LinkList</span><br><span class="line">  <span class="keyword">let</span> i: number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p &amp;&amp; i &lt; pos - <span class="number">1</span>) &#123; p = p.next i++ &#125; <span class="keyword">if</span> (!p || i &gt; pos - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> s = <span class="keyword">new</span> LNode()</span><br><span class="line">  s.data = e</span><br><span class="line">  s.next = p.next</span><br><span class="line">  p.next = s</span><br><span class="line">  LinkList.data++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consAll</span>(<span class="params">LinkList: any</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list: <span class="built_in">String</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> p: any = LinkList.next</span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    list += p.data + <span class="string">&#x27;, &#x27;</span></span><br><span class="line">    p = p.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteElem</span>(<span class="params">LinkList: any, i: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!LinkList.next) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p: any = LinkList.next</span><br><span class="line">  <span class="keyword">let</span> j: number = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> e: number</span><br><span class="line">  <span class="keyword">let</span> q</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123; p = p.next ++j &#125; <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q = p.next</span><br><span class="line">  p.next = q.next</span><br><span class="line">  <span class="comment">// 由于js的垃圾回收机制，不需要手动释放内存</span></span><br><span class="line">  LinkList.data--</span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLenth</span>(<span class="params">LinkList: any</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!LinkList.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p = LinkList.next</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    p = p.next</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">  <span class="comment">// 由于我把表长存在头结点的data中，所以可以直接 return LinkList.data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> L = <span class="keyword">new</span> LNode()</span><br><span class="line">  createLink(L, <span class="number">10</span>)</span><br><span class="line">  consAll(L)</span><br><span class="line">  <span class="built_in">console</span>.log(getIndexs(L, <span class="number">5</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(getElem(L, <span class="number">4</span>))</span><br><span class="line">  insertElem(L, <span class="number">3</span>, <span class="number">999</span>)</span><br><span class="line">  consAll(L)</span><br><span class="line">  deleteElem(L, <span class="number">7</span>)</span><br><span class="line">  consAll(L)</span><br><span class="line">  <span class="built_in">console</span>.log(getLenth(L))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>用 js 实现数据结构比 C/C++更容易，为了更加靠近，我在这里使用了一部分 typescript，最近还学习了 kmp 算法，快排，栈，图，队列，广度优先算法，狄克斯特拉算法等等，将在今后的博客一一列出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《数据结构》 严蔚敏 （PS: 这本书。。不好）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>javascript</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>你所不知道的HTML —— 规范篇</title>
    <url>/2017/12/24/unknowhtml-standard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="资源引入"><a href="#资源引入" class="headerlink" title="资源引入"></a>资源引入</h2><ol>
<li>移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。这是因为使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h2><ol>
<li><p>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度</p>
</li>
<li><p>结构顺序和视觉顺序基本保持一致，按照从上至下、从左到右的视觉顺序书写 HTML 结构。有时为了便于搜索引擎抓取，也会将重要内容在 HTML 结构顺序上提前</p>
</li>
<li><p>结构、表现、行为三者分离，避免内联</p>
</li>
<li><p>每一个块级元素都另起一行，每一行都使用 Tab 缩进对齐（head 和 body 的子元素不需要缩进）。删除冗余的行尾空格</p>
</li>
<li><p>对于内容较为简单的表格，建议将 tr 写成单行</p>
</li>
<li><p>可以在大的模块之间用空行隔开，使模块更清晰</p>
</li>
</ol>
<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>浏览器会根据标签的语义给定一个默认的样式。判断网页标签语义化是否良好的一个简单方法：去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</p>
<ol>
<li><p>尽可能少地使用无语义标签 span 和 div</p>
</li>
<li><p>在语义不明显，既可以使用 p 也可以使用 div 的地方，尽量用 p</p>
</li>
<li><p>在既可以使用 div 也可以使用 section 的地方，尽量用 section</p>
</li>
<li><p>不要使用纯样式标签，如 b、u 等，而改用 CSS 设置</p>
</li>
</ol>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol>
<li>同一页面，应避免使用相同的 name 与 id。因为 IE7-浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心</li>
</ol>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ol>
<li><p>标签名小写</p>
</li>
<li><p>无需自闭合的标签，不要自闭合</p>
</li>
<li><p>对于<code>html5</code>中规范中允许省略的闭合标签，不要省略</p>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li><p>属性和值全部小写</p>
</li>
<li><p>属性值必须用双引号包围</p>
</li>
<li><p>布尔类型的属性，建议不添加属性值</p>
</li>
<li><p>自定义属性建议以 xxx- 为前缀，推荐使用 data-</p>
</li>
<li><p>可以省略 style 标签和 script 标签的 type 属性</p>
</li>
</ol>
<h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><p>HTML 属性应该按照特定的顺序出现以保证易读性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">class</span><br><span class="line">name</span><br><span class="line">data-xxx</span><br><span class="line">src, for, type, href</span><br><span class="line">title, alt</span><br><span class="line">aria-xxx, role</span><br></pre></td></tr></table></figure>

<h2 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ol>
<li><p>禁止 img 的 src 取值为空，否则会导致部分浏览器重新加载一次当前页面</p>
</li>
<li><p>为图片添加 alt 属性，提高图片加载失败时的用户体验</p>
</li>
<li><p>避免为 img 添加不必要的 title 属性，多余的 title 影响看图体验，并且增加了页面尺寸</p>
</li>
<li><p>为图片添加 width 和 height 属性，以避免页面抖动</p>
</li>
<li><p>有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现</p>
</li>
<li><p>产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载, 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 css 背景图实现</p>
</li>
</ol>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ol>
<li>有文本标题的控件使用 label 标签将其与其标题相关联。最好将控件置于 label 内，以减少不必要的 id</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;label</span><br><span class="line">  &gt;<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;confirm&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 我已确认上述条款&lt;/label</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 button 元素时必须指明 type 属性值。因为 button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性，能获得友好的输入体验</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术杂文</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>你所不知道的HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress + nginx 修改固定链接</title>
    <url>/2017/10/14/url-rewrite/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>wordpress 固定链接一直都很想改，因为默认的参数格式实在是太丑了。</p>
<p>一开始以为只要更改 wordpress 仪表盘里的固定链接格式，改好格式后点开文章后，？？？404 nginx？？？于是对 wordpress 这个设置一直觉得他是不是出 bug 了（=。=），于是开始在各大搜索引擎上查找。</p>
<a id="more"></a>

<p>原来光 wordpress 里设置是不够的，这个是需要服务器设置 URL rewrite 的。但是 Apache 和 Nginx 之间配置是有一定的差别的，这里只贴出 Apache 的配置方法，就不详细介绍了：</p>
<h3 id="Apache-环境下开启-url-rewrite："><a href="#Apache-环境下开启-url-rewrite：" class="headerlink" title="Apache 环境下开启 url_rewrite："></a>Apache 环境下开启 url_rewrite：</h3><ol>
<li>开启 apache 的 url_rewrite 模块，也就是在 httpd.conf 中去掉这句话的注释 LoadModule rewrite_module modules/mod_rewrite.so</li>
<li>找到 AllowOverride，把 AllowOverride None 修改成 AllowOverride all</li>
<li>在所需要进行 rewrite 的 web 的主目录下添加.htaccess 文件，添加上一句话：RewriteEngine on</li>
</ol>
<p>由于我的服务器是由 nginx 来部署的，所以接下来来说说如何在 nginx 中配置 url_rewrite。</p>
<h3 id="Nginx-环境下开启-url-rewrite："><a href="#Nginx-环境下开启-url-rewrite：" class="headerlink" title="Nginx 环境下开启 url_rewrite："></a>Nginx 环境下开启 url_rewrite：</h3><p>打开 wordpress 仪表盘 —&gt; 设置 —&gt; 固定链接，在他的最下面有一个链接，即指向 nginx 配置文档，但是其中的内容对于不熟悉 nginx 的我来说太乱太杂，所以它并没有解决我的问题（可能我太蠢了。。），在自己搜索一番，在服务器配置里翻来翻去（并没有改=。=）之后，还是没有头绪如何去解决，这时候只好请出大佬田花花。 大佬思考了一会，告诉我有三个选择：</p>
<ol>
<li>服务器换 Apache</li>
<li>装 docker</li>
<li>更改 nginx 配置</li>
</ol>
<p>一开始说换 Apache，说 php 的后台和 Apache 配合使用比较好一些，但不知道是步骤有些麻烦还是怎么的，并没有选择这个。于是选择了装 docker，据大佬所说，使用 docker 的话修改这个十分的简单，于是开始了装 docker 之旅。</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>首先打开了 github，搜索进入了 docker/compose，应该是一个配合 docker 使用的一个插件？安装好了之后，开始安装 docker。打开 docker 的官网: <a href="http://www.docker.com/">www.docker.com</a>，找到 centos 安装 docker（一开始还以为自己是 ubuntu），输入命令之后，等待一会会就出现了错误，安装失败，于是大佬觉得可能是 yum 的版本太低了，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum upgrade</span><br></pre></td></tr></table></figure>

<p>更新了一下 yum，更新完成之后再次安装，结果还是失败，于是查看了一下 centOs 的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/system-release</span><br><span class="line">CentOS release 6.9 (Final)</span><br></pre></td></tr></table></figure>

<p>额。。gg，这个版本是用不了 docker 的。那样的话，也就只能使用第三个选择。</p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>这里我不是特别清楚原理，先直接上如何进行操作吧：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d/</span><br><span class="line">nano default.d</span><br></pre></td></tr></table></figure>

<p>于是出现如下配置内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/log/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line"></span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    location ~ php.$ &#123;</span><br><span class="line">      fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">      fastcgi_index   index.php;</span><br><span class="line">      fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">      include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>location / &#123;&#125;</code> 内添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!-e <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">  rewrite ^/(.*)$ /index.php/<span class="variable">$1</span> last;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>把</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ~ php.$ &#123;</span><br><span class="line">  fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">  fastcgi_index   index.php;</span><br><span class="line">  fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">  include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ~ ^.+.php &#123;</span><br><span class="line">  fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">  fastcgi_index   index.php;</span><br><span class="line">  fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">  include        fastcgi_params;</span><br><span class="line">  fastcgi_split_path_info ^((?U).+.php)(/?.+)$;</span><br><span class="line">  fastcgi_param PATH_INFO <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">  fastcgi_param PATH_TRANSLATED $document_root<span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存，重启 nginx：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>大功告成！刷新博客，很成功～感谢田花花大佬的帮助。</p>
]]></content>
      <categories>
        <category>技术杂文</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>[vue-cli] 解决 npm run dev 之后在某些浏览器上一片空白</title>
    <url>/2018/01/05/vue-cli-whitepage/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用开发模式启动项目后，在同一局域网通过手机连接项目，在一些手机厂商自带浏览器上产生空白页面，渲染失败。</p>
<a id="more"></a>

<h2 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h2><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p>在 vue-cli 中，这可能是我们用的最频繁的命令了，来看一下<code>package.json</code> 里:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node build/build.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>主要看 <code>dev</code> 这个属性的值:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</span><br></pre></td></tr></table></figure>

<p>来解读一下这一行命令</p>
<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>找到 <code>node_modules</code> 目录下的 <code>webpack-dev-server</code>，看它的<code>readme</code> 中可以得到以下信息：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Either method will start a server instance and begin listening for connections from <span class="code">`localhost`</span> on port <span class="code">`8080`</span>.</span><br><span class="line"></span><br><span class="line">webpack-dev-server is configured by default to support live-reload of files as you edit your assets while the server is running.</span><br></pre></td></tr></table></figure>

<p>意思是，输入命令 <code>webpack-dev-server</code> 就会在 <code>8080</code> 端口启动一个本地服务器，支持热重载，也就是你修改了静态文件内容无需刷新，页面直接更新的意思。</p>
<p>那后面那些参数什么意思呢？</p>
<p>首先是 <code>--inline</code>，这是支持自动刷新的一种模式，还有另一种是<code>--iframe</code>。</p>
<p>在 <code>iframe</code> 模式下：页面是嵌套在一个 <code>iframe</code> 下的，在代码发生改动的时候，这个 <code>iframe</code> 会重新加载；</p>
<p>在 inline 模式下：一个小型的 <code>webpack-dev-server</code> 客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。</p>
<p>不过 <strong>Iframe mode</strong> 和 <strong>Inline mode</strong> 最后达到的效果都是一样的，都是监听文件的变化，然后再将编译后的文件推送到前端，完成页面的 reload 的。</p>
<p>对于 <code>--process</code>，是用于显示打包的进度，如果我们去掉它，或者换成 <code>--quiet</code>，就不会出现那些百分比的东西。</p>
<p>最后 <code>--config</code>，<code>config</code> 后面跟着一串路径，指定的是 webpack 配置文件的路径。</p>
<p>ok，介绍完了，进入今天的正题</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>执行 <code>npm run dev</code> 之后，pc 端正常访问，手机局域网访问一片空白，无法正常访问，但是 build 之后可以正常访问，于是开启了 qq 浏览器的调试，发现有这样一个报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SyntaxError: Use of const <span class="keyword">in</span> strict mode</span><br></pre></td></tr></table></figure>

<p>发现是 es6 的语法不兼容，但一想到 dev 和 pro 模式的不同表现，那应该是就 babel 在 dev 与 pro 之间的配置不同。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>进入 <code>webpack.base.conf.js</code> 里面，找到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    include: [resolve(<span class="string">&#x27;src&#x27;</span>), resolve(<span class="string">&#x27;test&#x27;</span>)]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>将其改成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    include: [resolve(<span class="string">&#x27;src&#x27;</span>), resolve(<span class="string">&#x27;test&#x27;</span>), resolve(<span class="string">&#x27;node_modules/webpack-dev-server/client&#x27;</span>)]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>再将<code>.babelrc</code>添加一行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;es2015&quot;</span>, &#123;<span class="string">&quot;modules&quot;</span>: <span class="literal">false</span>&#125;],</span><br></pre></td></tr></table></figure>

<p>重新启动<code>npm run dev</code> 再用手机访问，OK，成功了。</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue build 过程中遇到的坑</title>
    <url>/2017/12/23/vue-build-kengs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一号坑-npm-install-已解决"><a href="#一号坑-npm-install-已解决" class="headerlink" title="一号坑[npm install] - 已解决"></a>一号坑[npm install] - 已解决</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>github 项目迁移至 coding，本地切换到另一个文件夹，重新 <code>npm install</code> 失败。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><code>npm install</code>: 时间长，且结束后报错</p>
<p><code>yarn</code>: 一直处于安装状态，但目录下生成了 <code>node_modules</code>，尝试 <code>npm run build</code> 后报错。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>cnpm</code> 解决（ <code>cnpm</code> 真好用 _(:з ゝ ∠)_）</p>
<h2 id="二号坑-static-文件-404-已解决"><a href="#二号坑-static-文件-404-已解决" class="headerlink" title="二号坑[static 文件 404] - 已解决"></a>二号坑[static 文件 404] - 已解决</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>build 成功之后，得放在服务器上跑，build 之后也有提示:</p>
<blockquote>
<p>Tip: built files are meant to be served over an HTTP server.<br>Opening index.html over file:// won’t work.</p>
</blockquote>
<p>于是，我便将文件夹上传服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r ~/my-github/ncuniversity/gpa/gpa-static/dist xxx@xxx.xxx:/path/</span><br></pre></td></tr></table></figure>

<p>上传好后访问网站，控制台一堆 404 错误，而且加载的比较慢。</p>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>看了一下资源请求的路径，竟然全是 <code>/static</code>，这就尴尬了，想了想本地跑没问题，应该是 <code>webpack</code> 打包的问题，于是重新看了一下<code>webpack</code>的配置文件 <code>config/index.js</code> 中，在 <code>build &#123;&#125;</code> 内，有一行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    assetsPublicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该就是这个了，使我的资源一直处于绝对路径下。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>将上面代码改成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    assetsPublicPath: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样应该就能使资源处于相对路径下了~</p>
<p>重新 build 后发现问题解决。</p>
<h2 id="三号坑-请求-404-已解决"><a href="#三号坑-请求-404-已解决" class="headerlink" title="三号坑[请求 404] - 已解决"></a>三号坑[请求 404] - 已解决</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li>发送请求，显示请求 404</li>
<li>请求跨域</li>
</ol>
<h3 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h3><p>本地为了解决跨域，使用了 proxy-table 去代理，然后请求的路径那里写的绝对路径:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getUserInfo () &#123;</span><br><span class="line">    <span class="built_in">this</span>.$http(&#123;</span><br><span class="line">        url: <span class="regexp">/api/</span>common/<span class="string">&#x27; + this.user.username.value,</span></span><br><span class="line"><span class="string">        mothod: &#x27;</span>GET<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        timeout: 4000</span></span><br><span class="line"><span class="string">    &#125;).then(_ =&gt; ...)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是打包后 proxy-table 就会失效。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 nginx 服务器上配置反向代理，将请求本机服务器的请求转发到目标服务器上。具体可以参见 <code>nginx 反向代理</code>。</p>
<p>如果遇到跨域问题可以让后端配置 <code>CORS</code></p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Vue-cli——目录结构探秘</title>
    <url>/2017/08/04/vue-cli-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里先说一下使用 vue-cli 之前的事情。</p>
<p>由于刚刚接触 Vue 不久，就接到了一个移动端项目，于是打算使用 vue 来进行一次尝试，所以按照练习时候的样子，emmm 先把 vue.js 引入网页里来，emmm 自己的外联 main.css 样式引进来，还有自己的 main.js 文件，还有一些图片布拉布拉的.</p>
<a id="more"></a>

<p>所以我整个项目的结构如下：（捂脸）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── css</span><br><span class="line">├── images</span><br><span class="line">├── index.html</span><br><span class="line">└── js</span><br></pre></td></tr></table></figure>

<p>由于之前我连路由，组件什么的都不会用，所以项目效果可想而知，连点击文章标题显示文章都是用弹窗来实现的（捂脸），一按返回就退出了整个网页有木有，体验效果极其糟糕，于是自己强行加了几个“返回”按钮，（实际就是 v-show 的切换 emmmm），各种栏目的切换也是通过这个，然后。。。产品就要求我改了，啊啊没办法，只好重写咯，这时学长推荐了使用 vue-cli 来快速开发，于是就开始了 vue-cli 的尝试之旅。</p>
<h2 id="Vue-cli-安装以及目录说明"><a href="#Vue-cli-安装以及目录说明" class="headerlink" title="Vue-cli 安装以及目录说明"></a>Vue-cli 安装以及目录说明</h2><p>之前看 Vue 官方文档的安装的时候，在命令行工具那里看见了 vue-cli 的安装，也尝试过，不过也就是初始化了一个项目，然后看见哇竟然自动在本地 <code>localhost:8080</code> 跑起来了，觉得很神奇，然后。。就没管它了，感觉自己像个智障，然后之前初始化的也找不到了，然后就重新初始化了一个项目，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装 vue-cli</span></span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个基于 webpack 模板的新项目</span></span><br><span class="line">$ vue init webpack my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖，走你</span></span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>

<p>没错，我就是直接从官网复制粘贴过来的，不过把 <code>my-project</code> 改成了 campusnews，emmm..在 VSCode 上把文件夹打开一看，我屮艸芔茻，这些都是什么玩意，这么一大堆东西，鬼都看不懂哦，不说了，放上来体会一下： …….算了，本来打算用 tree 生成一下所有的结构树，还是就展示一下主目录吧～</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">├── config</span><br><span class="line">├── index.html</span><br><span class="line">├── node\_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── README.md</span><br><span class="line">├── src</span><br><span class="line">└── static</span><br></pre></td></tr></table></figure>

<p>看不懂哦，只好去找找资料了，以下是我经过查找资料和自己的理解来讲述的，如有错误希望指正～</p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>这里主要是放 webpack 的一些配置，<code>webpack</code> 是前端网站的一种构建集成工具</p>
<h4 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── build.js</span><br><span class="line">├── check-versions.js</span><br><span class="line">├── dev-client.js</span><br><span class="line">├── dev-server.js</span><br><span class="line">├── utils.js</span><br><span class="line">├── vue-loader.conf.js</span><br><span class="line">├── webpack.base.conf.js</span><br><span class="line">├── webpack.dev.conf.js</span><br><span class="line">└── webpack.prod.conf.js</span><br></pre></td></tr></table></figure>

<h5 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h5><p>build 文件夹里有一个 build.js ，是我们完成项目之后需要运行的， 可以将我们的项目文件打包成 静态文件，存放在项目根目录的 dist 文件夹中（现在目录里还没有这个文件夹，build 的时候会自动生成），当然你可以自己设置路径，是在。。应该是在 config 文件夹中的 index.js 中改，可以指定主页，默认是 index.html。</p>
<h5 id="check-versions-js"><a href="#check-versions-js" class="headerlink" title="check-versions.js"></a>check-versions.js</h5><p>主要是检查一些所依赖的工具的版本是否适用，如 nodejs、npm，若版本太低则会提示出来。</p>
<h5 id="dev-client-js"><a href="#dev-client-js" class="headerlink" title="dev-client.js"></a>dev-client.js</h5><p>应该是本地客户端开发中有关热更新的吧～</p>
<h5 id="dev-server-js"><a href="#dev-server-js" class="headerlink" title="dev-server.js"></a>dev-server.js</h5><p>是一个用作服务器端的东西，涵盖了 express 和它的一些模块，为了在本地服务器上把我们的项目跑起来的一个文件，引入了反向代理的模块，我们可以用来发起跨域请求。</p>
<h5 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a>utils.js</h5><p>（是一个功能模块？）里面引入了一些 css-loader，以便于解析各种格式的 css，如 less，sass 什么的。</p>
<h5 id="vue-loader-conf-js"><a href="#vue-loader-conf-js" class="headerlink" title="vue-loader.conf.js"></a>vue-loader.conf.js</h5><p>它把上面的 utils.js 引入了，应该是用于切换 开发模式和 生产模式的文件吧，以便于用不同模式来解析 css。</p>
<p>下面那三个我只知道是 webpack 的一些打包的设置，比如指定入口文件啊，依赖安装路径啊，对不同后缀的文件用不同的 loader 去解析呀什么的。目前不了解这个也对我们开发项目影响不大～</p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>不知道干啥的，应该是配置文件</p>
<h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><p>依赖所存在的文件，就是我们一开始使用 <code>npm install</code> 安装的东西，都在里面，以后我们要添加依赖也是放在这个里面，可能有人会又疑问，你 <code>npm install</code> 后面啥也没加啊，你安装了啥。一看就是不了解 <code>npm</code> 的人（虽然我也不了解（捂脸）），<code>npm install</code> 可以从当前根目录中的 package.json 文件中读取所要安装的模块的名称和版本，然后一次性安装所有的依赖。</p>
<h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>终于到了最重要的部分，src 目录就是一般我们需要写的地方了。</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── App.vue</span><br><span class="line">├── assets</span><br><span class="line">├── components</span><br><span class="line">├── main.js</span><br><span class="line">└── router</span><br></pre></td></tr></table></figure>

<h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><p>是我们的主组件，也是我们所有组件和路由的出口，之后他会被渲染到我们项目根目录的 index.html 中显示出来，我们可以在这里写一些适合全局的 css 样式，比如说 css reset，字号，字体什么的。</p>
<h5 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h5><p>是我们放一些静态图片资源的目录，虽然我没有放图片在里面。</p>
<h5 id="components"><a href="#components" class="headerlink" title="components"></a>components</h5><p>这里存放的是我们写的各种组件，各个组件联系在一起组成一个完整的项目</p>
<h5 id="router"><a href="#router" class="headerlink" title="router"></a>router</h5><p>我们定义路由的地方，虽然也可以直接在 main.js 中直接定义，但是分开的话结构更加清晰，路由的定义我们下次再说～</p>
<h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>入口文件，引入了 vue 模块 和 app.vue 组件 以及 路由 router，我们需要在全局使用的一些东西也可以定义在这里面。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>用于存放我们需要使用的一些外部的 js、css 文件，需要使用的时候从这里引到文件内。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，至此整个 vue-cli 的目录我们都过了一遍，虽然我写的不是很详细，甚至有错误，待我慢慢学习并更新咯，希望各位看官老爷能指出，谢谢。</p>
]]></content>
      <categories>
        <category>技术杂文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>在命令行中用vscode打开文件</title>
    <url>/2017/10/15/vscode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于 zsh 方便地使用 vscode 打开文件</p>
<a id="more"></a>

<p>只需要在~/.zshrc 中添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">code</span></span> () &#123;</span><br><span class="line">  VSCODE_CWD=<span class="string">&quot;<span class="variable">$PWD</span>&quot;</span></span><br><span class="line">  open -n -b <span class="string">&quot;com.microsoft.VSCode&quot;</span> --args $* ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后只需要在终端输入 <code>code</code> 即可打开 vscode，输入 <code>code path/to/文件名</code> 就可以使用 vscode 来打开相应的文件。</p>
]]></content>
      <categories>
        <category>专治懒癌</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router 非定义路由的访问</title>
    <url>/2018/03/16/vue-router-404/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在写<code>vue</code>的路由表时，通常会遇到这样的一个问题，<strong>我已经定义了一系列路由，但我想要用户在访问非定义的路由的时候返回一个提示或者重定向至指定页面。</strong>该如何实现？</p>
<a id="more"></a>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我想到的是监听<code>hash</code>的变化，根据已经定义的路由来判断是否是非定义的路由，但这样有个问题，当定义其他路由或修改路由的时候，监听路由变化的函数也要修改，这就造成了一个很强的耦合性，因此此方法并不实用。 但略微查看<code>vue-router</code>的官方文档，没有看到相关的解决方案，于是在 google 搜索相关的问题，在一篇博客里看到一句话：</p>
<blockquote>
<p>又一个在使用 Vue 过程中遇到的新坑。首先踩这个坑都怪我自己看文档不够仔细，所以告诫大家，看文档真的一定要认认真真的一个个字的认真的品味。 vue-router 动态路由匹配 中有这么一段： 匹配优先级 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>
</blockquote>
<p>吓得我又回去翻看了一下文档，果然，在最最下面有一个匹配优先级。。 因此，想到了一个更加简单的方法去实现限制非定义路由的访问：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// 404 置后</span></span><br><span class="line">   path: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">   component: &#123;</span><br><span class="line">     beforeCreate () &#123;</span><br><span class="line">       <span class="built_in">window</span>.swal(&#123;</span><br><span class="line">         type: <span class="string">&#x27;warning&#x27;</span>,</span><br><span class="line">         title: <span class="string">&#x27;404 NOT FOUND&#x27;</span>,</span><br><span class="line">         timer: <span class="number">1000</span>,</span><br><span class="line">         showConfirmButton: <span class="literal">false</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     template: <span class="string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>window.swal</code>是引用的<code>sweetalert.js</code>的一个方法，主要作用就是一个美化提示弹框。 而对于这个<code>component</code>对象内的<code>beforeCreate</code>就很陌生了，为什么配置路由的<code>component</code>会出现这个，难道是属于路由的生命周期？ 但转念一想，<code>component</code>里本来应该的数据是什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    component: <span class="built_in">require</span>(<span class="string">&#x27;@/views/hello&#x27;</span>) <span class="comment">// 类似写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>component 内本该是由一个<code>单文件组件</code> (.vue 文件) <code>export</code>出来的，因此，我认为这里的<code>beforeCreated</code>其实是组件的生命周期，因为在非单文件组件中，定义一个组件的方式就是如此： 这是一个官方的 demo:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  data () &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; 将只在父组件模板中可用</span></span><br><span class="line">    <span class="string">&#x27;my-component&#x27;</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以由此可以看出，我的判断应该无误，ok，大功告成！</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.6月 头条前端三面 面经</title>
    <url>/2019/06/12/byteDance-intervies/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单记录一下第二次面试的经历，之后总结各个不熟悉知识点再进行整理。</p>
<a id="more"></a>
<h2 id="为什么选择实习"><a href="#为什么选择实习" class="headerlink" title="为什么选择实习"></a>为什么选择实习</h2><p>考研or实习都是一种选择，不同的人适合不同的路，都需要结合自己的实际情况来决定。</p>
<p>就拿我自己来说吧，从大一开始接触互联网，接触前端后，自己对考研就没有什么想法了，因为当时自己对考研也没有什么概念，而且也遇到了自己比较喜欢的前端，觉得做前端是一件很幸福的事情。再加上优秀的学长拿到各种offer，自己心里对以后的自己也更加期盼，希望自己和他们一样优秀。</p>
<p>一步步走来，也遇到了很多困惑，也经常陷入到非常迷茫的状态，总是反问自己，自己是否真的适合做前端呢？加上周边人都非常优秀，自卑和不自信总是让我焦躁不安。加上大二下学期 Teambition 的面试失利，更觉得自己出来是根本找不到好工作/实习。再加上家人希望我考研的想法、女票考研、想深造等等的原因让我在大三上学期中下旬做出了去考研的决定，觉得尝试过了，就算失败没考上也是不会后悔，而且就算失败了到时候出来凭借自己三年来所学的前端知识应该也不至于没事做。抱着这样的想法，我踏上了考研的征途。</p>
<p>我开始了解有关考研的一切：学校、科目、复习计划、书籍等等等，开始每天英语，数学的轮番轰炸，开始6点半起床7/8点开始学习，到晚上10点多结束的生活，也早早的定好了意向学校。每天就是看视频、记笔记、学英语，但是学校也有一些事情(比如徐某的作业)，也会干扰的自己的一些复习计划，加上女票因为一些身体原因也经常需要去医院之类的，我也应该陪同。在各种干扰下，自己的一个学习进度一直很缓慢，做题也非常的慢，心中难免会焦虑。而周某人=。=一天到晚给我发各种实习，扰乱我的心境(雾)，让我一再有屏蔽他的想法(23333)。</p>
<p>但自己还是硬着头皮坚持了几个月，但每天并没有学习一天的充实感，学习进展也随着难度的增大而更加缓慢。之后让我再去思考到底是考研或者实习就发生在彪彪去头条实习之后。我开始仔细考虑，自己是否真的要去考研。</p>
<p>花了一个星期，我一直考虑以下问题：</p>
<ol>
<li>考研的目的是什么</li>
<li>以后想从事什么方面的工作</li>
<li>考研会给我带来什么，实习会给我带来什么</li>
<li>对于以后想从事的行业是否对学历有着硬性的要求</li>
<li>自己现在的水平能不能找到一份较为满意的实习</li>
<li>一年后如果失败了如何应对</li>
<li>是否会后悔自己的决定</li>
</ol>
<p>我的想法依次如下：</p>
<ol>
<li>对我而言，考研是为了：<ol>
<li>提高学历</li>
<li>深造以获得更多选择</li>
<li>重新学习大学的课程</li>
<li>陪女票一起，度过这段困难的时期</li>
<li>满足家人的要求</li>
<li>提高自己的竞争力</li>
</ol>
</li>
<li>了解了关于云计算、大数据之类的，再读了一些关于分布式的论文后觉得这行也挺有意思的，想着如果能考上研究生希望去研究这一方面的技术。或者继续从事前端相关的事情。但后面更深入的了解关于云计算、大数据的一些具体的东西，觉得自己可能不太适合。但事无绝对，你没有深入一个行业去了解你永远无法知道自己到底适不适合它。但至少，前端我是很喜欢的也愿意去做相关的行业。</li>
<li>考研给我带来的也就是我考研的目的，而实习的话我在最初的选择也只有前端这一个选择，那么实习给我带来的是更早的接触公司的一些实际需要考虑的一些问题，技术上的提升，更早的经济收入、社会了解等等。</li>
<li>如果从事前端，在学历要求上更没有其他岗位的那么严格，初级阶段门槛也比较低。但是如果想往人工智能、大数据等方向进行发展的话，大部分还是会要求一个研究生的学历的。因为它需要这样一个较高门槛才可以去真正做出一些东西来的。</li>
<li>对于自己的水平，我一直是不是很自信，觉得自己学的东西比较浅，也有一些浮躁。虽然之前大二Teambition面试失败，但是很大一部分原因归结于自己没有准备(裸试可还行。。)，所以对于自己的水平到底能否去承担起一个这样的职位还是没有底的。而后面彪彪拿到offer也给我了一些信心，我觉得我跟彪彪的水平差不多，我也许可以去尝试一下。</li>
<li>对于失败，我从一开始就非常的坚定，绝不二战的，失败了就直接去找前端的实习工作。但是，一年前端的空窗期会对自己的水平造成多大的影响以及前端行业的一年后会发展成什么样自己能否跟上，这些都是让我所担忧的。</li>
<li>选择前端，我不会后悔，至少我对考研我尝试过几个月，了解自己的一个学习状态。而对于选择考研，并不知道自己是否会后悔。</li>
</ol>
<p>综合考虑一些问题之后，和家里人也沟通了很多次，各种思想斗争后，还是决定重拾前端。对于前端，我始终有着很大的热情，能够且愿意把时间花在上面，就算是遇到困难也会慢慢沉下心去解决。对于考研，我已经尝试过了，觉得自己的精力无法再全身心的投入进去，就算之后想起这个决定也不会觉得后悔。</p>
<p>就这样，我做出了这个决定，一个不再回头的决定 —— 找实习</p>
<h2 id="实习准备"><a href="#实习准备" class="headerlink" title="实习准备"></a>实习准备</h2><p>由于花费了数个月去准备考研，对于前端的知识就忘了一些，在提前联系了在头条的学长咨询相关情况后，决定先花一个月来准备，刚开始的计划是这样：</p>
<ol>
<li>每天两道leetcode算法题</li>
<li>刷面经</li>
<li>每天看看公众号文章以及掘金文章</li>
<li>做一个关于react + typescript的项目</li>
<li>读一本关于前端工程化的书，再看看你不知道javascript</li>
<li>限定自己最晚投简历的一个时间(定为5月31日，但实际上6月2日才投)</li>
<li>每天解决一个自己不熟悉的点，列出了一份清单并贴在墙上</li>
</ol>
<p>后面发现写新的项目有点来不及，时间不是很充裕。真正做到了的也就是把一些不熟悉的清单项仔仔细细的去读懂，每天刷两道算法题(到了后面就刷的更少了)，读的书也只读了差不多一半，到后面快要到deadline就直接快速翻了翻相关的内容。</p>
<p>以上计划在这次面试除了第三点（也就是再去做个项目），都对这次面试起到了比较大的作用，其中起了较大作用的是 1， 2，6，7。然后最重要的就是刷面经了，通过刷面经，基本上解决了百分之六十的问题，很多被问到的问题也是我通过刷面经之后才知道的。所以刷面经很重要！！很重要！！很重要！！</p>
<p>关于简历的话，我还是使用了子健学长的简历模板，然后彪彪用的也是(然后在面试的时候就问了为啥你俩简历看起来样子都差不多)。如果有内推的话，简历只要把你的信息写好，做过哪些项目，会什么技术之类的写好就行，主要还是看笔试面试。</p>
<p>然后在这篇文章的最后会给出我看的一些比较好的文章的链接。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>每轮面试基本上都有一个自我介绍环境，简单介绍一下自己的信息，前端经历，项目经历，性格什么的。</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>第一面的面试官感觉是个很随和很好相处的人，给我的感觉就是聊天没有什么压力，如果你答对了会给你一些反馈，答错了也会给你解释一下(虽然我答错的题目他也不能很清晰说出个所以然来)</p>
<p>一面问的问题都比较基础，我把我能想起来的都写在下面：</p>
<hr>
<ol>
<li>自己实现一个bind</li>
<li>写一个算法：找到一个数组的子数组，使得这个子数组的和大于一个给定的值n，并且这个子数组最短。比如arr = [1,2,3,4,5,6]，n= 10，那么最短的就是 [5,6]</li>
<li>vue.$nextTick原理，回退方案</li>
<li>异步队列，宏任务微任务(通过代码的执行顺序考察)</li>
<li>如何判断数据类型，为什么用 Object.prototype.toString.call() 来做，直接toString为什么不行</li>
<li>setImmediate和setTimeout区别</li>
<li>闭包</li>
<li>逻辑运算(&amp;&amp;, || , !)，运算符优先级</li>
<li>this指向</li>
<li>“aaa” == new String(“aaa”) // true or false</li>
<li>null == undefined // true or false</li>
<li>字符串和数字运算得到的结果，比如 1 + “2” + 1 或者 “2” + 1 + “2” 或者 “2” - 0 + 3之类的</li>
<li>es6 modules 和 commonjs 模块方案之间的区别(不是用法上的区别)</li>
<li>http状态码</li>
<li>CSRF是什么，如何防御</li>
<li>垂直居中方案</li>
<li>position:relative相对谁定位</li>
<li>new操作做了哪些事情</li>
</ol>
<hr>
<p>上面只是说了一个大概的，面试官实际上拿了一份pdf笔试题给我做了一下，然后能想起来就这么多，基本上都回答出来了，除了第13点,和第2点(基本思路对了，但是代码跑了个死循环=-=)</p>
<p>然后真心觉得面试官很能聊得来，就像聊天一样没有什么压力。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的面试官比较严肃，给人一种居高临下的压力。这轮面试表现不太好，一方面是因为面对比较严肃的面试官我内心压力挺大，很多问题都有点答非所问。另一方面有些场景下原理了解的不是特别深，被问到就有点慌了阵脚。</p>
<p>下面是我能回想起来的一些问题：</p>
<hr>
<ol>
<li>cookie，sessionStorage, localStorage 作用和区别</li>
<li>写一个寄生组合式继承</li>
<li>说一下事件的执行机制(事件捕获、冒泡)</li>
<li>用过Jquery吗？$.on用过吗？</li>
<li>介绍一下http</li>
<li>https的通信原理</li>
<li>http2.0有哪些新特性</li>
<li>Vue的数据劫持，用Object.defineProperty相比于Proxy有什么缺点</li>
<li>Vue为什么需要this.$set</li>
<li>requestAnimationFrame是什么，用它做动画和setTimeout有什么区别</li>
<li>前端路由的实现原理(history, hash)</li>
<li>使用命令式代码进行路由跳转的时候(Router.push)，如何监听url的变化，(Router.push的具体实现相当于黑盒，不能修改)</li>
<li>什么是反向代理</li>
<li>网页扫码登陆是怎么做的</li>
<li>同源策略，如何跨域请求资源</li>
<li>请求跨域资源要发几次请求，请求同源资源发几次请求，option请求是做什么的</li>
<li>http的请求中包含哪些属性(比如Content-type之类的)</li>
<li>了解哪些加密算法，有什么区别</li>
<li>资源的缓存(协商缓存、强缓存)，区别</li>
<li>说一下事件委托</li>
<li>对nodejs了解多少</li>
<li>你的优势是什么</li>
<li>你的缺点是什么</li>
<li>你有什么问题想问的吗？</li>
</ol>
<hr>
<p>3,4,8,11,12,16,23这几点感觉回答的不太好，虽然原理都知道，但是进行一些扩展问一下就不懂了，比如说知道vue数据劫持的原理是什么，但是不知道那两个方案有什么区别。虽然知道路由实现的原理，但是对于后面的给出的场景(监听url变化)没有想到一个很好的解决方案(连最基本的暴力setInterval都没想到)。对于请求中包含的属性也没有说太多，感觉是因为紧张想不起来。</p>
<p>然后说缺点的时候有点作死，说自己对于不喜欢的事情可能不是那么上心。。然后面试官说那给你分配你一些你可能不喜欢的业务的时候你是不是也不上心不好好做。。这个缺点我没有提前去想好怎么说，然后感觉就比较作死。。</p>
<p>然后后面面试官也看出我比较紧张(虽然我也跟他说了)，然后让我调整心态，放松，不要沮丧。</p>
<p>wtf？我听到不要沮丧的时候我整个人都不好了。。难道我就死在二面了。。让我失败了也不要沮丧什么的。。当时我的心就凉了半截。。不过最后他说了这一轮给我过。。才放下心来。</p>
<p>后面问你有没有什么问题想问，我当时又作死去问他他觉得我表现怎么样。。不说了，最好不要问这个问题，现在想想脑子是不是哪根筋答错了。应该可以问问项目规划或者技术栈什么的。</p>
<p>对于二面，我想说的就是，学习知识的时候要多思考，多问问为什么，才能有去查看原理的一些问题。其次，面对自己不懂的问题，不要含糊的回答，大方的直截了当地说不懂就行了，不知道 &gt; 乱说。然后就是要调整好自己的心态，面对压力的表现也是考核的一部分。(然后吐槽一下我花了大量时间看React的东西然后一点没问。。)</p>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面面试官也比较随和，交流也很舒服。但是感觉说话不多，不过整个面试下来都是比较轻松的。</p>
<p>这一面关于技术的问的比较少，就问了一道leetcode上面的算法题。</p>
<p>寻找两个有序数组的中位数：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数。偶数需要将中间两个值除以二。</p>
<p>这道题我做过，在leetcode上是hard级别的题目，但是要求是O(log(n+m))的复杂度，我写了一个O(n+m)的。然后问我有没有更快的算法，有没有O(log(n+m))级别的实现。但这个复杂度的算法有点复杂，需要提前进行一些数学运算在结合二分查找来做优化，一时半会也没想出来，不过他也没有追究这个问题。</p>
<p>之后就问了项目相关，有没有什么项目可以给他看一下的，然后我就拿了重构的Us项目给他看(由于我已经没有一些权限了，所以只能看到家园圈子那一块)，然后问了问你做了哪些事情，怎么设计的之类的问题。这个就是结合项目和你当时做的一些方案去说了。(所以说项目很重要，项目经验很重要)</p>
<p>在之后就问问一下简历上写的用node做爬虫的，是怎么做的。然后我就说了一下具体的实现难点，比如异步、并发控制，代理ip池，缓存中间数据等等，然后问了我为什么做这个项目，就又说到了这个是拿去参加比赛的项目中的一部分。然后就问了问我比赛的流程，怎么比的，获奖了没有，小组几个人完成的之类。</p>
<p>在之后又问了问高考成绩，跟当时一本线比高了多少分什么的。再之后就谈了谈实习相关，比如能实习多久之类的</p>
<p>总得来说三面是最简单的，没有过多的技术谈话，整个过程基本上都是我在不停的说，然后也是三个面试中用时最短的了，面完结束后就让我等hr电话了。</p>
<h3 id="HR-这个不算面试，就是聊天"><a href="#HR-这个不算面试，就是聊天" class="headerlink" title="HR(这个不算面试，就是聊天)"></a>HR(这个不算面试，就是聊天)</h3><p>这个就直接跟HR在电话中交谈，大概花了十多分钟。</p>
<p>问的问题：</p>
<ol>
<li>家住哪</li>
<li>能实习多久</li>
<li>会去秋招吗</li>
<li>如果以后有更好的工作机会(腾讯阿里)，会去吗</li>
<li>对于北京觉不觉得太远了</li>
<li>毕业是考研还是工作呢</li>
<li>有什么想问的吗</li>
</ol>
<p>对于会不会去秋招我的回答是会去，会去尝试一下更好的公司面试是怎么样的，看看自己水平如何，但是还是留在头条实习。对于以后有更好的机会我老老实实回答的会去。然后对于北京我觉得还是有点远的，不过实习嘛，地点在我看来就没有那么重要。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说头条的面试效率很高，我提交简历一两个小时后就跟我联系约面试时间了，然后半个下午就完成了一二轮面试，第二天进行的第三面，每次面试持续时间一个小时左右。总之有几点建议：</p>
<ol>
<li>面试的话一定要刷面经</li>
<li>一定要对自己学的知识再去深入的了解一下</li>
<li>要去做算法题</li>
<li>遇到不会的不要慌了阵脚，要及时调整好心态</li>
<li>知之为知之，不知为不知</li>
<li>至少做一个拿得出手项目</li>
</ol>
<p>最后希望大家都能拿到自己心仪的offer。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2">牛客网前端面试总结</a></li>
<li><a href="https://www.xiaohuochai.cc/">小火柴的前端小站</a></li>
<li>面试官系列：<ol>
<li><a href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a">面试官系列(1): 如何实现深克隆</a></li>
<li><a href="https://juejin.im/post/5ac2fb886fb9a028b86e328c">面试官系列(2): Event Bus的实现</a></li>
<li><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b">面试官系列(3): 前端路由的实现</a></li>
<li><a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf">面试官系列(4): 基于Proxy 数据劫持的双向绑定优势所在</a></li>
<li><a href="https://juejin.im/post/5b16c0415188257d42153bac">面试官系列(5): 你为什么使用前端框架</a></li>
<li><a href="https://juejin.im/post/5c02142fe51d4511be77aad7">面试官系列(6): 写过『通用前端组件』吗?</a></li>
<li><a href="https://juejin.im/post/5c03b85ae51d450c740de19c">面试官系列(7): 聊一聊 Babel</a></li>
<li><a href="5bf8dab3f265da61590b55d4">面试官(8): React 强调的『不可变数据结构』怎么实现?</a></li>
</ol>
</li>
<li><a href="https://github.com/forthealllight/blog/issues">forthealllight’s blog</a></li>
<li><a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question">前端面试搜集</a></li>
<li><a href="https://www.cnblogs.com/chaoran/p/8891892.html">BAT前端开发面经 - 附解答</a></li>
</ol>
<p>以上均为参考链接，且都有一些回答的。然后感觉刷面经的主要作用就是让你知道你自己哪里不懂，然后再去通过其他方式来</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>串的模式匹配应用之文本编辑</title>
    <url>/2017/12/16/pattern-match/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对 C 串结构的学习总结</p>
<a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>老实说，串这一章学的并不好，感觉只了解相关概念，在我的印象中, 串就是代表字符串，而在 C/C++语言中，字符串又可用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> chs[<span class="number">100</span>]; <span class="comment">// 字符数组</span></span><br><span class="line"><span class="built_in">string</span> str; <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure>

<p>两种（简单）方法表示，结构上均与线性表无异，区别只在于串的数据对象被约束为字符集。但在操作上，串与线性表是存在较大差别的。 在线性表的基本操作中，大多以“单个元素”作为操作对象，例如查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等。 而在串的基本操作中，通常以“串的整体”作为操作对象，例如在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。 但如何实现一个串，如何实现一个符合情景的串是一个令我头疼的问题。如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。（这个非数值处理有点不太明白，串不都是字符类型吗？不是均为非数值吗？）</p>
<h2 id="串的表示方法"><a href="#串的表示方法" class="headerlink" title="串的表示方法"></a>串的表示方法</h2><blockquote>
<p>定长顺序存储表示</p>
</blockquote>
<p>类似线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列，给定一个预定义的大小，为每个定义的串变量分配一个固定长度的存储区，可以用如下代码描述：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[MAXSIZE + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>串的实际长度可以在预定义长度内随意，超过定义的长度就会被截断。在上面的代码中，我们设置了一个常量<code>MAXSIZE</code>，同时自定义了一个数据类型<code>sstring[]</code>，注意，我们定义的字符串预定义长度为<code>MAXSIZE + 1</code>，这是为了方便串操作，我们将串的长度存储在 0 号数据单元，当然，这也不是必须的，在 c 语言中，我们可以使用<code>strlen()</code>来获取<strong>字符数组</strong><code>char chs[]</code>的真实长度，用<code>str.length()</code>来获取字符串的长度。 这个为最简单也最常用的一种串的结构，也是我们这次实验需要用到的结构。接下来简要介绍一下另外两种串的表示方法（对于我来说不是很熟悉）</p>
<blockquote>
<p>堆分配存储表示</p>
</blockquote>
<p>对于第一种表示方法，会有一些问题：</p>
<ol>
<li>操作的时间复杂度基于串的长度，效率较低</li>
<li>在一些操作中出现串值序列的长度超过上界时，约定使用截尾法处理，也就是说会导致一些串值丢失的情况</li>
</ol>
<p>为了解决这些问题，我们采取<strong>不限制串的最大长度，而采用动态分配串值的存储空间</strong> 我们仍以一组地址连续的存储单元存放串值字符序列，但他们的存储空间是在程序执行过程中动态分配而得。在 C 语言中，存在一个称之为“堆”的自由存储区，并由 C 怨言的动态分配函数<code>malloc()</code>和<code>free()</code>来管理。利用<code>malloc()</code>来为每一个新产生的串分配一块实际船厂所需的存储空间。其代码表示如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch; <span class="comment">// 若是非空串，则按串长分配存储区，否则ch为 NULL</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 串长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更加的灵活，因此在串处理的应用程序中也经常被选用。</p>
<blockquote>
<p>串的块链存储表示</p>
</blockquote>
<p>既然线性表中有链式的表示方法，那么在串中也可以采用链表方式存储串值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHUNKSIZE = <span class="number">80</span>; <span class="comment">// 自定义大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Chunk *head, *tail; <span class="comment">// 头尾指针</span></span><br><span class="line">    <span class="keyword">int</span> curlen; <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;LString</span><br></pre></td></tr></table></figure>

<p>由代码很容易看出，一个块由数据域（字符数组）和指向下一个块的指针组成，同时<code>LString</code>表示的是字符串，其头指针指向其串首地址，还可以增设一个尾指针用来指向最后一个结点，并给出当前串的长度<code>curlen</code>，我们把这种串结构称作为<strong>块链结构</strong>，设置尾指针还有一个目的，<strong>是为了标语进行联结操作，但需要注意的是联结时需要处理第一个串尾的无效字符</strong>。 <strong>块链结构</strong>的串虽然对一些串操作比较方便，但不如前两种灵活，它占用内存大，且操作复杂，使用频率较少。</p>
<p>介绍完这三种表示方法，该进入我们今天的主题——<strong>文本编辑</strong></p>
<h2 id="串应用——文本编辑"><a href="#串应用——文本编辑" class="headerlink" title="串应用——文本编辑"></a>串应用——文本编辑</h2><p>想到大一上学期，C 语言的课程比较紧凑，于是对于课本后面的知识没有好好巩固，对于文件处理方面的知识非常模糊，于是先整理了一下 C++文件与流的一些知识要点。</p>
<p>到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 那么我们如何对文件进行输入和输出呢？这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： <code>ofstream</code> <strong>该数据类型表示输出文件流，用于创建文件并向文件写入信息。</strong> <code>ifstream</code> <strong>该数据类型表示输入文件流，用于从文件读取信息。</strong> <code>fstream</code> <strong>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</strong> 因此，要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <code>&lt;iostream&gt;</code> 和 <code>&lt;fstream&gt;</code>。</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<code>ofstream</code> 和 <code>fstream</code> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <code>ifstream</code> 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，open() 成员函数的第一参数<strong>指定要打开的文件的名称和位置</strong>，第二个参数<strong>定义文件被打开的模式</strong>。 <code>ios::app</code> <strong>追加模式。所有写入都追加到文件末尾。</strong> <code>ios::ate</code> <strong>文件打开后定位到文件末尾。</strong> <code>ios::in</code> <strong>打开文件用于读取。</strong> <code>ios::out</code> <strong>打开文件用于写入。</strong> <code>ios::trunc</code> <strong>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</strong> 可以把以上两种或两种以上的模式结合使用。例如，如果想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fstream  afile;</span><br><span class="line">afile.open(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>

<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 <code>close()</code> 函数的标准语法，<code>close()</code> 函数是 <code>fstream</code>、<code>ifstream</code> 和 <code>ofstream</code> 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 <code>ofstream</code> 或 <code>fstream</code> 对象，而不是 <code>cout</code> 对象。 ####读取文件 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <code>ifstream</code> 或 <code>fstream</code> 对象，而不是 <code>cin</code> 对象。</p>
<p>有了以上的知识，对于读写文件的话还是信手拈来的。接下来，我们来看看实验要求</p>
<ol>
<li>要求建立一个文本文件，每个单词子串不包含空格且不跨行，单词子串由字符序列构成，且区分大小写；</li>
<li>统计给定单词子串在文本文件中出现的总次数；</li>
<li>检索输出某个单词子串出现在文本中的行号、在该行中出现的次数以及位置。</li>
</ol>
<p>一个个来分析，对于第一个，不包含空格也就是不存在类似<code>hello world</code>这样的字符串，字符串不跨行意味着每一行只有一个字符串，区分大小写的话意义不大，因为读取的和比较的时候是肯定区分大小写的。所以，我们使用如下函数来创建一个文本文件并读入字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; // 文件流</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10000</span>; <span class="comment">// 预定义字符串最大长度</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize]; <span class="comment">// 自定义字符数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data; <span class="comment">// 声明一个sstring类型的变量，存储输入的字符，包含换行符以及空格</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 用于标记当前读入的字符在字符数组的位置</span></span><br><span class="line">    <span class="keyword">char</span> temp; <span class="comment">// 存储中间变量，读入当前字符值</span></span><br><span class="line"></span><br><span class="line">    ofstream outfile; <span class="comment">// 定义一个写入变量</span></span><br><span class="line">    outfile.open(<span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 执行打开文件方法，打开一个当前路径下的&quot;test.txt&quot;文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Write some strings to this file, if you want to stop, input a &#x27;#&#x27;: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((temp = getchar()) != <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 以#号结束输入</span></span><br><span class="line">            data[i++] = temp; <span class="comment">// 存入字符数组中</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次读入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 结束输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    getchar(); <span class="comment">// important 坑</span></span><br><span class="line">    outfile &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 将数据写入文件中</span></span><br><span class="line">    outfile.close(); <span class="comment">// 关闭对文件的访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，我们使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize];</span><br></pre></td></tr></table></figure>

<p>来定义一个字符数组类型而不是<code>unsigned char</code>，这么做的目的是为了后面的读取文件使格式保持一致，在后面会说到。 同时，在注释中标记<code>important</code>的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<p>为什么要在结束输入之后调用这个方法呢？原因在于：*<em>当我们输入#之后，字符数组剩余的部分的内容不确定，如果没有<code>getchar()</code>他将会得到一些乱码导致文件编码存在问题以及读取文件存在问题。我们使用<code>getchar()</code>来获取缓冲区的字符，避免将这些字符写入文件中去。(有待考证) 写入之后，我们就是需要读取文件的内容了。对于实验的要求，采用整行读取会较为方便，即使用<code>getline()</code>函数，读取是较为简单的，但是我们如何存储读取的数据呢？我们知道，读取的每一行的数据均为一个字符串，因此我们需要一个结构来存储每一个字符串。我第一反应就是字符串数组，这是在别的语言里非常常见的，但在 c 语言中，<code>char chs[]</code>只能存储字符串，无法使用它来存储多个字符串，所以，我想到了使用另一个类型 —— **string\</em>* 使用<code>string</code>，我们需要引入头文件 <code>#include &lt;string&gt;</code>，我们可以这样定义一个字符串数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> content[maxsize];</span><br><span class="line">...</span><br><span class="line">content[<span class="number">0</span>] = <span class="string">&quot;my world&quot;</span>;</span><br><span class="line">content[<span class="number">1</span>] = <span class="string">&quot;your name&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>因此，我们可以每读取一行，将该行的字符串存入字符串数组中去，同时，由于读取的内容几乎在每个函数内都需要使用，为了避免每次调用函数都需要传参的麻烦，我们将读取的内容存在全局的字符串数组内，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> content[maxsize]; <span class="comment">// 字符串数组，存储文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data; <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 存储当前字符串存入数组的下标</span></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>; <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">while</span> (infile.getline(data, maxsize)) &#123; <span class="comment">// 逐行读取</span></span><br><span class="line">        content[index++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    lineNumber = index; <span class="comment">// 内容的行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的 content 用于全局，所以我们无需穿参，在函数内直接对<code>content</code>进行修改。再设置了一个全局的变量 <code>lineNumber</code> 用于存储读取文件的行数，对后面的匹配要求做铺垫。 读写存储操作均完成了，我们来看下一个要求，需要统计子串在字符串出现的总次数，思路很简单，我们对每一行进行匹配，若匹配成功则计数器加一，同时要注意一行可能会有多个匹配的子串，所以一行需要进行多次匹配。 那么在统计次数之前，我们需要完成一个更重要的工作，如何进行匹配？也就是判断子串是否在主串内以及如何定位到子串在主串的位置，这样的操作我们通常称为<strong>模式匹配</strong>。 通过模式匹配，我们将返回子串的第一个字符在主串中的下标。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sstring sMain = <span class="string">&quot;abbbcbc&quot;</span>;</span><br><span class="line">sstring sChild = <span class="string">&quot;bc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>则子串在主串的位置为<code>1</code>，那么如何实现匹配呢？ 我们指定两个指针，一个指针 <code>i</code> 指向主串首个字符，一个指针 <code>j</code> 指向子串首个字符，逐个字符比较。当字符相等的时候， <code>i</code> 和 <code>j</code> 同时后移，匹配下一个字符；当字符不相等时， <code>j</code> 回到子串的首个字符的位置， <code>i</code> 则回溯到之前匹配到子串的第一个字符的位置的下一个位置。当 <code>j</code> 后移到子串之后的位置时，说明子串已经完全匹配，则此时 <code>i</code> 的指向为子串的最后一个字符在主串的位置的后一个位置。我们需要返回子串的位置，则需要找到匹配到的子串的首字符在主串中的位置，只需要将 <code>i</code> 后移子串长度个单位就可以了。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(sstring s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span> <span class="params">(<span class="built_in">string</span> s, sstring t, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回子串t在主串s中第pos个字符之后的位置。</span></span><br><span class="line">    <span class="comment">// 1 &lt;= pos &lt;= sLen</span></span><br><span class="line">    <span class="comment">// 匹配失败返回0</span></span><br><span class="line">    <span class="keyword">int</span> i = pos - <span class="number">1</span>, j = <span class="number">0</span>, sLen = s.length(), tLen = getLength(t);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 相等则主、子串指针均后移</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; <span class="comment">// 主串指针回溯</span></span><br><span class="line">            j = <span class="number">0</span>; <span class="comment">// 子串指针重新指向子串首字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == tLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - tLen + <span class="number">1</span>; <span class="comment">// 返回子串在主串的首位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没匹配到则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个函数 <code>getIndex()</code> 返回的是位置而不是下标，也就是是从 1 开始的，所以使用的时候要注意，它作为一个辅助函数，来实现我们两个主要功能的。 先来看计数功能，统计子串在主串中出现的总次数，在先前，我们已经将字符串存入了字符串数组，数组的每一个元素代表着每一行的字符串。因此我们需要便利这个字符串数组，对其每一个字符串进行匹配，得到最终的匹配个数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordCount</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring queryStr; <span class="comment">// 搜索的子串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 记录第几行</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入你要计数的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; queryStr;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lineNumber) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], queryStr, index) + <span class="number">1</span>; <span class="comment">// 多次匹配</span></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">// 匹配成功计数器加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++; <span class="comment">// 换行，对下一行进行匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，对于子串的定位，功能上感觉和计数有部分重合，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strFind</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring s;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入要定位的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNumber; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器，记录每一行子串出现的次数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], s, index) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;字符串 %s 在第 %d 行，第 %d 列.\n&quot;</span>, s, i + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在第%d行共出现了%d次\n&quot;</span>, i + <span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ol>
<li><p><code>using namespace std;</code> 的位置 我发现，这一句代码不能放在定义全局变量 <code>string</code> 的下面，如果在下面的话，将产生一个报错：</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">Error: unknown type name &#x27;string&#x27;; did you mean &#x27;std::string&#x27;?</span><br></pre></td></tr></table></figure>

<p> 意味着 string 是包含在命名空间 std 中的。</p>
</li>
<li><p> 何时使用 <code>getFileContent()</code> 这个函数的作用是读取指定文件内容，并存入全局的字符串数组中去。当第一次使用该程序时，指定文件还未创建，因此读取得到的是空字符串，当我们执行完写入操作后，需要再次执行该函数将内容存入全局字符串数组。因此，需要在刚进入主函数时调用以及完成写入操作之后调用一次。</p>
</li>
</ol>
<h2 id="总结和改进"><a href="#总结和改进" class="headerlink" title="总结和改进"></a>总结和改进</h2><p>关于这次实验，我更改了实验内容所提供的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> sstring[maxsize];</span><br></pre></td></tr></table></figure>

<p>而使用了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize];</span><br></pre></td></tr></table></figure>

<p>只是为了函数的参数格式化，但其中区别未深入了解。同时，为了方便加入了<code>string</code>类型的数据，并不是很好的完全符合实验，而且对于引用参数和指针参数的理解还有些偏差，导致调试过程中出现许多的问题，需要自己仔细的再进行学习。 对于函数 <code>strfind()</code> 和 <code>wordCount()</code> ，这两个函数有一些公共的部分，应该是可以把它独立出来作为一个单独的函数来调用，将会简洁许多。</p>
<h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">string</span> content[maxsize]; <span class="comment">// 字符串数组，存储文件内容</span></span><br><span class="line"><span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordCount</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strFind</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFileContent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span> <span class="params">(<span class="built_in">string</span> s, sstring t, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(sstring s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> t = <span class="literal">true</span>;</span><br><span class="line">    getFileContent();</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (choose()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                createTextFile();</span><br><span class="line">                getFileContent(); <span class="comment">// 创建完之后需要重新调用一次content</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                wordCount();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                strFind();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                t = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功退出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Write some strings to this file, if you want to stop, input a &#x27;#&#x27;: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        temp = getchar();</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            data[i++] = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    outfile &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    outfile.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span> <span class="params">()</span> </span>&#123; <span class="comment">// 菜单函数</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t文本编辑系统菜单🈳️&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t1. 创建文本文件&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t2. 文件单词计数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t3. 文件单词定位&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t0. exit&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的选择: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data; <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 存储当前字符串存入数组的下标</span></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>; <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">while</span> (infile.getline(data, maxsize)) &#123; <span class="comment">// 逐行读取</span></span><br><span class="line">        content[index++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    lineNumber = index; <span class="comment">// 内容的行数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span> <span class="params">(<span class="built_in">string</span> s, sstring t, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回子串t在主串s中第pos个字符之后的位置。</span></span><br><span class="line">    <span class="comment">// 1 &lt;= pos &lt;= sLen</span></span><br><span class="line">    <span class="comment">// 匹配失败返回0</span></span><br><span class="line">    <span class="keyword">int</span> i = pos - <span class="number">1</span>, j = <span class="number">0</span>, sLen = s.length(), tLen = getLength(t);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 相等则主、子串指针均后移</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; <span class="comment">// 主串指针回溯</span></span><br><span class="line">            j = <span class="number">0</span>; <span class="comment">// 子串指针重新指向子串首字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == tLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - tLen + <span class="number">1</span>; <span class="comment">// 返回子串在主串的首位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没匹配到则返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(sstring s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordCount</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring queryStr; <span class="comment">// 搜索的子串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 记录第几行</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入你要计数的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; queryStr;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lineNumber) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], queryStr, index) + <span class="number">1</span>; <span class="comment">// 多次匹配</span></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">// 匹配成功计数器加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++; <span class="comment">// 换行，对下一行进行匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strFind</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring s;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入要定位的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNumber; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器，记录每一行子串出现的次数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], s, index) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;字符串 %s 在第 %d 行，第 %d 列.\n&quot;</span>, s, i + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在第%d行共出现了%d次\n&quot;</span>, i + <span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于栈结构的中缀表达式求值</title>
    <url>/2017/12/16/stack-calc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于中缀表达式的 C++实现和原理介绍</p>
<a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>栈这个东西，说简单也简单，就是一种数据结构，只是与顺序表，链表什么的不同，它遵循的是<strong>LIFO(后进先出)原则</strong>，阿这不是很简单么，只要时刻记住这一点就好了，<strong>只能从结构的一端进入和同一端出来</strong>就好了，这两个操作分别称为<strong>入栈</strong>和<strong>出栈</strong>。可以把它比喻成一筒可比克薯片，它是只有一边有盖子，称之为栈顶，它有一个金属的底部，防止薯片从底下漏出来了，称之为栈底。如果底部破了，薯片从底部漏了出来，称之为<strong>栈下溢</strong>；如果薯片装的过满了从顶部溢出来掉地上了，称之为<strong>栈上溢</strong>。关于这两个概念应该很好理解，但是这不是今天的重点，暂且不理它。 关于栈的概念应该大致清楚了，因为标题的缘故我再稍稍提一下<strong>队列</strong>。队列很好理解，从字面意思上我们就好理解了，就像排队一样，比如坐火车前去自动取票机取票，你得等你前面的人取完票你才能取票，当然队列里的数据元素都是遵纪守法的好公民，不存在插队现象（特意去搜了一下，栈应该是不存在自身插队的问题的），这就是<strong>FIFO(先进先出)原则</strong>，队列在遵循这个原则产生了多种变种比如<strong>双端队列、链队列、循环队列等</strong>。诶又扯远了，现在就正式开始吧。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本次应用实例是一个 <code>基于栈结构</code>的中缀表达式求值的一个程序，先不提实验本身，先搞清楚什么是<strong>中缀表达式</strong>，以及<strong>前缀和后缀表达式</strong>才是当务之急。 在表达式表示中，我们依照运算符相对运算数的位置不同，把这三个表达式分为：</p>
<ul>
<li><strong>中缀表达式</strong></li>
<li><strong>前缀表达式（波兰式）</strong></li>
<li><strong>后缀表达式（逆波兰式）</strong></li>
</ul>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="number">3</span> + <span class="number">4</span>) * <span class="number">5</span> - <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>概念：中缀表达式的运算符以中缀形式处于运算数的中间。</p>
<h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><p>举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- * + <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>概念：前缀表达式的运算符位于运算数之前。</p>
<h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> + <span class="number">5</span> * <span class="number">6</span> -</span><br></pre></td></tr></table></figure>

<p>概念：后缀表达式的运算符位于运算数之间。 对于<strong>中缀表达式</strong>，不用过多的解释，这个是我们日常使用的表达方式，一眼就能看出答案为 29。但是对于不了解的人来说，后面两个可能就不太看得懂了，其实，根据概念我们就可以大概猜出来了。由于加减乘除都是<strong>双运算数运算符</strong>，我们对于一个运算符要找出两个运算数与之搭配。先来看更简单易懂的<strong>后缀表达式（逆波兰式）</strong>求值，始终记住<strong>双运算数运算符</strong>。</p>
<ol>
<li>从左到右取出第一个运算符前两个运算数 <code>3 4</code></li>
<li>取出该运算符 <code>+</code></li>
<li>将两个运算数和运算符按照中缀表达式结合 <code>3 + 4</code></li>
<li>将使用了的运算符和运算数去除，将得到的结果放回原表达式 <code>7 5 * 6 -</code></li>
<li>重复 1 ～ 4，扫描的起始位置更改为之前运算符<code>+</code>所在位置</li>
<li>直到表达式中运算符被使用完毕，最后的到的运算数就是最终的值 <code>29</code></li>
</ol>
<p>接下来看稍微复杂一点的<strong>前缀表达式（波兰式）</strong>，由于部分复杂，我将采用图示法。</p>
<ol>
<li><p>表达式从右向左扫描，遇到数字则把数字压入栈中，直到遇到非数字的运算符 <code>+</code>, 得到一个数字栈 <code>3 4 5 6</code></p>
<p><img src="http://wingsico.org/images/1.png" alt="示意图1-w400"></p>
</li>
<li><p>将栈顶元素出栈作为第一个运算数 a <code>a = 3</code>, 再执行一次出栈操作拿到栈顶元素作为第二个运算数 b <code>b = 4</code>，用～代表之前拿到的第一个运算符<code>+</code>，执行式子 <code>a ~ b = 3 + 4 = 7</code><br><img src="http://wingsico.org/images/2.png" alt="示意图2-w400"></p>
</li>
<li><p>将运算结果<code>7</code>再次压栈，将～ <code>+</code>丢弃，从之前<code>+</code>所在的位置继续向左扫描</p>
<p><img src="http://wingsico.org/images/3.png" alt="示意图3-w400"></p>
</li>
<li><p>重复 1-3 步骤，直到扫描到最左边无运算符，停止运算，最后栈中剩下的数字就是求值的最后结果 <code>29</code></p>
</li>
</ol>
<p>通过我以上的描述，应该可以较明确的解释前缀、中缀、后缀表达式如何计算它们，下面给出一个更加复杂的前中后缀表达式，应该也很好计算。</p>
<blockquote>
<p>中缀：1 + ( ( 2 + 3 ) × 4 ) - 5<br>前缀：- + 1 × + 2 3 4 5<br>后缀：1 2 3 + 4 × + 5 -</p>
</blockquote>
<p>答案均为 <code>16</code> 经过上面的解释，不难看出，中缀和后缀表达式是比较好被计算机来解析并运算的，虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。 <strong>但是！</strong>我们先把转换表达式的方法放到最后来说，我们这里使用另一种简单直观、广为使用的方法来求解中缀表达式——<strong>算符优先算法</strong></p>
<h2 id="算符优先算法"><a href="#算符优先算法" class="headerlink" title="算符优先算法"></a>算符优先算法</h2><p>什么是算符优先算法呢？简单来说：</p>
<blockquote>
<p>算符优先算法是根据运算优先关系的规定来实现对表达式的编译或解释执行的</p>
</blockquote>
<p>举个例子，我们从小学就学过了四则运算的规则：</p>
<ol>
<li>先乘除后加减</li>
<li>从左算到右</li>
<li>先算括号内再算括号外</li>
</ol>
<p>所以对于以下式子，我们可以很快给出计算顺序然后得出正确的答案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 + 2 * 3 - 10 / 5</span><br><span class="line"></span><br><span class="line">(1) 4 + 2 * 3 - 10 / 5</span><br><span class="line">(2) 2 * 3 = 6</span><br><span class="line">(3) 4 + 6 - 10 / 5</span><br><span class="line">(4) 10 - 10 / 5</span><br><span class="line">(5) 10 / 5 = 2</span><br><span class="line">(6) 10 - 2</span><br><span class="line">(7) 8</span><br></pre></td></tr></table></figure>

<p>为了下面更好的理解一些术语词，先放上一段术语介绍：</p>
<p><strong>任何一个表达式都是由操作数、运算符和界限符组成的，我们称它们为单词。一般地，操作数既可以是常数也可以是被说明为变量或常量标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有左右括号和表达式结束符等等。</strong> <strong>我们把运算符和界限符统称为算符，它们构成的集合命名为 OP</strong></p>
<p>容易看出，像 <code>+ - * /</code> 为运算符， <code># ( )</code> 为界限符**(#为表达式结束符)**，则 OP 为这样一个集合 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;]</code></p>
<p>那么我们如何让计算机在运算中判断两个相继出现的算符 ß1 和 ß2 之间的优先关系呢？</p>
<p>通过<strong>算符优先级表</strong>！</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/zabery/WindowsLiveWriter/8cb80e0d0c2b_11913/untitled.png" alt="运算优先级表"></p>
<p>PS: 纵轴符号为运算符 ß1，横轴符号为运算符 ß2 ß1 代表<strong>运算符栈顶元素</strong>，ß2 代表<strong>输入的算符</strong> <code>&gt;</code> 代表 ß1 优先级高于 ß2 <code>=</code> 代表 ß1 优先级等于 ß2 <code>&lt;</code> 代表 ß1 优先级低于 ß2</p>
<p>可以看到，表中有内容为空的单元格，这是因为表达式中不允许他们相继出现，一旦有这种情况，我们可以把它当作出现了错误的表达式，在下面的讨论中我们假定所输入的表达式不会出现语法错误，关于这个表的具体使用方法，我们在下面的讨论中会提到。</p>
<p>磨刀不误砍柴功，在我们正式开始编码之前，举出一些问题并想到解决办法会让我们的编程思路更加清晰。</p>
<ul>
<li>如何读取输入的中缀表达式</li>
<li>如何实现算符优先算法<ul>
<li>如何寄存运算数和运算符</li>
<li>如何使用算符优先级表判断运算符优先级</li>
<li>如何实现多位数字和小数的存储</li>
<li>如何判断输入的字符是否为数字</li>
<li>…</li>
</ul>
</li>
</ul>
<p>有一些问题需要随着我们深入编码才会逐渐浮现出来，所以在下面再提出并解决吧～现在，就来正式开始编码之旅</p>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p>先来解决上面已经列出来的问题吧！</p>
<blockquote>
<p>如何读取输入的中缀表达式？</p>
</blockquote>
<p>针对这个问题，书上给出了一种方式，使用<code>getchar()</code>，一开始我也确实是使用这种方法的，但后面暴露了一些问题：</p>
<ul>
<li>每次只能读取一位字符，比如输入 10 只能分开读取为 1，0，导致难以判断是多位数字还是个位数字</li>
<li>还有一个问题到后面再提，这里先<code>mark</code>一下</li>
</ul>
<p>于是我放弃了使用<code>getchar()</code>，决定使用一个字符数组来存储我所输入的中缀表达式，初始代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> express[STACK_INIT_SIZE]; <span class="comment">// 存储中缀表达式</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// 存储运算结果</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入中缀运算式: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; express; <span class="comment">// 直接用cin读取中缀表达式</span></span><br><span class="line">    result = MidExpression_Eval(express); <span class="comment">// 这是定义的解析中缀表达式的函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出等式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>STACK_INIT_SIZE</code>是我一开始在程序头部定义的一个常数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_INIT_SIZE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>用途除了<strong>初始化存储中缀表达式的数组的内存空间</strong>、还用于<strong>初始化栈</strong>，会在下面说到。 针对这个问题，以上代码其实很明显的暴露了一些问题：</p>
<ul>
<li>运算中免不了有除法，所以会出现有小数的情况</li>
<li>每次输入运算符都要自己手动在末尾加入运算结束符<code>#</code>，很麻烦</li>
<li>在输出等式的时候，会将运算结束符也输出，即会出现<code>1+3*2/5#=2.2</code>的情况</li>
</ul>
<p>解决方法很简单：</p>
<ol>
<li><p> <code>int result</code> 写成 <code>float result</code>，实在不放心还能写成 <code>double result</code></p>
</li>
<li><p>在输入的时候不输入 <code>#</code>，在代码中将 <code>#</code> 添加到字符数组的最后面</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">express[<span class="built_in">strlen</span>(express)] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 一定要放在下一句的前面</span></span><br><span class="line">result = MidExpression_Eval(express);</span><br></pre></td></tr></table></figure>

<p> <code>strlen()</code> 的功能就是返回数组内实际所占的长度，不记录<code>\0</code>，这里 就不过多的描述了。 举个例子就明白了：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> test[<span class="number">100</span>] = &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(test); <span class="comment">// 5</span></span><br><span class="line">test[<span class="built_in">strlen</span>(test)] = <span class="string">&#x27;#&#x27;</span> <span class="comment">// 相当于 test[5] = &#x27;#&#x27;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test; <span class="comment">// 2+3*4#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上面的方法，我们免去了输入中缀表达式的结束符<code>#</code>，但是我们实际上<code>express</code>的内容仍带有 <code>#</code>，所以，我们在输出等式之前，可以先把结束符去除:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = MidExpression_Eval(express);</span><br><span class="line">express[<span class="built_in">strlen</span>(express) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 必须放在上面那个式子的后面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p> 解释一下，由于在解决 2 里面将 <code>#</code> 加了 express 内，会使<code>expresss</code> 的长度增加 1，也就是<code>strlen(express)</code> 的值会比原来大 1，因此 <code>#</code> 的位置就在 <code>express[strlen(express) - 1]</code>，把这个位置的字符替换成 <code>\0</code>，因为 <code>cout</code> 在输出字符数组的时候会截止于 <code>\0</code></p>
</li>
</ol>
<p>三个问题都解决了，最后代码清单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> express[STACK_INIT_SIZE]; <span class="comment">// 存储中缀表达式</span></span><br><span class="line">    <span class="keyword">float</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入中缀运算式: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; express;</span><br><span class="line">    express[<span class="built_in">strlen</span>(express)] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    result = MidExpression_Eval(express);</span><br><span class="line">    express[<span class="built_in">strlen</span>(express) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样真的好了吗? (😏 笑) 其实上面还有一个问题，暂时还没有暴露出来。在这里就提前说了吧！ 注意到我们的中缀表达式字符数组只是定义了但没有初始化，一开始我也觉得应该没有什么问题，但直到我把所有程序完成执行输出的时候这个问题才暴露了出来： <code>cout &lt;&lt; express</code> 并没有在预期的位置(设置’\0’的地方)停止输出，而是在后面的一些的位置停止，导致输出了一些乱码。这是为什么呢？ 在数组初始化之前，数组里的每一个数据单元的内容都是不确定的，如果我们不进行初始化的话，就会导致数组未赋值的区域内容不确定，就有可能出现上述情况，因此，我们做出一个改进，即初始化<code>express</code>数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> express[STACK_INIT_SIZE] = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就解决了不在预期停止输出的 bug。 好了，接下去下一个大问题。</p>
<h3 id="如何实现算符优先算法"><a href="#如何实现算符优先算法" class="headerlink" title="如何实现算符优先算法"></a>如何实现算符优先算法</h3><p><strong>算法思想</strong>：</p>
<ol>
<li>首先置运算数栈为空栈，表达式起始符 <code>#</code> 作为运算符栈的栈底元素</li>
<li>依次读入表达式中的每一个字符，若是运算数则进运算数栈，若是运算符则和运算符栈中的栈顶运算符比较优先级后作相应操作，直至整个表达式求值完毕（即运算符栈的栈顶元素和当前读入的字符均为 <code>#</code></li>
</ol>
<h3 id="如何寄存运算符和运算数"><a href="#如何寄存运算符和运算数" class="headerlink" title="如何寄存运算符和运算数"></a>如何寄存运算符和运算数</h3><p>我的自我对算符优先的认识（没有具体考证，待指正。）： <strong>算符优先算法的求解过程跟后缀表达式求值过程十分相似，均是使用 <em>压栈_， _入栈_， _栈外运算</em> 等操作完成的。</strong> 因此，我们需要使用 <strong>栈</strong> 来存储我们的<strong>运算数</strong>和<strong>运算符</strong>，因此我们需要声明、定义和初始化栈，版本 1 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Sqstack</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base, *top; <span class="comment">// 栈顶和栈底指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize; <span class="comment">// 栈的内存大小</span></span><br><span class="line">&#125; Sqstack0, Sqstack1; <span class="comment">// 运算数栈1 ／ 运算符栈0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在某个函数内</span></span><br><span class="line">Sqstack0 OPTR; <span class="comment">// 运算符栈</span></span><br><span class="line">Sqstack1 OPND; <span class="comment">// 运算数栈</span></span><br></pre></td></tr></table></figure>

<p>只声明了一个栈类型，但定义了两个结构体变量，分别用来存储运算数和运算符，这样做有一个好处：</p>
<ul>
<li>只需要写一个初始化栈、入栈、出栈、获取栈顶元素函数</li>
</ul>
<p>但是相比于它所带来的缺点，这个优点可以忽略了：</p>
<ul>
<li>运算符和运算数都用同一个类型的栈，其内部的指针均为字符类型，对于运算数会产生许多麻烦的事情，比如：<ul>
<li>对于多位数字，无法存入数字类型，且作为字符也只能一个个存，且转换成数字很麻烦</li>
<li>从运算数数栈中取出的是字符，无法直接参与运算</li>
</ul>
</li>
</ul>
<p>解决的话可以使用两个不同的栈分别存储运算数和运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算符栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算数栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack1;</span><br></pre></td></tr></table></figure>

<p>上面对于不同的栈指定了不同的指针类型，但运算数栈的指针类型真的正确吗？想一想看，这个栈是用来寄存运算数的，而在运算过程中可能会产生浮点类型的数字，因此我们要改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算数栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack1;</span><br></pre></td></tr></table></figure>

<h3 id="如何判断一个字符是否为数字"><a href="#如何判断一个字符是否为数字" class="headerlink" title="如何判断一个字符是否为数字"></a>如何判断一个字符是否为数字</h3><p>答: ASCII 码 众所周知，字符在内部是以 <code>ASCII码</code> 来存储的，数字 0 ～ 9 都是使用连续的 <code>ASCII码</code> 表示的，且有一个更重要的是，<strong>字符之间是可以比较大小的，比较的就是 <code>ASCII码</code> 的大小</strong>，因此，我们可以据此实现判断一个字符是否为数字的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>); <span class="comment">// 是数字返回 true，不是则返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现多位数字以及小数的存储"><a href="#如何实现多位数字以及小数的存储" class="headerlink" title="如何实现多位数字以及小数的存储"></a>如何实现多位数字以及小数的存储</h3><p>来看一个式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> + <span class="number">12</span> * <span class="number">3</span> / <span class="number">9</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>按照我们的算法思想，首先先使用上面写的 <code>isNumber(char c)</code> 函数，判断该字符是否为一个数字，如果是，我们需要先把它转换成真正的数字，比如说第一个遇到了字符 <code>&#39;6&#39;</code>，我们可以这样把它转换成数字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = c - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// num 为 6</span></span><br></pre></td></tr></table></figure>

<p>记住，字符也是可以进行运算的（用 ASCII 码），查 <code>ASCII码表</code> 就可以知道，字符 <code>&#39;6&#39;</code> 的 <code>ASCII码</code> 为 64，<code>&#39;0&#39;</code> 的 <code>ASCII码</code> 为 48，则两个字符相减刚好为数字 <code>6</code>， 这样就将字符转换成了数字。 但是，当我们遇到 <code>12</code> 的时候又会出现什么问题呢，<code>12</code> 会被拆分成 <code>&#39;1&#39;, &#39;2&#39;</code>，如果我们不经过任何处理就压入运算数栈的话是会出问题的，那么该如何解决呢？代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">theChar = express[i]; <span class="comment">// 拿到表达式的第一个值</span></span><br><span class="line"><span class="keyword">while</span> (theChar != <span class="string">&#x27;#&#x27;</span> || GetTop(Op_char) != <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 判断表达式是否结束</span></span><br><span class="line">    <span class="keyword">char</span> numbers[<span class="number">20</span>]; <span class="comment">// 用于存储多位数字</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度</span></span><br><span class="line">    <span class="keyword">while</span> (isNumber(theChar)) &#123; <span class="comment">// 若是数字，则循环读取</span></span><br><span class="line">        numbers[j] = theChar;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        theChar = express[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈</span></span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">            sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k); <span class="comment">// 将字符转换成对应的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        Push1(Op_float, sum);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123; ... &#125;; <span class="comment">// 若不是数字则执行else里的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于除了处理多位数字的代码，上面都有详细的注释，这里着重解释多位数字的存储。 首先我们定义了字符数组，分配了 20 个内存单元，因为我们读入的数字不管是 <code>int</code>类型还是 <code>float</code> 类型进行四则运算一般不超过这个长度；同时，使用一个变量 <code>j</code> 来存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度，还能通过判断是否为 0 来辨别是运算数还是运算符。 若扫描到某一位为数字，不会直接将其压入运算符栈中，而是会继续获取下一位，直到获取到非数字时，<code>while</code> 才会跳出循环，进行数字位数(<code>j</code>)的判断。若是多位数字，则循环遍历存储着多位数字的数组 <code>numbers[]</code>，将其转换成真正的数字。 <code>for</code> 循环里面的那句语句如何理解呢？举个例子，假设：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> numbers[<span class="number">20</span>] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这是一个三位数字，值为<code>123</code>，那么如何根据其下标转换成数字呢？ 我们上面提到了如何将单个字符转换成单个数字，所以 <code>numbers[k] - &#39;0&#39;</code>就很好理解，<code>pow()</code> 函数是一个求次方的函数， <code>pow(10, 2)</code> 是求 10 的二次方，观察我假设的这个字符数组，我们可以获得三个信息：</p>
<ol>
<li>长度<code>j</code>为 3</li>
<li>对应下标<code>k</code>为 0, 1, 2</li>
<li>值为 <code>123</code></li>
</ol>
<p>其次，<code>123</code> 可以拆分成 <code>1 * 10^2 + 2 * 10^1 + 3 * 10^0</code>，所以答案一目了然，<code>10</code> 的幂可以由公式 <code>j - k - 1</code>（数组长度 - 当前数字字符下标 - 1）求出， 所以转换公式为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k)</span><br></pre></td></tr></table></figure>

<p>运算结束后，将累加得到的数字 <code>sum</code> 压入运算数栈，大功告成。 且慢，如果数字是小数怎么办？同样的思路，我们来将之前的代码改进一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">theChar = express[i]; <span class="comment">// 拿到表达式的第一个值</span></span><br><span class="line"><span class="keyword">while</span> (theChar != <span class="string">&#x27;#&#x27;</span> || GetTop(Op_char) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> numbers[<span class="number">10</span>]; <span class="comment">// 用于存储多位数字</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度</span></span><br><span class="line">    <span class="keyword">while</span> (isNumber(theChar) || theChar == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 若是数字或小数点，则循环读取</span></span><br><span class="line">        numbers[j] = theChar;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        theChar = express[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈</span></span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dot = getIndex(numbers, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 若无小数点则返回-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[k] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dot != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; dot) &#123;</span><br><span class="line">                    sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k - dot - <span class="number">1</span>); <span class="comment">// 将字符转换成对应的多位数字</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; dot) &#123; <span class="comment">// 若没有小数点，这个块不执行</span></span><br><span class="line">                    sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, dot - k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Push1(Op_float, sum);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">// 若不是数字则执行else里的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小数转换的思路就不多说了，和上面是一样的，用<strong>小数点所在的位置</strong>减去<strong>小数点后面的数字的位置</strong>得到的就是其<code>10</code>的幂的值。 但是，这里面还是有一些要小心的陷阱：</p>
<ul>
<li><code>j</code> 会因为含有小数点而增加长度，因此不能再使用 <code>j - 1 - k</code> 来确定整数部分乘以<code>10</code>的幂的值了, 应该将长度<code>j</code>减去小数点占的一个元素再减去小数点所在的下标<code>dot</code>。</li>
<li>区分小数点前后的转换规则，若 <code>k &lt; dot</code> 执行整数部分转换， 若 <code>k &gt; dot</code> 执行小数部分转换</li>
</ul>
<p>除此之外，里面增加了一个新的函数 <code>getIndex(numbers, &#39;.&#39;)</code>，是为了寻找小数点，找到了则返回小数点的下标，没有找到则返回 <code>-1</code>，根据下标是否等于 <code>-1</code> 判断是否是一个小数。来看这个函数的内部实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ops[], <span class="keyword">char</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == ops[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，这个问题也解决了，下面解决最让人疑惑的部分。</p>
<h3 id="如何使用算符优先级表判断运算符优先级"><a href="#如何使用算符优先级表判断运算符优先级" class="headerlink" title="如何使用算符优先级表判断运算符优先级"></a>如何使用算符优先级表判断运算符优先级</h3><p>算符优先级表我之前已经给出了，对于这样一个表，第一反应就是将它转换成二维数组，行代表输入的字符，列代表运算符栈顶元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// +</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// -</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// *</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// /</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;, <span class="comment">// (</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// )</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;=&#x27;</span>&#125;  <span class="comment">// #</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于这张表，我们需要做什么呢，在上面介绍这张表的时候，已经给出了一些关于 <code>&#39;&gt;&#39;, &#39;=&#39;, &#39;&lt;&#39;</code> 的具体含义，我们要做的就是根据<strong>输入的字符</strong>和<strong>运算符栈顶元素</strong>来从这张表中获取它们的优先级比较。 <strong>具体做法：</strong> 我们先创建一个运算符全集数组，用来对应优先级表的第一行和第一列的元素符元素（看之前的那张图）:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与比较符号优先级二维数组对应的操作符全集</span></span><br><span class="line"><span class="keyword">char</span> OP[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>有了这个，我们只需要找出<strong>输入的字符在这个数组中对应的下标 <code>i</code>**以及</strong>运算符栈顶元素在这个数组中对应的下标 <code>j</code><strong>，就可以通过 <code>priority[i][j]</code> 来获取 **运算符栈顶元素</strong> 和 <strong>输入的算符</strong> 之间的优先关系。用一个十分精简的函数 <code>Precede</code> 实现获取其优先关系:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> top, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// top 为运算符栈顶元素，c为输入的算符</span></span><br><span class="line">    <span class="keyword">return</span> priority[getIndex(OP, top)][getIndex(OP, c)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用了 <code>getIndex()</code> 辅助函数。 这个函数我们有三个可能的返回值：</p>
<ul>
<li><p><code>&lt;</code> 栈顶元素优先级低，将输入的算符压入运算符栈，因为栈的<code>LIFO原则</code>，越靠近栈顶的元素会有更高的优先级去进行运算，之后继续读取下一个字符。</p>
</li>
<li><p><code>=</code> 优先级相等，除了 <code>&#39;#&#39;</code> 与 <code>&#39;#&#39;</code>之间，就只有 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code>了，但是 <code>&#39;#&#39;</code> 是不可能出现在这一层函数的，它会在最外部的 <code>while</code> 循环中判断。所以这里的作用就是将运算符栈处于栈顶位置的 <code>&#39;(&#39;</code>脱去，并读取下一个字符，以便其他算符的运算</p>
</li>
<li><p>‘&gt;’ 栈顶元素优先级高，将优先处理栈顶元素：将运算符栈顶元素取出，同时取出两次运算数栈顶元素，将其组合成中缀表达式进行运算，将运算结果再重新压入运算数栈内，达到优先运算的预期要求<strong>（此时无需读取下一个字符，因为输入的字符还未使用）</strong>。</p>
</li>
</ul>
<p>实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (Precede(GetTop(Op_char), theChar)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="comment">// 栈顶元素优先级比此时的取值更低</span></span><br><span class="line">        Push(Op_char, theChar); <span class="comment">// 压入运算符栈</span></span><br><span class="line">        theChar = express[++i]; <span class="comment">// 使读取的位置后移，并取到下一个字符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">        <span class="keyword">char</span> x;</span><br><span class="line">        Pop(Op_char, x); <span class="comment">// 脱括号并读取下一个字符</span></span><br><span class="line">        theChar = express[++i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: <span class="comment">// 出栈并将运算结果入栈</span></span><br><span class="line">        <span class="keyword">char</span> theta;</span><br><span class="line">        <span class="keyword">float</span> a, b;</span><br><span class="line">        Pop(Op_char, theta);</span><br><span class="line">        Pop1(Op_float, b);</span><br><span class="line">        Pop1(Op_float, a);</span><br><span class="line">        Push1(Op_float, Operate(a, theta, b));</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>theChar</code> 来用保存当前读取的字符，<code>Op_char</code> 是定义并经过初始化的运算符栈， <code>Op_float</code> 是定义并经过初始化的运算数栈，<code>Push</code> 和 <code>Pop</code> 是对<strong>运算符栈</strong>的<strong>入栈</strong>和<strong>出栈</strong>， <code>Push1</code> 和 <code>Pop1</code> 是对<strong>运算数栈</strong>的<strong>入栈</strong>和<strong>出栈</strong>。它们对应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SqStack Op_char; <span class="comment">// 声明运算符栈</span></span><br><span class="line">SqStack1 Op_float; <span class="comment">// 声明运算数栈</span></span><br><span class="line"><span class="keyword">char</span> theChar; <span class="comment">// 记录目前读取表达式的字符</span></span><br><span class="line"></span><br><span class="line">InitStack(Op_char); <span class="comment">// 初始化运算符栈</span></span><br><span class="line">Push(Op_char, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 将最低优先级的&#x27;#&#x27;起始符压入操作数栈</span></span><br><span class="line"></span><br><span class="line">InitStack1(Op_float); <span class="comment">// 初始化运算数栈</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> e)</span> </span>&#123; <span class="comment">// 将运算符压入运算符栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算符栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack1</span><span class="params">(SqStack1 &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">float</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> e)</span> </span>&#123; <span class="comment">// 将运算数压入运算数栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">float</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算数栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这上面的代码都是对栈的基本操作，就不详细解释了。 除此之外，之前的代码里还有一个 <code>Operate()</code> 函数，其作用就是实现双操作符的运算的，返回的是运算的结果，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operate</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> x, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result = a + b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result = a * b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result = a - b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            result = a / b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于代码简单，没有什么技术含量，也不详细解释了。 = 至此，我们已经把提出的所有的问题解决了，下面附上源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 定义栈类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算符栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算数栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义所使用的常量集</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_INIT_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_INCREMENT = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/* 用于比较符号优先级的全局二维数组 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// +</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// -</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// *</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// /</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;, <span class="comment">// (</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// )</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;=&#x27;</span>&#125;  <span class="comment">// #</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 与比较符号优先级二维数组对应的操作符全集</span></span><br><span class="line"><span class="keyword">char</span> OP[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数预定义</span></span><br><span class="line"><span class="comment">// 操作结果：初始化运算符栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：得到运算符栈的栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算符栈进行压栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算符栈进行出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：初始化运算数栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack1</span><span class="params">(SqStack1 &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：得到运算数栈的栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTop1</span><span class="params">(SqStack1 &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算数栈进行压栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算数栈进行出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：判断一个字符是否是数字</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：计算中缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MidExpression_Eval</span><span class="params">(<span class="keyword">char</span> Express[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：计算表达式axb，并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operate</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> x, <span class="keyword">float</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：获取操作符在全集操作符中的位置，并返回下标，此函数为辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ops[], <span class="keyword">char</span> e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> top, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 操作结果：获取算符优先级关系，并返回具体优先级符号，如&#x27;&lt;&#x27;,&#x27;&gt;&#x27;等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> express[STACK_INIT_SIZE] = &#123;&#125;; <span class="comment">// 存储中缀表达式</span></span><br><span class="line">    <span class="keyword">float</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入中缀运算式: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; express;</span><br><span class="line">    express[<span class="built_in">strlen</span>(express)] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    result = MidExpression_Eval(express);</span><br><span class="line">    express[<span class="built_in">strlen</span>(express) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;s)</span> </span>&#123; <span class="comment">// 获取运算符栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(s.top - <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> e)</span> </span>&#123; <span class="comment">// 将运算符压入运算符栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算符栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack1</span><span class="params">(SqStack1 &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">float</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTop1</span><span class="params">(SqStack1 &amp;s)</span> </span>&#123; <span class="comment">// 获取运算数栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(s.top - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> e)</span> </span>&#123; <span class="comment">// 将运算数压入运算数栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">float</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算数栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operate</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> x, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result = a + b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result = a * b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result = a - b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            result = a / b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ops[], <span class="keyword">char</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == ops[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> top, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority[getIndex(OP, top)][getIndex(OP, c)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MidExpression_Eval</span><span class="params">(<span class="keyword">char</span> express[])</span> </span>&#123;</span><br><span class="line">    SqStack Op_char; <span class="comment">// 声明运算符栈</span></span><br><span class="line">    SqStack1 Op_float; <span class="comment">// 声明运算数栈</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 记录表达式读取位置</span></span><br><span class="line">    <span class="keyword">char</span> theChar; <span class="comment">// 记录目前读取表达式的字符</span></span><br><span class="line"></span><br><span class="line">    InitStack(Op_char); <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    Push(Op_char, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 将最低优先级的&#x27;#&#x27;起始符压入操作数栈</span></span><br><span class="line"></span><br><span class="line">    InitStack1(Op_float); <span class="comment">// 初始化运算数栈</span></span><br><span class="line">    theChar = express[i]; <span class="comment">// 拿到表达式的第一个值</span></span><br><span class="line">    <span class="keyword">while</span> (theChar != <span class="string">&#x27;#&#x27;</span> || GetTop(Op_char) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> numbers[<span class="number">10</span>]; <span class="comment">// 用于存储多位数字</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度</span></span><br><span class="line">        <span class="keyword">while</span> (isNumber(theChar) || theChar == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 若是数字或小数点，则循环读取</span></span><br><span class="line">            numbers[j] = theChar;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            theChar = express[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈</span></span><br><span class="line">            <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> dot = getIndex(numbers, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 若无小数点则返回-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[k] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dot != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; dot) &#123;</span><br><span class="line">                        sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k - dot - <span class="number">1</span>); <span class="comment">// 将字符转换成对应的多位数字</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; dot) &#123; <span class="comment">// 若没有小数点，这个块不执行</span></span><br><span class="line">                        sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, dot - k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            Push1(Op_float, sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (Precede(GetTop(Op_char), theChar)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="comment">// 栈顶元素优先级比此时的取值更低</span></span><br><span class="line">                    Push(Op_char, theChar); <span class="comment">// 压入运算符栈</span></span><br><span class="line">                    theChar = express[++i]; <span class="comment">// 使读取的位置后移，并取到下一个字符</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                    <span class="keyword">char</span> x;</span><br><span class="line">                    Pop(Op_char, x);</span><br><span class="line">                    theChar = express[++i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">char</span> theta;</span><br><span class="line">                    <span class="keyword">float</span> a, b;</span><br><span class="line">                    Pop(Op_char, theta);</span><br><span class="line">                    Pop1(Op_float, b);</span><br><span class="line">                    Pop1(Op_float, a);</span><br><span class="line">                    Push1(Op_float, Operate(a, theta, b));</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GetTop1(Op_float);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结束吗"><a href="#结束吗" class="headerlink" title="结束吗"></a>结束吗</h2><p>看上去我们的代码已经很完善了，其实我们还有一些东西没有处理：</p>
<ul>
<li>如果输入了错误的中缀表达式？</li>
<li>某些地方的代码可以更加优雅？</li>
<li>大量的中缀表达式验证正确性？</li>
</ul>
<p>对于第一点，我是假设于使用程序的人都会输入正确的中缀表达式，并没有对错误的中缀表达式进行处理和反馈提示，因此对用户有一些不友好，待改进；其次，像一些 for 循环，if else 语句可以更加精简、优雅，没有对代码进行多次提炼，待改进；这个应用程序没有经过大量、多样的测试来验证其准确性，所以并不能保证其完全正确，待改进。</p>
<h2 id="深入与思考"><a href="#深入与思考" class="headerlink" title="深入与思考"></a>深入与思考</h2><blockquote>
<p>如何求后缀表达式的值，以及中缀表达式如何转换为后缀表达式？</p>
</blockquote>
<p>对于前一个问题，我在 Thinking 里已经描述过了，这里就不再再次阐述，对于后一个问题，有了上面的基础，也是很容易实现的，这里就不用代码描述了，就用文字描述一下大概的思路：</p>
<ol>
<li>初始化两个栈：运算符栈 S1 和储存中间结果的栈 S2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压入 S2；</li>
<li>遇到运算符时，比较其与 S1 栈顶运算符的优先级：<ol>
<li>如果 S1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入 S1；</li>
<li>否则，将 S1 栈顶的运算符弹出并压入到 S2 中，再次转到<code>4-i</code>与 S1 中新的栈顶运算符相比较；</li>
</ol>
</li>
<li>遇到括号时：<ol>
<li>如果是左括号“(”，则直接压入 S1；</li>
<li>如果是右括号“)”，则依次弹出 S1 栈顶的运算符，并压入 S2，直到遇到左括号为止，此时将这一对括号丢弃；</li>
</ol>
</li>
<li>重复步骤<code>2</code> 至 <code>5</code>，直到表达式的最右边；</li>
<li>将 S1 中剩余的运算符依次弹出并压入 S2；</li>
<li>依次弹出 S2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次的程序和记录总结，我学到了很多，其中最值得一提的就是编码方式。 在编写程序的时候，我可以先不管各个功能的具体实现（比如<code>Operate()</code>啊，<code>Pop()</code>啊什么的）， 我只需要关注完成这个程序需要什么功能，先写下来，完成一个主函数的逻辑，到后面再去分别实现一个个的辅助函数的逻辑，领悟了这一点对我来说是非常有帮助的，这可以大大的提高我函数式编程的思维。 除此之外，实现一些辅助函数的辅助函数的时候也对我的思维进行了锻炼，比如说精简的<code>Precede()</code>，对多位数字和小数的处理，以及整个中缀表达式求值思维得到了巩固和拓展，对于克服种种难题有满满的成就感。 好了，就这样吧，这应该是我写的最认真的一篇记录了，加油。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
