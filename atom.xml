<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wingsico</title>
  
  <subtitle>真正的大师，永远都怀着一颗学徒的心</subtitle>
  <link href="https://wingsico.github.io/atom.xml" rel="self"/>
  
  <link href="https://wingsico.github.io/"/>
  <updated>2020-12-07T05:44:32.066Z</updated>
  <id>https://wingsico.github.io/</id>
  
  <author>
    <name>wingsico</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>临别有感</title>
    <link href="https://wingsico.github.io/2020/06/24/some-of-leave/"/>
    <id>https://wingsico.github.io/2020/06/24/some-of-leave/</id>
    <published>2020-06-24T02:26:14.000Z</published>
    <updated>2020-12-07T05:44:32.066Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在刷着刷着LeetCode的时候，瞄了一眼时间，是上午9点57分，脑海里突然跳出一个词：感受孤独，不知为何眼角被泪水浸湿。可能是将要毕业的惆怅，可能是爱人离开的不舍，也可能是即将北漂的无奈。这些种种境况带给我的是孤独和惆怅。很久以前我认为自己是一个坚强的人，不在意孤独，不在意离别。可后来发现我错了，彻头彻尾地错了。表面的阳光开朗是由背地里无数次哭泣支撑着，不管是高中毕业离家的离别，还是北京出租屋里的孤独，都让我难以掩泣。孤独从四面八方涌来，好像要把我埋葬于此。不知为何，此时不管脑海里在思考着什么，那些东西全部都被孤独感侵蚀了，鼻酸的感觉时时刻刻充斥着我，视线也越来越模糊。孤独，也就是如此吧。</p><p>虽然我现在还在寝室，身边还有两个室友在谈论着什么，外面风和日丽，小鸟在欢快地嬉闹着。但这些却无法给我带来平静，我的孤独感充斥了我的脑海，将其他一切都沾染上了孤独的颜色。也许室友在谈论即将的离别，也许太阳也在散播着孤独的、惨白的光线，也许鸟儿也在独奏一曲忧伤的哀歌。悄悄是离别的笙箫，也许也吹奏了孤独的曲调，身边的一切，在悄悄地随着时间流逝，但这如此细微的悄悄，却让我感受到无比的孤独和惆怅。孤独，也就是如此吧。</p><p>我不知是害怕孤独，还是害怕离别。是即将离别给我的感伤，还是离别后的孤独让我难以承受，我已难以判断。现在似乎更能理解雨欣的眼泪了，当在以往触手可及的一切即将不复返地离你远去，我想，这似乎确实难以让人接受。离别，也就是如此吧。</p>]]></content>
    
    
    <summary type="html">离别的尽头，也许就是孤独吧</summary>
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="念" scheme="https://wingsico.github.io/tags/%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>《猫鼠游戏》有感</title>
    <link href="https://wingsico.github.io/2020/04/04/catch-me-if-you-can/"/>
    <id>https://wingsico.github.io/2020/04/04/catch-me-if-you-can/</id>
    <published>2020-04-04T09:02:07.000Z</published>
    <updated>2020-12-07T05:44:32.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>看完这部电影，对于结局我是非常喜欢的，我不喜欢悲剧，也不喜欢作为主人公的纯喜剧，对于 猫鼠游戏 中的双方共赢的具有教育意义的结局，让我在观影后不单纯只是了解了弗兰克的结局，而沉浸在这种略微喜悦的感觉中，而是也会让我去平静下来，去真正的作为一个旁观者的一个思考。</p><p>弗兰克的经历我觉得是很现实的，父亲由于税务问题导致破产，母亲也因此出轨。父亲对弗兰克影响颇深，他尊重父亲，也记住父亲说的每一句话和做的每一件事。只有父亲是真正关心他的，父子关心亲如朋友，这点从记住弗兰克生日和父子两的交谈中可以看出。在弗兰克心中，父亲占有很重要的地位。以至于后面父母的离婚，让他开始想要报复银行和政府，因为在它看来，是他们的不公平对待让父亲破产，家庭破裂。因此，他走上了支票诈骗的路。</p><p>在这条路上，弗兰克充分的展现了他的聪明才智和敏锐的观察力，情商更是超高。在一次次成功的欺骗背后，是对细节和人心的把控。不管是当飞行员前在电视上看的相关飞行员的谈话，还是当医生时在电视上的一些谈话，这些对细节的注意和提前规划让他顺利的实施这一切。</p><p>在这趟旅途中，警官卡尔这个角色，我觉得他既是一个抓捕罪犯的警官，其实也是弗兰克唯一可以说真话的朋友。在这场猫鼠游戏中，双方都对对方产生了奇妙的感情，卡尔虽然在追捕弗兰克，但同时也在保护他。</p><p>这场猫鼠游戏，由家庭开始，也由家庭结束，父亲的死，母亲的改嫁，让他最终放弃了这场游戏，这场游戏对于弗兰克来说，也就失去了它的意义。</p><p>在影片的最后的前一段，弗兰克为什么要离开，离开后去了哪里，我无从而知。但从他裁掉记录在档案中的弗兰克被捕的照片可以找到一些蛛丝马迹。被FBI聘用后，压抑的工作和卡尔的无视让他想要回到从前，回到那场猫鼠游戏，也许那样，他才有和卡尔或者其他相互信任的人交流的机会。</p><p>影片的最后，弗兰克和卡尔一起讨论，一起工作，内容依旧是支票诈骗，依旧是那场猫鼠游戏。只是，老鼠搅动奶油变成了黄油，从桶里逃出，最终变成猫了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 中 Number 有多少个?</title>
    <link href="https://wingsico.github.io/2020/04/01/js-number-scope/"/>
    <id>https://wingsico.github.io/2020/04/01/js-number-scope/</id>
    <published>2020-04-01T15:42:39.000Z</published>
    <updated>2020-12-07T05:44:32.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 中 Number 到底有多少个？为了弄清这个问题，并且了解 JavaScript 的 Number 类型设计，将从规范上进行探究。</p><p>这个问题的来源是 winter 老师的 <strong>#重学前端#</strong> 课程，在讲解 Number 类型时提到这样一句话：</p><blockquote><p>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64 - 2^53 + 3) 个值。</p></blockquote><p>对于这个 <code>2^64 - 2^53 + 3</code>，winter老师并没有给出相关的解释，为了弄清楚这个的来源去查阅相关资料后进行整理。</p><p>为了知道这个问题的答案，需要先了解一下在JavaScript中Number是如何表示的。</p><h2 id="JavaScript中的Number"><a href="#JavaScript中的Number" class="headerlink" title="JavaScript中的Number"></a>JavaScript中的Number</h2><p>从ECMAScript规范中得知, Number的值是：</p><blockquote><p>primitive value corresponding to a double-precision 64-bit binary format IEEE 754-2008 value</p></blockquote><p>意思就是：符合IEEE 754-2008 格式的 64 位双精度二进制的原始值。</p><p>在 IEEE 754 中，64位双精度浮点数中的64位由以下部分组成：</p><p><img src="http://cdn.wingsico.org/blog/js%20number.png" alt="64位双精度浮点数"></p><ul><li>s - 符号位，占 1 bit (数符)</li><li>e - 指数位，占 11 bit (阶码=阶码真值+偏移量)</li><li>f - 小数位，占 52 bit (尾数)</li></ul><p>在规范中也明确的给出了各种情况的计算方式：</p><p><img src="http://cdn.wingsico.org/blog/IEEE-64double.png" alt="IEEE 754计算"></p><ol><li><p>如果指数位e全为1，即 e = 11111111111，也就是十进制的2047(2^11-1)，且小数位f不为0，就超过了最大值，这样的数字无法正确表示，表示为 NaN(Not a Number)，此时会无视作为符号位的s</p></li><li><p>如果指数为e全为1，但小数位f为0的话，则根据符号位s得到两个特殊的值((-1)^s)，当s为0时，得到正无穷大，对于JS中的Infinity;当s为1时，得到负无穷大，对应-Infinity</p></li><li><p>如果指数e在 0&lt;e&lt;2^11-1 之间，这个表示 IEEE 认为的正常的浮点数区间，那么对应的数字的计算公式为：(-1)<sup>s</sup>x(2<sup>e-1023</sup>)x(1.f)<br> 对于e-1023和1.f可能会有些疑惑。其中 1023 代表指数的偏移量，那么为什么会有这个偏移量呢，首先，作为11位的阶码，如果是无符号，那么表示的范围为 <code>[0-2047]</code>, 当处于我们第三种情况时，e的范围要去掉0和2047，变成 <code>[1,2046]</code>，如果要表示正负，则需要使用一个bit去作为符号位，范围为 <code>[-1022, 1023]</code>，如果没有偏移量，那么需要引入补码，计算更加复杂，为了简化运算，则使用无符号的阶码，引入了偏移量的概念，通过偏移将其转换成 <code>[1,2046]</code>，所以偏移量为 1023。<br> 那么对于1.f来说，因为对于浮点数，在规范中采用科学计数法的方法，对于十进制12.34来说，用科学技术法表示为 1.234x10^2，不会表示为 0.1234x10^3，其首位肯定是一个不为0的数字，那么在二进制中，只有0和1，那么他的首位就只能是1（用科学计数法表示，首位不能为0）。因为对于所有的浮点数他的首位都是1，因此可以省略一位进行，不需要额外占用1位，所以f实际上的有效位数有53位（其中首位是1）。在计算时需要使用上这个隐含的1。这也是1.f的由来</p></li><li><p>当e为0且f不为0时，是非规范化的数字，用于表示那些非常接近0的数字。</p><blockquote><p>非规格化下，指数为，000 00000000 - 011 11111111 (偏移量) = - 100 00000001（转成10进制，减1取反）= - 1023<br>从指数看，得知最小值是2^-1023，然而如果尾数是0.00000000 00000000 00000000 00000000 00000000 00000000 0001 不为0的情况，52位尾数相当于小数点还能虚拟化的向右移动51，可以取得更小的 2^-51, 所以最小值为 <code>2^-1074 = Math.pow(2,-1074)</code> 约等于 5e-324<br>而JS最小值常量Number.MIN_VALUE正是5e-324<br>所以(-5e-324,5e-324)之间的数比可表示的最小数还要小，显示成0，叫反向溢出。</p></blockquote></li><li><p>如果指数是0且尾数也是0，则表示正负0的情况</p></li></ol><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>从上面的分类我们得知，前两种是非正常的值，第一种含有 2^52 种情况（尾数有52位），第二种含有两种情况（正无穷和负无穷），那么根据排列组合，共有 2*1*2^52 = 2^53 种情况。这些非正常的值在JS中以 NaN、+Infinity、-Infinity表示，因此在Number中多了三种情况。那么总数就是 <code>2^64-2^53+3</code>，算得有 18437736874454810627 个值。</p><p>其中也可以解释为什么 <code>NaN != NaN</code>，因为 NaN 代表了 2^52 种情况，不是一个固定的值，而是一批值，自然也不会等于自身了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="深入理解" scheme="https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="规范" scheme="https://wingsico.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Unicode 简介</title>
    <link href="https://wingsico.github.io/2020/04/01/unicode-intro/"/>
    <id>https://wingsico.github.io/2020/04/01/unicode-intro/</id>
    <published>2020-04-01T15:40:52.000Z</published>
    <updated>2020-12-07T05:44:32.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Unicode是一种编码格式，它出现的主要原因是为了统一全球的符号编码，因为在Unicode之前，对于一些基本字符通常采用ASCII码的方式表示，但ASCII码是由一个字节组成的，最多只可以表示256个字符。</p><p>那么ASCII码能表示的字符是相当的有限了，且和其他的编码方式不能共同使用。因为对于同一个字符，别的编码方式可能对应的数字和ASCII中的不一致，这就导致了不通用的问题，这也是Unicode致力于解决的问题，它希望给世界上每一种文字系统的每一个字符，都分配一个唯一的整数，这些整数叫做代码点（Code Points）。</p><p>Unicode的数量理论上是无限的，但从中分出了 UTF-8, UTF-16, UTF-32等，其中的数字代表他可以表示的字符最少占用的bit数量。也就是 UTF-8 最少可以用一个字节表示一个字符，UTF-16 最少要用两个字节表示一个字符，UTF-32 最少要用 4 个字节来表示一个字符。</p><p>其中 UTF-8 是最灵活的，可以使用 1 - 8 个字节来表示字符， UTF-16 可以用两个字节或四个字节来表示一个字符，UTF-32 只能用四个字节来表达一个字符。</p><p>Unicode编码使用16进制，表示方法为 U+xxxx，U+0000 ~ U+FFFF 为基本多文种平面 (Base Multilingual Plane)。Unicode规范上规定了17个代码平面，分为 #0 ~ #16，其中 #0 就是 BMP，这17个平面理论上可以编码110多万个字符。</p><p>根据情况合理利用 UTF-8，UTF-16 等可以节省空间 (UTF-8需要占用空间来表示这个字符需要几个字节)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html">Unicode令人混淆的概念</a></li><li><a href="https://blog.csdn.net/zxhoo/article/details/38819517">图说我的Unicode的理解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="unicode" scheme="https://wingsico.github.io/tags/unicode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 规范类型</title>
    <link href="https://wingsico.github.io/2020/04/01/js-spec-types/"/>
    <id>https://wingsico.github.io/2020/04/01/js-spec-types/</id>
    <published>2020-04-01T15:27:52.000Z</published>
    <updated>2020-12-07T05:44:32.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>每一种语言都有自己的类型，但基本上都是遵从语言的规范类型。对于一些规范类型，winter描述的并不详细。因此，在查阅相关资料后，对齐进行补充。</p><a id="more"></a><h2 id="规范类型"><a href="#规范类型" class="headerlink" title="规范类型"></a>规范类型</h2><p>共有以下7种规范类型：</p><ol><li><p>List和Record：List是用来描述参数列表的执行，其实跟ES中规定的数组的意义相近，但是写规范的时候还不存在ES的数组类型，所以使用List代替，写作&lt;&lt;1,2&gt;&gt;。而Record是用来描述算法中的数据聚合的，可以简单理解为ES中的对象，这类类型的话内部聚合了一个或多个命名字段（可以理解为键值对），其中命名字段的值一般是ES规范中的值或者是Record类型关联的抽象值（可以简单对应为JS中的基本类型的值或者是对象类型的值），字段的名称始终用 <code>[[name]]</code> 表示。你可以在JS对象的原型链上或原型链中的某个属性中看到类型的表示，例如 <code>[[Scopes]]</code>，但一般涉及语言实现，不会对外暴露出具体信息。</p></li><li><p>Set和Relation：Set主要是解释内存模型中使用的无序元素集合，即数学意义上的集合，其中的元素出现不超过一次，应该与ES6中的Set类型对应，在语言层面上会用于描述字符集之类的。Relation用于解释Set之间的关系，例如包含、交叉等，可以参考数学定义上的集合关系。</p></li><li><p>Completion Record：翻译过来即是完成时的记录，这里的完成时一般是指语句执行后的完成状态。这个完成状态有几种类型，例如正常的复赋值语句完成后，他的完成状态就是normal，但例如break, continue,return, throw这些语句执行完成后，其完成状态就是对应的状态（break,continue,return,throw）。ECMAScript规范中的每个运行时语义都显式或隐式返回一个报告其结果的完成Completion Record。Completion Record是一个Record，所以就可以用对象来描述它，它有三个字段：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Completion Record = &#123;</span><br><span class="line">  [[type]] <span class="comment">// Completion的类型，有 normal, break, continue, return, throw 5种类型</span></span><br><span class="line">  [[value]] <span class="comment">// 返回的值为ES语言值或空，仅当当[[type]] 为 normal,return, throw时有值</span></span><br><span class="line">  [[target]] <span class="comment">// 定向控制转移的目标label，为string或空，仅当[[type]] 为break, continue时有值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> type 对应的是完成状态的类型。而value、target从字面理解就是完成后得到的值和需要跳转的目标，这个目标的话在我们使用 break, coutinue 的时候可以在后面跟一个 label， 来指定要跳转的模板，即 <code>continue xxx</code>。</p><p> 只有当 type 为 <code>[[normal]]</code> 时，才是正常的完成状态，其他的类型均为 <strong>中断的完成状态</strong></p></li><li><p>Reference类型：用来解释诸如delete，typeof，赋值运算符，super关键字和其他语言特征等运算符的行为。 简单理解，就是如何去解析这些运算符的使用，有点类似词法作用域中对变量的LHS，RHS的查找。</p><p> Reference一般由三个部件组成</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BaseValue <span class="comment">// 值为：undefined,Object,Boolean,String,Symbol,Number,Environment Record. </span></span><br><span class="line">  ReferencedName <span class="comment">// String或Symbol值。</span></span><br><span class="line">  StrictReference <span class="comment">// 布尔值，标识是否为严格模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 举个例子：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  b: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 那么在查找b的时候就会得到一个Reference类型：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BaseValue: a,</span><br><span class="line">  ReferencedName: b,</span><br><span class="line">  StrictReference: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个类型从语言规范层面来说，可以解释为什么可以直接对字符串字面量使用字符串方法，例如 <code>&quot;ABC&quot;.toLowerCase()</code>，要执行这个语句，就要知道<code>&quot;ABC&quot;.toLowerCase</code>是什么，才能执行函数。这个语句会得到以下的Reference：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BaseValue: <span class="string">&quot;ABC&quot;</span>,</span><br><span class="line">  ReferencedName: toLowerCase,</span><br><span class="line">  StrictReference: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Reference内置了一些方法，对这个例子而言，对 <code>.</code> 运算符解释时会对 Base Value 执行 <code>[[GetValue]]</code> 内置方法，由于 “ABC” 是原始值类型的 （<code>Primitive</code>，也就是在拆箱转换的时候提到的），会对 BaseValue 进行 <code>ToObject(BaseValue)</code>, 将其变成 String 对象，再调用 <code>toLowerCase</code> 方法。</p><p> 还有一些其他的内置方法，就不展开描述了。</p></li><li><p>Property Descriptor类型：就是属性描述符，用来解释对象属性的特性的操作，其值为Record类型，分为数据属性描述符和访问器属性描述符。例如 <code>[[Writable]]，[[Get]]</code> 等</p></li><li><p>Lexical Environment和Environment Record类型：主要是用来描述ES里作用域，标识符绑定等等。这个要详细描述的话有点长，可以查询一下相关资料。关于作用域、闭包的解释都可以从这个层面来说明。</p></li><li><p>Data Blocks：主要是描述二进制数据，用来描述字节大小（8位）数值的不同且可变的序列。这个我也不太懂，就不详细说明了。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是对 winter 对规范类型的补充说明，也是我自己刨根问底的一种尝试吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每一种语言都有自己的类型，但基本上都是遵从语言的规范类型。对于一些规范类型，winter描述的并不详细。因此，在查阅相关资料后，对齐进行补充。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="规范" scheme="https://wingsico.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>2019.6月 头条前端三面 面经</title>
    <link href="https://wingsico.github.io/2019/06/12/byteDance-intervies/"/>
    <id>https://wingsico.github.io/2019/06/12/byteDance-intervies/</id>
    <published>2019-06-12T09:06:10.000Z</published>
    <updated>2020-12-07T05:44:32.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单记录一下第二次面试的经历，之后总结各个不熟悉知识点再进行整理。</p><a id="more"></a><h2 id="为什么选择实习"><a href="#为什么选择实习" class="headerlink" title="为什么选择实习"></a>为什么选择实习</h2><p>考研or实习都是一种选择，不同的人适合不同的路，都需要结合自己的实际情况来决定。</p><p>就拿我自己来说吧，从大一开始接触互联网，接触前端后，自己对考研就没有什么想法了，因为当时自己对考研也没有什么概念，而且也遇到了自己比较喜欢的前端，觉得做前端是一件很幸福的事情。再加上优秀的学长拿到各种offer，自己心里对以后的自己也更加期盼，希望自己和他们一样优秀。</p><p>一步步走来，也遇到了很多困惑，也经常陷入到非常迷茫的状态，总是反问自己，自己是否真的适合做前端呢？加上周边人都非常优秀，自卑和不自信总是让我焦躁不安。加上大二下学期 Teambition 的面试失利，更觉得自己出来是根本找不到好工作/实习。再加上家人希望我考研的想法、女票考研、想深造等等的原因让我在大三上学期中下旬做出了去考研的决定，觉得尝试过了，就算失败没考上也是不会后悔，而且就算失败了到时候出来凭借自己三年来所学的前端知识应该也不至于没事做。抱着这样的想法，我踏上了考研的征途。</p><p>我开始了解有关考研的一切：学校、科目、复习计划、书籍等等等，开始每天英语，数学的轮番轰炸，开始6点半起床7/8点开始学习，到晚上10点多结束的生活，也早早的定好了意向学校。每天就是看视频、记笔记、学英语，但是学校也有一些事情(比如徐某的作业)，也会干扰的自己的一些复习计划，加上女票因为一些身体原因也经常需要去医院之类的，我也应该陪同。在各种干扰下，自己的一个学习进度一直很缓慢，做题也非常的慢，心中难免会焦虑。而周某人=。=一天到晚给我发各种实习，扰乱我的心境(雾)，让我一再有屏蔽他的想法(23333)。</p><p>但自己还是硬着头皮坚持了几个月，但每天并没有学习一天的充实感，学习进展也随着难度的增大而更加缓慢。之后让我再去思考到底是考研或者实习就发生在彪彪去头条实习之后。我开始仔细考虑，自己是否真的要去考研。</p><p>花了一个星期，我一直考虑以下问题：</p><ol><li>考研的目的是什么</li><li>以后想从事什么方面的工作</li><li>考研会给我带来什么，实习会给我带来什么</li><li>对于以后想从事的行业是否对学历有着硬性的要求</li><li>自己现在的水平能不能找到一份较为满意的实习</li><li>一年后如果失败了如何应对</li><li>是否会后悔自己的决定</li></ol><p>我的想法依次如下：</p><ol><li>对我而言，考研是为了：<ol><li>提高学历</li><li>深造以获得更多选择</li><li>重新学习大学的课程</li><li>陪女票一起，度过这段困难的时期</li><li>满足家人的要求</li><li>提高自己的竞争力</li></ol></li><li>了解了关于云计算、大数据之类的，再读了一些关于分布式的论文后觉得这行也挺有意思的，想着如果能考上研究生希望去研究这一方面的技术。或者继续从事前端相关的事情。但后面更深入的了解关于云计算、大数据的一些具体的东西，觉得自己可能不太适合。但事无绝对，你没有深入一个行业去了解你永远无法知道自己到底适不适合它。但至少，前端我是很喜欢的也愿意去做相关的行业。</li><li>考研给我带来的也就是我考研的目的，而实习的话我在最初的选择也只有前端这一个选择，那么实习给我带来的是更早的接触公司的一些实际需要考虑的一些问题，技术上的提升，更早的经济收入、社会了解等等。</li><li>如果从事前端，在学历要求上更没有其他岗位的那么严格，初级阶段门槛也比较低。但是如果想往人工智能、大数据等方向进行发展的话，大部分还是会要求一个研究生的学历的。因为它需要这样一个较高门槛才可以去真正做出一些东西来的。</li><li>对于自己的水平，我一直是不是很自信，觉得自己学的东西比较浅，也有一些浮躁。虽然之前大二Teambition面试失败，但是很大一部分原因归结于自己没有准备(裸试可还行。。)，所以对于自己的水平到底能否去承担起一个这样的职位还是没有底的。而后面彪彪拿到offer也给我了一些信心，我觉得我跟彪彪的水平差不多，我也许可以去尝试一下。</li><li>对于失败，我从一开始就非常的坚定，绝不二战的，失败了就直接去找前端的实习工作。但是，一年前端的空窗期会对自己的水平造成多大的影响以及前端行业的一年后会发展成什么样自己能否跟上，这些都是让我所担忧的。</li><li>选择前端，我不会后悔，至少我对考研我尝试过几个月，了解自己的一个学习状态。而对于选择考研，并不知道自己是否会后悔。</li></ol><p>综合考虑一些问题之后，和家里人也沟通了很多次，各种思想斗争后，还是决定重拾前端。对于前端，我始终有着很大的热情，能够且愿意把时间花在上面，就算是遇到困难也会慢慢沉下心去解决。对于考研，我已经尝试过了，觉得自己的精力无法再全身心的投入进去，就算之后想起这个决定也不会觉得后悔。</p><p>就这样，我做出了这个决定，一个不再回头的决定 —— 找实习</p><h2 id="实习准备"><a href="#实习准备" class="headerlink" title="实习准备"></a>实习准备</h2><p>由于花费了数个月去准备考研，对于前端的知识就忘了一些，在提前联系了在头条的学长咨询相关情况后，决定先花一个月来准备，刚开始的计划是这样：</p><ol><li>每天两道leetcode算法题</li><li>刷面经</li><li>每天看看公众号文章以及掘金文章</li><li>做一个关于react + typescript的项目</li><li>读一本关于前端工程化的书，再看看你不知道javascript</li><li>限定自己最晚投简历的一个时间(定为5月31日，但实际上6月2日才投)</li><li>每天解决一个自己不熟悉的点，列出了一份清单并贴在墙上</li></ol><p>后面发现写新的项目有点来不及，时间不是很充裕。真正做到了的也就是把一些不熟悉的清单项仔仔细细的去读懂，每天刷两道算法题(到了后面就刷的更少了)，读的书也只读了差不多一半，到后面快要到deadline就直接快速翻了翻相关的内容。</p><p>以上计划在这次面试除了第三点（也就是再去做个项目），都对这次面试起到了比较大的作用，其中起了较大作用的是 1， 2，6，7。然后最重要的就是刷面经了，通过刷面经，基本上解决了百分之六十的问题，很多被问到的问题也是我通过刷面经之后才知道的。所以刷面经很重要！！很重要！！很重要！！</p><p>关于简历的话，我还是使用了子健学长的简历模板，然后彪彪用的也是(然后在面试的时候就问了为啥你俩简历看起来样子都差不多)。如果有内推的话，简历只要把你的信息写好，做过哪些项目，会什么技术之类的写好就行，主要还是看笔试面试。</p><p>然后在这篇文章的最后会给出我看的一些比较好的文章的链接。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>每轮面试基本上都有一个自我介绍环境，简单介绍一下自己的信息，前端经历，项目经历，性格什么的。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>第一面的面试官感觉是个很随和很好相处的人，给我的感觉就是聊天没有什么压力，如果你答对了会给你一些反馈，答错了也会给你解释一下(虽然我答错的题目他也不能很清晰说出个所以然来)</p><p>一面问的问题都比较基础，我把我能想起来的都写在下面：</p><hr><ol><li>自己实现一个bind</li><li>写一个算法：找到一个数组的子数组，使得这个子数组的和大于一个给定的值n，并且这个子数组最短。比如arr = [1,2,3,4,5,6]，n= 10，那么最短的就是 [5,6]</li><li>vue.$nextTick原理，回退方案</li><li>异步队列，宏任务微任务(通过代码的执行顺序考察)</li><li>如何判断数据类型，为什么用 Object.prototype.toString.call() 来做，直接toString为什么不行</li><li>setImmediate和setTimeout区别</li><li>闭包</li><li>逻辑运算(&amp;&amp;, || , !)，运算符优先级</li><li>this指向</li><li>“aaa” == new String(“aaa”) // true or false</li><li>null == undefined // true or false</li><li>字符串和数字运算得到的结果，比如 1 + “2” + 1 或者 “2” + 1 + “2” 或者 “2” - 0 + 3之类的</li><li>es6 modules 和 commonjs 模块方案之间的区别(不是用法上的区别)</li><li>http状态码</li><li>CSRF是什么，如何防御</li><li>垂直居中方案</li><li>position:relative相对谁定位</li><li>new操作做了哪些事情</li></ol><hr><p>上面只是说了一个大概的，面试官实际上拿了一份pdf笔试题给我做了一下，然后能想起来就这么多，基本上都回答出来了，除了第13点,和第2点(基本思路对了，但是代码跑了个死循环=-=)</p><p>然后真心觉得面试官很能聊得来，就像聊天一样没有什么压力。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的面试官比较严肃，给人一种居高临下的压力。这轮面试表现不太好，一方面是因为面对比较严肃的面试官我内心压力挺大，很多问题都有点答非所问。另一方面有些场景下原理了解的不是特别深，被问到就有点慌了阵脚。</p><p>下面是我能回想起来的一些问题：</p><hr><ol><li>cookie，sessionStorage, localStorage 作用和区别</li><li>写一个寄生组合式继承</li><li>说一下事件的执行机制(事件捕获、冒泡)</li><li>用过Jquery吗？$.on用过吗？</li><li>介绍一下http</li><li>https的通信原理</li><li>http2.0有哪些新特性</li><li>Vue的数据劫持，用Object.defineProperty相比于Proxy有什么缺点</li><li>Vue为什么需要this.$set</li><li>requestAnimationFrame是什么，用它做动画和setTimeout有什么区别</li><li>前端路由的实现原理(history, hash)</li><li>使用命令式代码进行路由跳转的时候(Router.push)，如何监听url的变化，(Router.push的具体实现相当于黑盒，不能修改)</li><li>什么是反向代理</li><li>网页扫码登陆是怎么做的</li><li>同源策略，如何跨域请求资源</li><li>请求跨域资源要发几次请求，请求同源资源发几次请求，option请求是做什么的</li><li>http的请求中包含哪些属性(比如Content-type之类的)</li><li>了解哪些加密算法，有什么区别</li><li>资源的缓存(协商缓存、强缓存)，区别</li><li>说一下事件委托</li><li>对nodejs了解多少</li><li>你的优势是什么</li><li>你的缺点是什么</li><li>你有什么问题想问的吗？</li></ol><hr><p>3,4,8,11,12,16,23这几点感觉回答的不太好，虽然原理都知道，但是进行一些扩展问一下就不懂了，比如说知道vue数据劫持的原理是什么，但是不知道那两个方案有什么区别。虽然知道路由实现的原理，但是对于后面的给出的场景(监听url变化)没有想到一个很好的解决方案(连最基本的暴力setInterval都没想到)。对于请求中包含的属性也没有说太多，感觉是因为紧张想不起来。</p><p>然后说缺点的时候有点作死，说自己对于不喜欢的事情可能不是那么上心。。然后面试官说那给你分配你一些你可能不喜欢的业务的时候你是不是也不上心不好好做。。这个缺点我没有提前去想好怎么说，然后感觉就比较作死。。</p><p>然后后面面试官也看出我比较紧张(虽然我也跟他说了)，然后让我调整心态，放松，不要沮丧。</p><p>wtf？我听到不要沮丧的时候我整个人都不好了。。难道我就死在二面了。。让我失败了也不要沮丧什么的。。当时我的心就凉了半截。。不过最后他说了这一轮给我过。。才放下心来。</p><p>后面问你有没有什么问题想问，我当时又作死去问他他觉得我表现怎么样。。不说了，最好不要问这个问题，现在想想脑子是不是哪根筋答错了。应该可以问问项目规划或者技术栈什么的。</p><p>对于二面，我想说的就是，学习知识的时候要多思考，多问问为什么，才能有去查看原理的一些问题。其次，面对自己不懂的问题，不要含糊的回答，大方的直截了当地说不懂就行了，不知道 &gt; 乱说。然后就是要调整好自己的心态，面对压力的表现也是考核的一部分。(然后吐槽一下我花了大量时间看React的东西然后一点没问。。)</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面面试官也比较随和，交流也很舒服。但是感觉说话不多，不过整个面试下来都是比较轻松的。</p><p>这一面关于技术的问的比较少，就问了一道leetcode上面的算法题。</p><p>寻找两个有序数组的中位数：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数。偶数需要将中间两个值除以二。</p><p>这道题我做过，在leetcode上是hard级别的题目，但是要求是O(log(n+m))的复杂度，我写了一个O(n+m)的。然后问我有没有更快的算法，有没有O(log(n+m))级别的实现。但这个复杂度的算法有点复杂，需要提前进行一些数学运算在结合二分查找来做优化，一时半会也没想出来，不过他也没有追究这个问题。</p><p>之后就问了项目相关，有没有什么项目可以给他看一下的，然后我就拿了重构的Us项目给他看(由于我已经没有一些权限了，所以只能看到家园圈子那一块)，然后问了问你做了哪些事情，怎么设计的之类的问题。这个就是结合项目和你当时做的一些方案去说了。(所以说项目很重要，项目经验很重要)</p><p>在之后就问问一下简历上写的用node做爬虫的，是怎么做的。然后我就说了一下具体的实现难点，比如异步、并发控制，代理ip池，缓存中间数据等等，然后问了我为什么做这个项目，就又说到了这个是拿去参加比赛的项目中的一部分。然后就问了问我比赛的流程，怎么比的，获奖了没有，小组几个人完成的之类。</p><p>在之后又问了问高考成绩，跟当时一本线比高了多少分什么的。再之后就谈了谈实习相关，比如能实习多久之类的</p><p>总得来说三面是最简单的，没有过多的技术谈话，整个过程基本上都是我在不停的说，然后也是三个面试中用时最短的了，面完结束后就让我等hr电话了。</p><h3 id="HR-这个不算面试，就是聊天"><a href="#HR-这个不算面试，就是聊天" class="headerlink" title="HR(这个不算面试，就是聊天)"></a>HR(这个不算面试，就是聊天)</h3><p>这个就直接跟HR在电话中交谈，大概花了十多分钟。</p><p>问的问题：</p><ol><li>家住哪</li><li>能实习多久</li><li>会去秋招吗</li><li>如果以后有更好的工作机会(腾讯阿里)，会去吗</li><li>对于北京觉不觉得太远了</li><li>毕业是考研还是工作呢</li><li>有什么想问的吗</li></ol><p>对于会不会去秋招我的回答是会去，会去尝试一下更好的公司面试是怎么样的，看看自己水平如何，但是还是留在头条实习。对于以后有更好的机会我老老实实回答的会去。然后对于北京我觉得还是有点远的，不过实习嘛，地点在我看来就没有那么重要。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说头条的面试效率很高，我提交简历一两个小时后就跟我联系约面试时间了，然后半个下午就完成了一二轮面试，第二天进行的第三面，每次面试持续时间一个小时左右。总之有几点建议：</p><ol><li>面试的话一定要刷面经</li><li>一定要对自己学的知识再去深入的了解一下</li><li>要去做算法题</li><li>遇到不会的不要慌了阵脚，要及时调整好心态</li><li>知之为知之，不知为不知</li><li>至少做一个拿得出手项目</li></ol><p>最后希望大家都能拿到自己心仪的offer。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2">牛客网前端面试总结</a></li><li><a href="https://www.xiaohuochai.cc/">小火柴的前端小站</a></li><li>面试官系列：<ol><li><a href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a">面试官系列(1): 如何实现深克隆</a></li><li><a href="https://juejin.im/post/5ac2fb886fb9a028b86e328c">面试官系列(2): Event Bus的实现</a></li><li><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b">面试官系列(3): 前端路由的实现</a></li><li><a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf">面试官系列(4): 基于Proxy 数据劫持的双向绑定优势所在</a></li><li><a href="https://juejin.im/post/5b16c0415188257d42153bac">面试官系列(5): 你为什么使用前端框架</a></li><li><a href="https://juejin.im/post/5c02142fe51d4511be77aad7">面试官系列(6): 写过『通用前端组件』吗?</a></li><li><a href="https://juejin.im/post/5c03b85ae51d450c740de19c">面试官系列(7): 聊一聊 Babel</a></li><li><a href="5bf8dab3f265da61590b55d4">面试官(8): React 强调的『不可变数据结构』怎么实现?</a></li></ol></li><li><a href="https://github.com/forthealllight/blog/issues">forthealllight’s blog</a></li><li><a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question">前端面试搜集</a></li><li><a href="https://www.cnblogs.com/chaoran/p/8891892.html">BAT前端开发面经 - 附解答</a></li></ol><p>以上均为参考链接，且都有一些回答的。然后感觉刷面经的主要作用就是让你知道你自己哪里不懂，然后再去通过其他方式来</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单记录一下第二次面试的经历，之后总结各个不熟悉知识点再进行整理。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="总结" scheme="https://wingsico.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2019年-2020年目标规划</title>
    <link href="https://wingsico.github.io/2019/06/11/2019-plan-1/"/>
    <id>https://wingsico.github.io/2019/06/11/2019-plan-1/</id>
    <published>2019-06-11T15:13:10.000Z</published>
    <updated>2020-12-07T05:44:32.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个有略微拖延症的患者，觉得清单驱动行为是很有必要的。现将一些目标规划列出来，驱动自己将其完成。</p><p>在完成过程中，也将把其整理成博客，希望今年还能取得更多进步！</p><a id="more"></a><h2 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h2><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="深入理解系列"><a href="#深入理解系列" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol><li>svg</li><li>canvas</li><li>video</li><li>shadow-dom</li><li>web-component</li><li>web worker</li><li>CSS3</li></ol><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><h4 id="深入理解系列-1"><a href="#深入理解系列-1" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol><li>Proxy</li><li>Class</li><li>Generator</li><li>Async</li><li>Promise</li><li>Blob</li><li>垃圾收集</li><li>正则表达式</li><li>Iterator</li><li>Object.defineProperty()</li><li>Reflection</li><li>typescript</li><li>ES6/7/8 等新特性</li></ol><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="深入理解系列-2"><a href="#深入理解系列-2" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol><li>Fiber</li><li>Hooks</li><li>HoC</li><li>render function</li><li>immutable</li><li>pure function</li><li>更新、渲染机制</li><li>jsx</li><li>设计方案</li></ol><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><ol><li>React + typescript + [状态管理方案 Mobx,Redux] + antd 重构 US</li><li>React + Koa2 + Mongodb 写一个自己的博客</li></ol><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><h4 id="深入理解系列-3"><a href="#深入理解系列-3" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol><li>异步 IO</li><li>事件驱动</li><li>异步并发控制</li><li>V8</li><li>Buffer</li><li>中间件</li><li>流</li></ol><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="深入理解系列-4"><a href="#深入理解系列-4" class="headerlink" title="深入理解系列"></a>深入理解系列</h4><ol><li>mixins</li><li>observable</li><li>Vue.use</li><li>diretives</li><li>provide/inject</li><li>设计方案</li></ol><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="理解并实践"><a href="#理解并实践" class="headerlink" title="理解并实践"></a>理解并实践</h4><ol><li>Webpack</li><li>Gulp</li><li>PostCSS</li><li>Scss</li><li>设计模式</li><li>算法</li><li>函数式编程</li><li>网络</li><li>数据结构</li><li>数据库</li><li>Git</li><li>测试</li><li>工程化</li></ol><h2 id="生活类"><a href="#生活类" class="headerlink" title="生活类"></a>生活类</h2><ol><li>减肥 15 斤</li><li>养成良好作息习惯</li><li>学会炒更多菜</li><li>女票考研成功！</li><li>坚持健身</li><li>存钱！</li><li>认识更多的人</li><li>读一些非技术类的书</li></ol><p>加油，为了美好青春而战，为了家人，也为了自己！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个有略微拖延症的患者，觉得清单驱动行为是很有必要的。现将一些目标规划列出来，驱动自己将其完成。&lt;/p&gt;
&lt;p&gt;在完成过程中，也将把其整理成博客，希望今年还能取得更多进步！&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="规划" scheme="https://wingsico.github.io/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 重置MySQL密码</title>
    <link href="https://wingsico.github.io/2018/03/27/mysql-password-reset/"/>
    <id>https://wingsico.github.io/2018/03/27/mysql-password-reset/</id>
    <published>2018-03-27T08:26:53.000Z</published>
    <updated>2020-12-07T05:44:32.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如何在 Mac OS 上重置 MySQL 服务密码?</p><a id="more"></a><h2 id="1-停止-MySQL-服务"><a href="#1-停止-MySQL-服务" class="headerlink" title="1. 停止 MySQL 服务"></a>1. 停止 MySQL 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server stop</span><br></pre></td></tr></table></figure><h2 id="2-进入安全模式"><a href="#2-进入安全模式" class="headerlink" title="2. 进入安全模式"></a>2. 进入安全模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqld\_safe --skip-grant-tables</span><br></pre></td></tr></table></figure><p>这个地方，如果你 <code>alias</code> 了 <code>mysqlld\_safe</code> 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 <code>/usr/local/mysql/bin/mysqld/usafe</code>。</p><p>说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。</p><p>这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。</p><h2 id="3-新打开一个终端，进入-MySQL"><a href="#3-新打开一个终端，进入-MySQL" class="headerlink" title="3. 新打开一个终端，进入 MySQL"></a>3. 新打开一个终端，进入 MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： <code>/usr/local/mysql/bin/mysql -u root -p</code> 然后输入任意密码就可以进入 MySQL 了。</p><h2 id="4-修改密码"><a href="#4-修改密码" class="headerlink" title="4. 修改密码"></a>4. 修改密码</h2><p>进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。</p><p>MySQL 的用户信息是存在 <code>mysql.user</code> 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql; <span class="comment"># 切换数据库</span></span><br><span class="line"><span class="keyword">describe</span> <span class="keyword">user</span>; <span class="comment"># 查看user表的字段</span></span><br></pre></td></tr></table></figure><p>然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。</p><p>然后修改密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">authentication</span>\_string=<span class="keyword">PASSWORD</span>(<span class="string">&#x27;123456&#x27;</span>) <span class="keyword">where</span> <span class="keyword">User</span>=<span class="string">&#x27;root&#x27;</span>; <span class="comment"># 将root用户密码改成 123456</span></span><br></pre></td></tr></table></figure><h2 id="5-刷新权限，使配置生效"><a href="#5-刷新权限，使配置生效" class="headerlink" title="5. 刷新权限，使配置生效"></a>5. 刷新权限，使配置生效</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>最后再启动 MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何在 Mac OS 上重置 MySQL 服务密码?&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂文" scheme="https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"/>
    
    <category term="疑难杂症" scheme="https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="mysql" scheme="https://wingsico.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 非定义路由的访问</title>
    <link href="https://wingsico.github.io/2018/03/16/vue-router-404/"/>
    <id>https://wingsico.github.io/2018/03/16/vue-router-404/</id>
    <published>2018-03-15T16:54:12.000Z</published>
    <updated>2020-12-07T05:44:32.072Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在写<code>vue</code>的路由表时，通常会遇到这样的一个问题，<strong>我已经定义了一系列路由，但我想要用户在访问非定义的路由的时候返回一个提示或者重定向至指定页面。</strong>该如何实现？</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我想到的是监听<code>hash</code>的变化，根据已经定义的路由来判断是否是非定义的路由，但这样有个问题，当定义其他路由或修改路由的时候，监听路由变化的函数也要修改，这就造成了一个很强的耦合性，因此此方法并不实用。 但略微查看<code>vue-router</code>的官方文档，没有看到相关的解决方案，于是在 google 搜索相关的问题，在一篇博客里看到一句话：</p><blockquote><p>又一个在使用 Vue 过程中遇到的新坑。首先踩这个坑都怪我自己看文档不够仔细，所以告诫大家，看文档真的一定要认认真真的一个个字的认真的品味。 vue-router 动态路由匹配 中有这么一段： 匹配优先级 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p></blockquote><p>吓得我又回去翻看了一下文档，果然，在最最下面有一个匹配优先级。。 因此，想到了一个更加简单的方法去实现限制非定义路由的访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// 404 置后</span></span><br><span class="line">   path: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">   component: &#123;</span><br><span class="line">     beforeCreate () &#123;</span><br><span class="line">       <span class="built_in">window</span>.swal(&#123;</span><br><span class="line">         type: <span class="string">&#x27;warning&#x27;</span>,</span><br><span class="line">         title: <span class="string">&#x27;404 NOT FOUND&#x27;</span>,</span><br><span class="line">         timer: <span class="number">1000</span>,</span><br><span class="line">         showConfirmButton: <span class="literal">false</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     template: <span class="string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>window.swal</code>是引用的<code>sweetalert.js</code>的一个方法，主要作用就是一个美化提示弹框。 而对于这个<code>component</code>对象内的<code>beforeCreate</code>就很陌生了，为什么配置路由的<code>component</code>会出现这个，难道是属于路由的生命周期？ 但转念一想，<code>component</code>里本来应该的数据是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    component: <span class="built_in">require</span>(<span class="string">&#x27;@/views/hello&#x27;</span>) <span class="comment">// 类似写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>component 内本该是由一个<code>单文件组件</code> (.vue 文件) <code>export</code>出来的，因此，我认为这里的<code>beforeCreated</code>其实是组件的生命周期，因为在非单文件组件中，定义一个组件的方式就是如此： 这是一个官方的 demo:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  data () &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; 将只在父组件模板中可用</span></span><br><span class="line">    <span class="string">&#x27;my-component&#x27;</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以由此可以看出，我的判断应该无误，ok，大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在写&lt;code&gt;vue&lt;/code&gt;的路由表时，通常会遇到这样的一个问题，&lt;strong&gt;我已经定义了一系列路由，但我想要用户在访问非定义的路由的时候返回一个提示或者重定向至指定页面。&lt;/strong&gt;该如何实现？&lt;/p&gt;</summary>
    
    
    
    <category term="疑难杂症" scheme="https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="vue" scheme="https://wingsico.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程之curry</title>
    <link href="https://wingsico.github.io/2018/03/15/functional-programming-1/"/>
    <id>https://wingsico.github.io/2018/03/15/functional-programming-1/</id>
    <published>2018-03-15T15:43:03.000Z</published>
    <updated>2020-12-07T05:44:32.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始学习函数式编程，对函数式编程有了更多的一点点认识，对函数的 curry 接触了一点点，以此作为记录，写下当前感悟</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>先来看一个常见的需求：</p><blockquote><p>现给定一个字符串： const STRING = “This is the mid day show with Cheryl Waters” 请将空格替换成”-“</p></blockquote><p>这是一个很简单的需求，很自然的写下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replaceSpaceToStrike = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/ /g</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace(STRING);</span><br></pre></td></tr></table></figure><p>或者是写个更具有拓展性的函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replace = <span class="function">(<span class="params">reg, replacement, str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, replacement);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;-&quot;</span>, STRING);</span><br></pre></td></tr></table></figure><p>发现参数多而杂乱。那么把它 curry 化我们应该如何去写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replace = <span class="function"><span class="params">what</span> =&gt;</span> <span class="function"><span class="params">replacement</span> =&gt;</span> <span class="function"><span class="params">str</span> =&gt;</span> str.replace(what, replacement);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> noSpaces = replace(<span class="regexp">/\s+/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cenosred = noSpaces(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">cenosred(STRING);</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>curry</code> 化在完成最终需求之前生成了许多 <code>curry 帮助函数</code>, 这里表明了一种 <strong>预加载函数</strong> 的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 相比于之前的解决方案，它需要更多的代码，但只需要参入一部分参数，就能的到一个新的函数。相对于之前的方案，它更加灵活，同时减少了同时传参的个数。 这个例子可能没有突出函数式 <code>curry</code> 化的优点，再举一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getChildren = <span class="function"><span class="params">x</span> =&gt;</span> x.childNodes; <span class="comment">// 获得一个节点的子节点</span></span><br></pre></td></tr></table></figure><p>这是针对一个元素的函数， 利用<code>curry</code>化，我们可以很容易扩展到数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="params">arr</span> =&gt;</span> arr.map(f);</span><br><span class="line"><span class="keyword">const</span> getAllChildren = map(getChildren);</span><br></pre></td></tr></table></figure><p>通常我们不定义直接操作数组的函数，因为只需内联调用 <code>map(getChildren)</code> 就能达到目的。这一点同样适用于 <code>sort</code>、<code>filter</code> 以及其他的 <strong>高阶函数（higher order function）</strong>（高阶函数：参数或返回值为函数的函数）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>curry</code> 函数用起来非常得心应手，使用它简直就是一种享受。它堪称手头必备工具，能够让函数式编程不那么繁琐和沉闷。 通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。 此外，我们还可以引入 <code>lodash</code> 和 <code>ramda</code> 中的 <code>curry</code> 函数，帮助我们更好的实现<code>curry</code>化。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近开始学习函数式编程，对函数式编程有了更多的一点点认识，对函数的 curry 接触了一点点，以此作为记录，写下当前感悟&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="函数式" scheme="https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代码片段理解(2)</title>
    <link href="https://wingsico.github.io/2018/03/14/codes-understanding-2/"/>
    <id>https://wingsico.github.io/2018/03/14/codes-understanding-2/</id>
    <published>2018-03-14T02:11:44.000Z</published>
    <updated>2020-12-07T05:44:32.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pick = <span class="function">(<span class="params">field = <span class="string">&quot;&quot;</span>, object = &#123;&#125;</span>) =&gt;</span> object[field];</span><br><span class="line"><span class="keyword">const</span> pluck = <span class="function">(<span class="params">field, array</span>) =&gt;</span> array.map(<span class="function"><span class="params">object</span> =&gt;</span> pick(field, object));</span><br><span class="line"><span class="keyword">const</span> deepPluck = <span class="function">(<span class="params">field, array</span>) =&gt;</span></span><br><span class="line">  array.map(<span class="function"><span class="params">object</span> =&gt;</span> deepPick(field, object));</span><br><span class="line"><span class="keyword">const</span> deepPick = <span class="function">(<span class="params">fields, object = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [first, ...remaining] = fields.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> remaining.length</span><br><span class="line">    ? deepPick(remaining.join(<span class="string">&quot;.&quot;</span>), object[first])</span><br><span class="line">    : object[first];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>接着之前那一段 <code>函数嵌套</code> 的代码，这一段我觉得简单许多，至少不会在一开始就比较懵逼，这里需要了解的知识主要有以下几个:</p><ol><li>默认参数</li><li>Array.prototype.map</li><li>箭头函数</li><li>扩展运算符</li></ol><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数没什么好说的，详情看<a href="http://es6.ruanyifeng.com/#docs/function" title="ES6 函数的扩展">ES6 函数的扩展</a></p><h3 id="Array-proptotype-map"><a href="#Array-proptotype-map" class="headerlink" title="Array.proptotype.map"></a>Array.proptotype.map</h3><p><code>Array.prototype.map</code>，参数为函数，函数的参数为数组中的一个值，对数组的每一个值执行一个操作，并把需要的值 return 出来，每一项 return 出来的值构成一个新的数组，不改变原数组。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数这里也没有用到特殊的操作，与上一节一致 （</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>主要是数组的解构赋值以及扩展运算符的结合。</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h3><p>第一行代码还是比较好理解的，平常也用的比较多，即提取出对象对应 key 的 value，用 es5 重写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">key, object</span>) </span>&#123;</span><br><span class="line">  key = key === <span class="literal">undefined</span> ? <span class="string">&quot;&quot;</span> : key;</span><br><span class="line">  object = object || &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> object[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 es6 的写法清晰很多，<strong>默认参数可以让代码阅读更加明了，可以一目了然的看出哪些参数必须传，哪些参数可以不传，不需要查看函数内部，除此之外，还可以便于后期的迭代，如果之后不需要这个参数了，在对外接口中彻底拿掉这个函数，也不会导致不可用的问题出现。对于是否设置默认参数，要根据当前实际情况来看，如果参数有被遗漏的情况，则最好加上默认参数。</strong></p><h3 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h3><p>作用：将一个由对象组成的数组中的每一项(<code>object</code>)中对应的(<code>field</code>)取出，并组成一个新的数组，需要注意的一点，对于数组中某一项没有对应的 key 的时候，不会跳过而是得到<code>undefined</code>，即长度始终保持与对象数组一致。</p><p>举个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objs = [&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">c</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">pluck(key, objs); <span class="comment">// [1, undefined, 3]</span></span><br></pre></td></tr></table></figure><h3 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h3><p>与第二行形式结构一致，唯一不同的是 map 内参数函数的返回值。因此只需了解第四行代码即可。</p><h3 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h3><p>首先要注意的就是参数的命名，从<code>pick</code>中的<code>field</code>变为了<code>fields</code>，从函数体可以了解到该函数的功能： <strong>采用递归的形式，取得对象更深层对象的属性值</strong></p><p>用一个例子就很好解释:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个具有多重对象嵌套的对象</span></span><br><span class="line"><span class="keyword">let</span> example = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="string">&quot;a.b.c&quot;</span>; <span class="comment">// 即点操作符，取出c的值</span></span><br><span class="line">deepPluck(keys, example); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析代码的过程就是一个拆解代码的过程，将一个看似复杂的代码段逐步拆解，分解成一个个的小的易懂的片段，最后将其组合即可。分析后最好再自己实现一遍以加深印象。</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; pick = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;field = &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;, object = &amp;#123;&amp;#125;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; object[field];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; pluck = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;field, array&lt;/span&gt;) =&amp;gt;&lt;/span&gt; array.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;object&lt;/span&gt; =&amp;gt;&lt;/span&gt; pick(field, object));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; deepPluck = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;field, array&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  array.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;object&lt;/span&gt; =&amp;gt;&lt;/span&gt; deepPick(field, object));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; deepPick = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;fields, object = &amp;#123;&amp;#125;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [first, ...remaining] = fields.split(&lt;span class=&quot;string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; remaining.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ? deepPick(remaining.join(&lt;span class=&quot;string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;), object[first])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : object[first];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="es6" scheme="https://wingsico.github.io/tags/es6/"/>
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="函数式" scheme="https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代码片段理解(1)</title>
    <link href="https://wingsico.github.io/2018/03/13/codes-understanding-1/"/>
    <id>https://wingsico.github.io/2018/03/13/codes-understanding-1/</id>
    <published>2018-03-13T14:57:18.000Z</published>
    <updated>2020-12-07T05:44:32.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">arg</span> =&gt;</span></span><br><span class="line">  fns.reduce(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在学习 react 过程中碰到这样的一段代码，勉强能知道这是一段函数式的代码，并且配合 es6 的箭头函数以及扩展运算符组合而成的，但最初看到这段代码的时候还是把我难住了，主要问题有三个：</p><ol><li>两个箭头函数写法</li><li>函数作为参数传递</li><li><code>Array.prototype.reduce</code> 用法</li></ol><h3 id="gt-gt-console-log-1"><a href="#gt-gt-console-log-1" class="headerlink" title="() =&gt; () =&gt; console.log(1)"></a>() =&gt; () =&gt; console.log(1)</h3><p>这个不难理解，箭头函数可以省略大括号，则箭头后跟着的就是其返回值，在这里他的返回值就是一个函数，<strong>这里也就是一个函数式编程的思想，函数作为一等公民，和其他类型的值用法可以一致</strong>。用 es5 重写一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">test(); <span class="comment">// 返回: function () &#123;console.log(1)&#125;</span></span><br><span class="line">test()(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="fn-gt-fn-‘我被参数执行了’"><a href="#fn-gt-fn-‘我被参数执行了’" class="headerlink" title="(fn) =&gt; fn(‘我被参数执行了’)"></a>(fn) =&gt; fn(‘我被参数执行了’)</h3><p>这个也比较好理解，根据第一点，函数可以作为返回值，也能作为参数，用一个简单的例子表示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">text</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(text)(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">&quot;我被参数执行了&quot;</span>;</span><br><span class="line">    fn(text);</span><br><span class="line">  &#125;)(); <span class="comment">// 打印出: 我被参数执行了</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p>至于<code>reduce</code>，之前对他的了解只有是<strong>累加器，把数组前面的值与目前的值进行运算，并作为一个值与数组的下一项的值进行运算</strong>，是从这样一个例子得到的认知:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>对 reduce 有一个模糊的认识，且不清楚他拥有的参数及其含义。查阅相关资料后，了解了： <strong><code>reduce</code> 共有两个参数，第一个参数为<code>callback</code>，即回调函数，用于对数组内的值进行操作，且必须有返回值;第二个参数为<code>initialValue</code>，是一个可选的参数，即初始值，即第一个 pre 的值初始化，如果没有设置这个参数，则 pre 默认为第一个数组的值，需要注意的是，初始值的类型决定了最后得到的结果的类型，这两者是保持一致的</strong></p><p>拿上面的那个例子来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际执行过程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. pre === 0, cur === 1</span></span><br><span class="line"><span class="comment">        2. pre === 0 + 1, cur === 2</span></span><br><span class="line"><span class="comment">        3. pre === 0 + 1 + 2, cur === 3</span></span><br><span class="line"><span class="comment">        4. pre === 0 + 1 + 2 + 3, cur === &quot;&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 比数组的长度多执行一次</span></span><br><span class="line"><span class="comment">// 若没有设置初始值，则和数组的长度的执行次数一致</span></span><br></pre></td></tr></table></figure><p>这个也很好理解，将前面 return 的值给下一次使用，但是，为了理解我们最开始给出的那段代码，这个值就是一个问题，这个也同样是和第一点和第二点一样, 甚至是第一点和第二点的结合，函数式编程思想，函数作为参数传递进来，又作为返回值给下一次使用。 <strong>这里只用到第二点，函数作为参数传递。</strong> 至此，解决了三个问题，为了读懂这一段代码，需要把这三个知识串在一起使用。</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>首先，要理解第一个参数<code>fns</code>，从参数的命名上看，我们可以知道<code>fns</code>应该表示成数组，然后需要注意的是：<strong>传递的参数不应该以数组的形式传递（这也是我一开始遇到的问题，并且困扰到最后，也是对扩展运算符的了解不够或者误解），而应该以多个参数的形式传递。具体详情查看<code>es6 数组的扩展</code></strong> 再者是连续的两个双箭头，<code>() =&gt; ... =&gt; ...</code>意味着他是一个会返回函数的函数，第一次调用的结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg =&gt; fns.reduce(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br></pre></td></tr></table></figure><p>通过对<code>reduce</code>的理解，<code>composed</code>为数组的前一个 return 的值(在 arg 缺省的情况下，数组的第一项作为 composed)，<code>cur</code>为当前的值。</p><p>注意这里对<strong>值</strong>的定义，对于 reduce 来说，值可以是任何一种类型（当没有初始值限制的时候），当然也包括<strong>函数</strong>，对于我们这一段代码来说，当初始值缺省时，第一项的返回值可以不为函数，最后一项的返回值也可以不为函数，也可以没有返回值，但中间部分的返回值必须为一个函数，由<code>f(composed)</code>可以了解到这一点；</p><p>当初始值存在时，则从第一项到倒数第二项的参数的返回值必须为函数（因为第一项需要接受初始值作为参数的传递）。</p><p>之前还是没看懂，现在终于了解了，对于这个代码，每一个参数必须为函数，且均要有参数（如果没有给 arg 赋值的话，第一个可以没有参数），这个函数的返回值与参数 <code>arg</code> 有关，arg 是一直存在的，之前没搞懂这一点，就算调用时不赋值，也为 <code>undefined</code>，因此第一个 <code>pre</code> 永远为 <code>undefined</code>（除非你给 arg 赋值），且除了最后一个函数外，均必须要有返回值，若最后一个函数没有返回值，则整体就没有返回值。 由此，可以得到这个<code>compose</code>函数的用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="function">() =&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> last = <span class="function"><span class="params">b</span> =&gt;</span> <span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">let</span> result = compose(first, second, last)(); <span class="comment">// 打印出 2，不是返回值为2</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// undefined</span></span><br><span class="line">last = <span class="function"><span class="params">b</span> =&gt;</span> b + <span class="number">1</span>;</span><br><span class="line">result = compose(first, second, last)(); <span class="comment">// 返回值为3</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last(second(first())); <span class="comment">// 返回值为2</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，终于搞明白了<code>compose</code>函数的作用，就是为了以一个简明的方式实现函数的嵌套，即<strong>组合嵌套函数</strong>，有多个参数，实参为函数的形式存在，其返回值也为函数，即组合之后的函数。</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; compose = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;...fns&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;arg&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fns.reduce(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;composed, f&lt;/span&gt;) =&amp;gt;&lt;/span&gt; f(composed), arg);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="es6" scheme="https://wingsico.github.io/tags/es6/"/>
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="函数式" scheme="https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[nginx] 服务器无法访问 + 502 bad gateway</title>
    <link href="https://wingsico.github.io/2018/01/13/nginx-502/"/>
    <id>https://wingsico.github.io/2018/01/13/nginx-502/</id>
    <published>2018-01-13T01:38:19.000Z</published>
    <updated>2020-12-07T05:44:32.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在腾讯云制作镜像的时候强制关闭了服务器，后面外网就访问不了服务器了。记录一下解决过程</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>一开始以为是文件丢失了，后面用 vnc 上去看了之后文件都还在，然后我就又重启了好几遍，网页还是访问不了，于是我先放在一边。 第二天再看了一下，发现二级域名下的资源可以访问，但主域名的无法访问，显示 502 bad gateway。 于是觉得应该是 nginx 的问题，试图重启 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure><p>失败，报了个错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job <span class="keyword">for</span> nginx.service invalid.</span><br></pre></td></tr></table></figure><p>难道是没有开启？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>。。报了个更长的错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job <span class="keyword">for</span> nginx.service failed because the control process exited with error code. See <span class="string">&quot;systemctl status nginx.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>根据它的提示我试了一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx.service</span><br></pre></td></tr></table></figure><p>得到如下的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">● nginx.service - The nginx HTTP and reverse proxy server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Fri 2018-01-12 20:33:08 CST; 27s ago</span><br><span class="line">  Process: 2702 ExecStart=/usr/sbin/nginx (code=exited, status=1/FAILURE)</span><br><span class="line">  Process: 2698 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2697 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">Jan 12 20:33:06 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to [::]:80 failed (98: ...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (9...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to [::]:80 failed (98: ...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (9...e)</span><br><span class="line">Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] <span class="built_in">bind</span>() to [::]:80 failed (98: ...e)</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos nginx[2702]: nginx: [emerg] still could not <span class="built_in">bind</span>()</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: nginx.service: control process exited, code=e...s=1</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: Failed to start The nginx HTTP and reverse pr...er.</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: Unit nginx.service entered failed state.</span><br><span class="line">Jan 12 20:33:08 VM_48_13_centos systemd[1]: nginx.service failed.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><p>不是很看得懂，看到一堆 failed 和 disabled. 先看一下 nginx 的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep  nginx</span><br><span class="line">root      2516     1  0 Jan12 ?        00:00:00 nginx: master process nginx</span><br><span class="line">nginx     2517  2516  0 Jan12 ?        00:00:00 nginx: worker process</span><br><span class="line">root      5308  4831  0 09:04 pts/1    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><p>把 nginx 进程关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -9 nginx</span><br></pre></td></tr></table></figure><p>再次启动 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>嗯，没有消息就是最好的消息，没有报错了，启动成功。但这个时候主域名还是访问不了，想到主域名上面放的是博客，博客是 wordpress 驱动的，用的 php，想到可能是 php 挂死了，那重启一下 php-fpm 吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">killall php-fpm</span><br><span class="line">./opt/php56/sbin/php-fpm</span><br></pre></td></tr></table></figure><p>再访问一下主域名，ok，博客成功显示。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在腾讯云制作镜像的时候强制关闭了服务器，后面外网就访问不了服务器了。记录一下解决过程&lt;/p&gt;</summary>
    
    
    
    <category term="疑难杂症" scheme="https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="linux" scheme="https://wingsico.github.io/tags/linux/"/>
    
    <category term="nginx" scheme="https://wingsico.github.io/tags/nginx/"/>
    
    <category term="服务器" scheme="https://wingsico.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>[vue-cli] 解决 npm run dev 之后在某些浏览器上一片空白</title>
    <link href="https://wingsico.github.io/2018/01/05/vue-cli-whitepage/"/>
    <id>https://wingsico.github.io/2018/01/05/vue-cli-whitepage/</id>
    <published>2018-01-05T08:02:33.000Z</published>
    <updated>2020-12-07T05:44:32.072Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用开发模式启动项目后，在同一局域网通过手机连接项目，在一些手机厂商自带浏览器上产生空白页面，渲染失败。</p><a id="more"></a><h2 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h2><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p>在 vue-cli 中，这可能是我们用的最频繁的命令了，来看一下<code>package.json</code> 里:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node build/build.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>主要看 <code>dev</code> 这个属性的值:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</span><br></pre></td></tr></table></figure><p>来解读一下这一行命令</p><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>找到 <code>node_modules</code> 目录下的 <code>webpack-dev-server</code>，看它的<code>readme</code> 中可以得到以下信息：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Either method will start a server instance and begin listening for connections from <span class="code">`localhost`</span> on port <span class="code">`8080`</span>.</span><br><span class="line"></span><br><span class="line">webpack-dev-server is configured by default to support live-reload of files as you edit your assets while the server is running.</span><br></pre></td></tr></table></figure><p>意思是，输入命令 <code>webpack-dev-server</code> 就会在 <code>8080</code> 端口启动一个本地服务器，支持热重载，也就是你修改了静态文件内容无需刷新，页面直接更新的意思。</p><p>那后面那些参数什么意思呢？</p><p>首先是 <code>--inline</code>，这是支持自动刷新的一种模式，还有另一种是<code>--iframe</code>。</p><p>在 <code>iframe</code> 模式下：页面是嵌套在一个 <code>iframe</code> 下的，在代码发生改动的时候，这个 <code>iframe</code> 会重新加载；</p><p>在 inline 模式下：一个小型的 <code>webpack-dev-server</code> 客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。</p><p>不过 <strong>Iframe mode</strong> 和 <strong>Inline mode</strong> 最后达到的效果都是一样的，都是监听文件的变化，然后再将编译后的文件推送到前端，完成页面的 reload 的。</p><p>对于 <code>--process</code>，是用于显示打包的进度，如果我们去掉它，或者换成 <code>--quiet</code>，就不会出现那些百分比的东西。</p><p>最后 <code>--config</code>，<code>config</code> 后面跟着一串路径，指定的是 webpack 配置文件的路径。</p><p>ok，介绍完了，进入今天的正题</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>执行 <code>npm run dev</code> 之后，pc 端正常访问，手机局域网访问一片空白，无法正常访问，但是 build 之后可以正常访问，于是开启了 qq 浏览器的调试，发现有这样一个报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Use of const <span class="keyword">in</span> strict mode</span><br></pre></td></tr></table></figure><p>发现是 es6 的语法不兼容，但一想到 dev 和 pro 模式的不同表现，那应该是就 babel 在 dev 与 pro 之间的配置不同。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>进入 <code>webpack.base.conf.js</code> 里面，找到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    include: [resolve(<span class="string">&#x27;src&#x27;</span>), resolve(<span class="string">&#x27;test&#x27;</span>)]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>将其改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    include: [resolve(<span class="string">&#x27;src&#x27;</span>), resolve(<span class="string">&#x27;test&#x27;</span>), resolve(<span class="string">&#x27;node_modules/webpack-dev-server/client&#x27;</span>)]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再将<code>.babelrc</code>添加一行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;es2015&quot;</span>, &#123;<span class="string">&quot;modules&quot;</span>: <span class="literal">false</span>&#125;],</span><br></pre></td></tr></table></figure><p>重新启动<code>npm run dev</code> 再用手机访问，OK，成功了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用开发模式启动项目后，在同一局域网通过手机连接项目，在一些手机厂商自带浏览器上产生空白页面，渲染失败。&lt;/p&gt;</summary>
    
    
    
    <category term="疑难杂症" scheme="https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="vue" scheme="https://wingsico.github.io/tags/vue/"/>
    
    <category term="webpack" scheme="https://wingsico.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之图的应用</title>
    <link href="https://wingsico.github.io/2018/01/02/graph/"/>
    <id>https://wingsico.github.io/2018/01/02/graph/</id>
    <published>2018-01-02T06:16:54.000Z</published>
    <updated>2020-12-07T05:44:32.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在算法图解里看见了关于最短路径的求解，对于无权值的图，我们可以采用<code>广度优先搜索</code>算法，找出的是经过最少的边的路径，而对于含有<code>边权</code>的图，若要找到其<code>最短路径</code>（更好的称为<code>最快路径</code>），可采用另一种算法，即<code>狄克斯特拉算法</code></p><a id="more"></a><h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><p>据我所知，狄克斯特拉算法<code>只适用于有向无环图</code>，这是为什么呢？ 假设有一个环，<code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> -&gt; <code>B</code> -&gt; <code>A</code>，这意味着你可以从一结点出发，走一圈之后又回到了这个结点，假设在这个带环的图内，你要找出从起点到终点的最短路径，绕环前行是否合理呢？</p><p>你可以选择避开环，也可以选择包含环的路径。这两条路径都可以到达终点，但环增加了权重，所以绕环的路径不可能是最短的路径。对于无向图，意味着两个节点互相指着对方，其实就是环，在无向图中，每一条边的都是环。所以狄克斯特拉算法只适用于<code>有向无环图</code> <code>狄克斯特拉算法</code>能否找出含有负权值的边呢？</p><p>答案是不能:(，因为在<code>狄克斯特拉算法</code>中，对于处理过的结点，就意味着没有前往该结点的更快的路径，但若含有负权值的边，你知道如果包含负权值的话，会更快到达该结点，但是该算法不会再用负权值去处理这个结点，因此<strong>该算法只适用于不含有负权值的图</strong>。 狄克斯特拉算法的核心思想为:</p><ol><li>找出“最便宜的结点”，即可在最短时间内到达的结点</li><li>更新该结点的邻居，检查是或否有前往他们的更短路径，如果有，就更新其开销</li><li>重复这个过程，知道对图中的每个结点都这样做了</li><li>计算最终路径</li></ol><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>由上面的一些知识可得，狄克斯特拉算法适用于<code>有向无环图</code>和<code>不存在负权值的图</code>。但是实验给了一张<code>权值为正的无环图</code>，这就有一些懵逼了，那么我还如何使用<code>狄克斯特拉算法</code>去解决一个无向图呢？ 、</p><p>为了解决这个问题，先进入实验，从实验中得到解决的方法。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个大学校内交通咨询系统，能让旅客咨询从任一楼到其余所有楼之间的最短路径。</p><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>输入：输入图的顶点数，以及边数。 输出：一幢楼到其他楼之间的最短路径。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>1.建立交通网络图的存储结构。 2.解决单源最短路径问题。</p><h3 id="实验分析与设计"><a href="#实验分析与设计" class="headerlink" title="实验分析与设计"></a>实验分析与设计</h3><p>由实验图我们可以看出，这是一个<code>不含有负权值边的无向图</code>，由我们有向图<code>狄克斯特拉算法</code>可以延伸出一种处理无向图的最短路径的算法。 首先，我们需要先建立一个图结构，这个图应该包含以下一些东西：</p><ul><li>图的顶点数</li><li>图的边数</li></ul><p>还有什么呢？因为我们处理的是<code>单源最短路径</code>，所以需要存储<strong>源点到各个点的距离</strong>；除此之外，我们需要保存一条边的顶点之间的联系，我们使用一个<code>邻接矩阵</code>来存储这之间的联系；还有就是，由算法的原理可以知道，到每一个点的最短路径会在每一轮就确定下来，因此我们需要存储已经确定了最短路径的结点。</p><p>综上，我们可以知道，这个图结构应该包含完整的以下内容：</p><ul><li>图的顶点数</li><li>图的边数</li><li>源点到各个顶点的初始路程</li><li>顶点与顶点之间的联系，即边权值</li><li>已经确定最短路径的结点</li></ul><p>因此，我们使用一个<code>结构体</code>作为图的结构，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_node_count = <span class="number">20</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Type AdjacencyList[max_node_count][max_node_count]; <span class="comment">// 邻接矩阵存储顶点与顶点之间的联系</span></span><br><span class="line">    Type distances[max_node_count]; <span class="comment">// distances数组，1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    Type shortPaths[max_node_count]; <span class="comment">// shortPaths数组，存放已经确定最短路径的结点</span></span><br><span class="line">    Type vertex = <span class="number">0</span>; <span class="comment">// 图的顶点数</span></span><br><span class="line">    Type edge = <span class="number">0</span>; <span class="comment">// 图的边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><p>采用邻接矩阵来存储顶点之间的联系。 根据实验要求，我们需要先初始化这个图，也就是初始化部分邻接矩阵以及他的顶点数和边数。容易知道的是，每个顶点和他自身的距离为 0，因此，在初始化的时候就可以直接设为 0，另外，对于其他的点，我们先初始化为无穷大的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的顶点数和边数: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g.vertex &gt;&gt; g.edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.edge; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = <span class="number">0</span>; <span class="comment">// 顶点与自身距离为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = inf; <span class="comment">// 某个顶点与其余顶点距离默认初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">之后我们便要读入对应的顶点和边权了，对于有向图，其是有固定的指向的，因此，在邻接矩阵中，若无环，且`AdjacencyList[<span class="number">3</span>][<span class="number">4</span>] ≠ ∞`，则`AdjacencyList[<span class="number">4</span>][<span class="number">3</span>] = ∞`，是一个对立的关系，那么对于无向图呢？ 其实只要让`AdjacencyList[<span class="number">3</span>][<span class="number">4</span>] = AdjacencyList[<span class="number">4</span>][<span class="number">3</span>]`即可，这样，即可使无向图也可以使用`狄克斯特拉算法`来寻找最快路径。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">status getGraph (Graph &amp;g) &#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// 边的左顶点</span></span><br><span class="line">    <span class="keyword">int</span> v2; <span class="comment">// 边的右顶点</span></span><br><span class="line">    <span class="keyword">int</span> e; <span class="comment">// 边的权值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.edge; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;</span>, i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e;</span><br><span class="line">        g.AdjacencyList[v1][v2] = e; <span class="comment">// 填入邻接矩阵</span></span><br><span class="line">        g.AdjacencyList[v2][v1] = e; <span class="comment">// 无向图处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还要初始化两个表，一个是初始路径的表，还有一个就是已经确定最短路径的表。 初始路径的表，即源点到各个点的初始路径，有些点不与源点直接相连，即可设置为无穷大；对于与源点直接相连的点，可以查看邻接矩阵中关于源点的顶点之间的联系，然后填入表内。 已经确定最短路径的表，在最开始只有源点是确定的，其他点均尚未确定，因此，初始化也非常简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dis数组，表示1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.distances[i] = g.AdjacencyList[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line">    <span class="comment">// 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.shortPaths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.shortPaths[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要做的就是依据邻接矩阵来不断更新这两个表的数据来计算所有点距离源点的最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min; <span class="comment">// 存储最小值</span></span><br><span class="line">    <span class="keyword">int</span> vmin; <span class="comment">// 存储最小值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex - <span class="number">1</span>; ++i) &#123; <span class="comment">// 最后一个点无需比较</span></span><br><span class="line">        <span class="comment">// 找到距离号顶点最近的顶点</span></span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.vertex; ++j) &#123; <span class="comment">// 遍历各个顶点，找出距离最近的未确定的结点</span></span><br><span class="line">            <span class="keyword">if</span> (g.shortPaths[j] == <span class="number">0</span> &amp;&amp; g.distances[j] &lt; min) &#123;</span><br><span class="line">                min = g.distances[j];</span><br><span class="line">                vmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g.shortPaths[vmin] = <span class="number">1</span>; <span class="comment">// 确定该顶点找到最小路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= g.vertex; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.AdjacencyList[vmin][k] &lt; inf) &#123; <span class="comment">// 若两个顶点直接相邻</span></span><br><span class="line">                <span class="keyword">if</span> (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; <span class="comment">// 若该距离更小，更新最短路径的数据</span></span><br><span class="line">                    g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如注释。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_node_count = <span class="number">20</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">999999</span>; <span class="comment">// 存储一个可以当做相对无穷的值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Type AdjacencyList[max_node_count][max_node_count]; <span class="comment">// 邻接矩阵存储顶点与顶点之间的联系</span></span><br><span class="line">    Type distances[max_node_count]; <span class="comment">// distances数组，1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    Type shortPaths[max_node_count]; <span class="comment">// shortPaths数组，存放已经确定最短路径的结点</span></span><br><span class="line">    Type vertex = <span class="number">0</span>; <span class="comment">// 图的顶点数</span></span><br><span class="line">    Type edge = <span class="number">0</span>; <span class="comment">// 图的边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">const</span> status ok = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> status err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化邻接表</span></span><br><span class="line"><span class="function">status <span class="title">getGraph</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 读入边</span></span><br><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化distances数组</span></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 计算得到所有节点确定最短路径长度的数组</span></span><br><span class="line"><span class="function">status <span class="title">displayClosestDistances</span> <span class="params">(Graph g)</span></span>; <span class="comment">// 输出最终得到到各个结点的最小路径数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DIJKSTRA 算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph traffic; <span class="comment">// 定义一个Graph变量</span></span><br><span class="line">    initGraph(traffic); <span class="comment">// 初始化图的邻接顺序表</span></span><br><span class="line">    getGraph(traffic); <span class="comment">// 读入边的相关信息</span></span><br><span class="line">    initDistances(traffic); <span class="comment">// 初始化各个顶点距离源点的路径顺序表</span></span><br><span class="line">    initShortPaths(traffic); <span class="comment">// 初始化各个已经确定最短顶点的顶点顺序表</span></span><br><span class="line">    makeClosestDistances(traffic);</span><br><span class="line">    displayClosestDistances(traffic);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *****************  函数库  *********************</span></span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的顶点数和边数: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g.vertex &gt;&gt; g.edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.edge; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = <span class="number">0</span>; <span class="comment">// 顶点与自身的距离为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = inf; <span class="comment">// 某个顶点与其余顶点距离默认初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">getGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// 边的左顶点</span></span><br><span class="line">    <span class="keyword">int</span> v2; <span class="comment">// 边的右顶点</span></span><br><span class="line">    <span class="keyword">int</span> e; <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.edge; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;</span>, i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e;</span><br><span class="line">        g.AdjacencyList[v1][v2] = e; <span class="comment">// 填入邻接矩阵</span></span><br><span class="line">        g.AdjacencyList[v2][v1] = e; <span class="comment">// 无向图处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dis数组，表示1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.distances[i] = g.AdjacencyList[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line">    <span class="comment">// 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.shortPaths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.shortPaths[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">displayClosestDistances</span> <span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出各个顶点的距离1号顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号顶点距离源点(1号)的最短路径的长度为 %d\n&quot;</span>, i, g.distances[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min; <span class="comment">// 存储最小值</span></span><br><span class="line">    <span class="keyword">int</span> vmin; <span class="comment">// 存储最小值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex - <span class="number">1</span>; ++i) &#123; <span class="comment">// 最后一个点无需比较</span></span><br><span class="line">        <span class="comment">// 找到距离号顶点最近的顶点</span></span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.vertex; ++j) &#123; <span class="comment">// 遍历各个顶点，找出距离最近的未确定的结点</span></span><br><span class="line">            <span class="keyword">if</span> (g.shortPaths[j] == <span class="number">0</span> &amp;&amp; g.distances[j] &lt; min) &#123;</span><br><span class="line">                min = g.distances[j];</span><br><span class="line">                vmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.shortPaths[vmin] = <span class="number">1</span>; <span class="comment">// 确定该顶点找到最小路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= g.vertex; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.AdjacencyList[vmin][k] &lt; inf) &#123; <span class="comment">// 若两个顶点直接相邻</span></span><br><span class="line">                <span class="keyword">if</span> (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; <span class="comment">// 若该距离更小，更新最短路径的数据</span></span><br><span class="line">                    g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/Users/wingsico/CLionProjects/dijkstra/cmake-build-debug/dijkstra</span><br><span class="line">输入图的顶点数和边数: 5 7</span><br><span class="line">输入第1条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 2 180</span><br><span class="line">输入第2条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 3 100</span><br><span class="line">输入第3条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 4 150</span><br><span class="line">输入第4条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 4 50</span><br><span class="line">输入第5条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 5 130</span><br><span class="line">输入第6条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 3 4 80</span><br><span class="line">输入第7条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 4 5 120</span><br><span class="line">1号顶点距离源点(1号)的最短路径的长度为 0</span><br><span class="line">2号顶点距离源点(1号)的最短路径的长度为 180</span><br><span class="line">3号顶点距离源点(1号)的最短路径的长度为 100</span><br><span class="line">4号顶点距离源点(1号)的最短路径的长度为 150</span><br><span class="line">5号顶点距离源点(1号)的最短路径的长度为 270</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个代码上还有可以改进的地方，这个算法的时间复杂度为<code>O(N^2)</code>，每次找到离源点最近的定点的时间复杂度是 O(N)(一个 for 循环遍历所有结点)，这里我们可以使用<code>堆</code>来优化，可以使这一部分的时间复杂度降低到<code>O(logN)</code>。</p><p>另外，对于稀疏图来说，我们可以使用<code>邻接表法</code>代替邻接矩阵，使得整个时间复杂度优化到<code>O((M+N)logN)</code>，但没有仔细研究，所以也不了了之。 对于选做题，有一定难度，不过了解<code>费洛伊德算法</code>即可解决，即<code>多源最短路径的算法</code>，其核心代码只有五行，利用了动态规划的思想，实现起来很简单，但由于时间有限，加之期末临近，只好作罢。 Over。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在算法图解里看见了关于最短路径的求解，对于无权值的图，我们可以采用&lt;code&gt;广度优先搜索&lt;/code&gt;算法，找出的是经过最少的边的路径，而对于含有&lt;code&gt;边权&lt;/code&gt;的图，若要找到其&lt;code&gt;最短路径&lt;/code&gt;（更好的称为&lt;code&gt;最快路径&lt;/code&gt;），可采用另一种算法，即&lt;code&gt;狄克斯特拉算法&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="数据结构" scheme="https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c++" scheme="https://wingsico.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的HTML —— 规范篇</title>
    <link href="https://wingsico.github.io/2017/12/24/unknowhtml-standard/"/>
    <id>https://wingsico.github.io/2017/12/24/unknowhtml-standard/</id>
    <published>2017-12-24T15:45:53.000Z</published>
    <updated>2020-12-07T05:44:32.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="资源引入"><a href="#资源引入" class="headerlink" title="资源引入"></a>资源引入</h2><ol><li>移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。这是因为使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h2><ol><li><p>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度</p></li><li><p>结构顺序和视觉顺序基本保持一致，按照从上至下、从左到右的视觉顺序书写 HTML 结构。有时为了便于搜索引擎抓取，也会将重要内容在 HTML 结构顺序上提前</p></li><li><p>结构、表现、行为三者分离，避免内联</p></li><li><p>每一个块级元素都另起一行，每一行都使用 Tab 缩进对齐（head 和 body 的子元素不需要缩进）。删除冗余的行尾空格</p></li><li><p>对于内容较为简单的表格，建议将 tr 写成单行</p></li><li><p>可以在大的模块之间用空行隔开，使模块更清晰</p></li></ol><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>浏览器会根据标签的语义给定一个默认的样式。判断网页标签语义化是否良好的一个简单方法：去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</p><ol><li><p>尽可能少地使用无语义标签 span 和 div</p></li><li><p>在语义不明显，既可以使用 p 也可以使用 div 的地方，尽量用 p</p></li><li><p>在既可以使用 div 也可以使用 section 的地方，尽量用 section</p></li><li><p>不要使用纯样式标签，如 b、u 等，而改用 CSS 设置</p></li></ol><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol><li>同一页面，应避免使用相同的 name 与 id。因为 IE7-浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心</li></ol><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ol><li><p>标签名小写</p></li><li><p>无需自闭合的标签，不要自闭合</p></li><li><p>对于<code>html5</code>中规范中允许省略的闭合标签，不要省略</p></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li><p>属性和值全部小写</p></li><li><p>属性值必须用双引号包围</p></li><li><p>布尔类型的属性，建议不添加属性值</p></li><li><p>自定义属性建议以 xxx- 为前缀，推荐使用 data-</p></li><li><p>可以省略 style 标签和 script 标签的 type 属性</p></li></ol><h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><p>HTML 属性应该按照特定的顺序出现以保证易读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">class</span><br><span class="line">name</span><br><span class="line">data-xxx</span><br><span class="line">src, for, type, href</span><br><span class="line">title, alt</span><br><span class="line">aria-xxx, role</span><br></pre></td></tr></table></figure><h2 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ol><li><p>禁止 img 的 src 取值为空，否则会导致部分浏览器重新加载一次当前页面</p></li><li><p>为图片添加 alt 属性，提高图片加载失败时的用户体验</p></li><li><p>避免为 img 添加不必要的 title 属性，多余的 title 影响看图体验，并且增加了页面尺寸</p></li><li><p>为图片添加 width 和 height 属性，以避免页面抖动</p></li><li><p>有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现</p></li><li><p>产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载, 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 css 背景图实现</p></li></ol><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ol><li>有文本标题的控件使用 label 标签将其与其标题相关联。最好将控件置于 label 内，以减少不必要的 id</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;label</span><br><span class="line">  &gt;<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;confirm&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 我已确认上述条款&lt;/label</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 button 元素时必须指明 type 属性值。因为 button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性，能获得友好的输入体验</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于 HTML 的最佳实践的相关规范</summary>
    
    
    
    <category term="技术杂文" scheme="https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"/>
    
    
    <category term="html" scheme="https://wingsico.github.io/tags/html/"/>
    
    <category term="你所不知道的HTML" scheme="https://wingsico.github.io/tags/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84HTML/"/>
    
  </entry>
  
  <entry>
    <title>vue build 过程中遇到的坑</title>
    <link href="https://wingsico.github.io/2017/12/23/vue-build-kengs/"/>
    <id>https://wingsico.github.io/2017/12/23/vue-build-kengs/</id>
    <published>2017-12-23T09:23:09.000Z</published>
    <updated>2020-12-07T05:44:32.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一号坑-npm-install-已解决"><a href="#一号坑-npm-install-已解决" class="headerlink" title="一号坑[npm install] - 已解决"></a>一号坑[npm install] - 已解决</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>github 项目迁移至 coding，本地切换到另一个文件夹，重新 <code>npm install</code> 失败。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><code>npm install</code>: 时间长，且结束后报错</p><p><code>yarn</code>: 一直处于安装状态，但目录下生成了 <code>node_modules</code>，尝试 <code>npm run build</code> 后报错。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>cnpm</code> 解决（ <code>cnpm</code> 真好用 _(:з ゝ ∠)_）</p><h2 id="二号坑-static-文件-404-已解决"><a href="#二号坑-static-文件-404-已解决" class="headerlink" title="二号坑[static 文件 404] - 已解决"></a>二号坑[static 文件 404] - 已解决</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>build 成功之后，得放在服务器上跑，build 之后也有提示:</p><blockquote><p>Tip: built files are meant to be served over an HTTP server.<br>Opening index.html over file:// won’t work.</p></blockquote><p>于是，我便将文件夹上传服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ~/my-github/ncuniversity/gpa/gpa-static/dist xxx@xxx.xxx:/path/</span><br></pre></td></tr></table></figure><p>上传好后访问网站，控制台一堆 404 错误，而且加载的比较慢。</p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>看了一下资源请求的路径，竟然全是 <code>/static</code>，这就尴尬了，想了想本地跑没问题，应该是 <code>webpack</code> 打包的问题，于是重新看了一下<code>webpack</code>的配置文件 <code>config/index.js</code> 中，在 <code>build &#123;&#125;</code> 内，有一行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    assetsPublicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该就是这个了，使我的资源一直处于绝对路径下。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>将上面代码改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    assetsPublicPath: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样应该就能使资源处于相对路径下了~</p><p>重新 build 后发现问题解决。</p><h2 id="三号坑-请求-404-已解决"><a href="#三号坑-请求-404-已解决" class="headerlink" title="三号坑[请求 404] - 已解决"></a>三号坑[请求 404] - 已解决</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ol><li>发送请求，显示请求 404</li><li>请求跨域</li></ol><h3 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h3><p>本地为了解决跨域，使用了 proxy-table 去代理，然后请求的路径那里写的绝对路径:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> getUserInfo () &#123;</span><br><span class="line">    <span class="built_in">this</span>.$http(&#123;</span><br><span class="line">        url: <span class="regexp">/api/</span>common/<span class="string">&#x27; + this.user.username.value,</span></span><br><span class="line"><span class="string">        mothod: &#x27;</span>GET<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        timeout: 4000</span></span><br><span class="line"><span class="string">    &#125;).then(_ =&gt; ...)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>但是打包后 proxy-table 就会失效。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 nginx 服务器上配置反向代理，将请求本机服务器的请求转发到目标服务器上。具体可以参见 <code>nginx 反向代理</code>。</p><p>如果遇到跨域问题可以让后端配置 <code>CORS</code></p>]]></content>
    
    
    <summary type="html">记录 vue 进行生产环境构建时遇到的一些坑和解决办法</summary>
    
    
    
    <category term="疑难杂症" scheme="https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="javascript" scheme="https://wingsico.github.io/tags/javascript/"/>
    
    <category term="vue" scheme="https://wingsico.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>项目总结(一) —— 移动端适配</title>
    <link href="https://wingsico.github.io/2017/12/23/mobile-adaptation/"/>
    <id>https://wingsico.github.io/2017/12/23/mobile-adaptation/</id>
    <published>2017-12-22T17:07:04.000Z</published>
    <updated>2020-12-07T05:44:32.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>历经好多时间= =，终于完成了一个小项目，再次更新了一些我的移动端知识，之前总是对概念有些不清晰，先梳理一下。</p><a id="more"></a><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>CSS 像素(CSS Pixel)</p></blockquote><p>CSS 代码中的逻辑像素，是一个抽象的东西，实际并不存在。</p><blockquote><p>设备独立像素(Device Independent Pixel)</p></blockquote><p>与设备无关的逻辑像素，可以通过虚拟程序来设置，包含了 CSS 像素</p><blockquote><p>设备像素(Device Pixel)</p></blockquote><p>物理像素，设备能控制显示的最小单位，类似 1920 * 1080 像素分辨率这种的。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><blockquote><p>设备像素与设备独立像素</p></blockquote><p><strong>对于 PC 页面</strong>：在未缩放的情况下，<code>1设备像素 === 1设备独立像素</code>，若缩放为 200%时，可以说 <code>2设备像素 === 1设备独立像素</code>。 <strong>对于移动端页面</strong>： 根据设备不同有一些差异，其引起差异的原因主要在于一个被称之为<code>ppi(pixel per inc)</code>的东西。</p><blockquote><p>PPI</p></blockquote><p>从名字上就知道是 <code>每英寸设备有多少像素</code>，这里的像素指的是设备像素，即物理像素，其数值越高，每英寸设备里的像素就越高，画面也就越清晰。 计算方式为: <img src="http://images2015.cnblogs.com/blog/984702/201704/984702-20170412161418626-799396908.png" alt="PPI计算"> 像苹果的 Retina 屏的 ppi 就比较高，所以清晰度很高。 还有一个很重要的概念就是<code>dpr(device pixel ratio)</code></p><blockquote><p>DPR</p></blockquote><p>设备像素比，这个设备像素比就是<code>物理像素</code>与<code>独立像素</code>，独立像素之前说到，包含着<code>CSS像素</code>，所以 dpr 即提供了一个我们代码中的像素与设备实际像素之间的一个转换关系。 计算公式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpr = 设备像素 / 设备独立像素</span><br></pre></td></tr></table></figure><p>像苹果手机的 dpr 一般为 2，即意味着 1 长度的设备像素里有 2 长度的设备独立像素，换做面积来算的话就是 1 设备像素包含着 4 设备独立像素，即成平方关系，所以清晰明了，dpr 越高，屏幕清晰度也越高，与 ppi 有些相似，用一张图看看： <img src="http://images2015.cnblogs.com/blog/984702/201704/984702-20170412163741001-1502532540.png" alt="DPR"> 大概需要了解的就这些，我在实际运用中用到的也就如下几点：</p><ol><li>dpr</li><li>px</li><li>device-width (屏幕宽度)</li></ol><h3 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h3><p>对于 dpr，一般用于两个地方，一个是<code>字体大小</code>，一个是<code>背景图片大小</code> 对于字体，也是用 px 堆起来的，因此 dpr 也会影响到字体的显示，当 dpr 较大时，为了同比例显示字体大小，就会去检测其 dpr 的值，根据 dpr 的不同来设置不同比例的字体大小，可以用如下一段<code>sass</code>的混合宏来适配字体显示:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> font-dpr(<span class="variable">$font-size</span>) &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$font-size</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="selector-attr">[data-dpr=&quot;2&quot;]</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font-size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-attr">[data-dpr=&quot;3&quot;]</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font-size</span> * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个<code>data-dpr</code>，即根据 dpr 不同来应用不同的字体样式，此外，这里将传入的字体大小除以 2，这是因为一般设计给的视觉稿都是 iphone6 的二倍稿，因此，为了显示正常字体大小，将其标注的字体大小除以二，再根据 dpr 来适配字体大小。 移动端运用到图片几乎是必然的，一般设计师会给出两种图片，一种为@2x 图，一种为@3x 图，不过这个主要是用来出来高清屏下图片较为高清的显示，对于普通的安卓机，dpr 一直都是 1，意义不大，用普通的@2x 图即可达到高清的显示，但是对于 ios 系统，存在 dpr 为 2、dpr 为 3 的情况，为了图片的一个等比例缩放，我们根据 dpr 的不同来使用不同倍数的图片以达到与标准屏幕一致的感受。同样的，我们也可以使用<code>sass</code>的混合宏来适配背景图片：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> bg-image(<span class="variable">$url</span>) &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="variable">$url</span>+<span class="string">&quot;@2x.png&quot;</span>);</span><br><span class="line">  <span class="keyword">@media</span> (-webkit-min-device-pixel-ratio: <span class="number">3</span>), (min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="variable">$url</span>+<span class="string">&quot;@3x.png&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除这两点之外，我暂时没有用到 dpr 其他的使用方法。</p><h2 id="布局适配"><a href="#布局适配" class="headerlink" title="布局适配"></a>布局适配</h2><p>布局和适配其实我一直难以分辨这两个概念，我就把它罗列在一起吧。 为了达到想要的效果，我的历程如下：</p><ol><li>meta 设置 viewport -&gt; width=device-width…</li><li>rem 布局</li><li>flex-box</li><li>flexible.js</li><li>视口单位 vw,vh</li><li>calc 计算</li><li>calc + 视口单位</li><li>calc + 视口单位 + 媒体查询</li><li>百分比布局</li><li>删除 6、7、8, 9 重归 flexible</li><li>加上媒体查询，适配特殊机型，如 Nexus 5X</li></ol><p>妈耶心好累，布局适配改改改改好头疼，不过还好都解决了。</p><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  name=&quot;viewport&quot;</span><br><span class="line">  content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>这行代码作用是设置<code>理想视口</code>，什么是视口？什么又是理想视口，要说明这个，对于<code>viewport</code>就要讲很多了。 这里有一个链接，我觉得写的很好，很多内容都非常清晰的表达了出来: <a href="https://www.cnblogs.com/xiaohuochai/p/5496995.html">移动端之 viewport</a></p><h3 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h3><p><code>rem</code>、<code>px</code>、<code>em</code>均是常用的单位，他们都是相对长度单位，在不同的地方我们需要配合起来使用。</p><h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p><code>px(Pixel)</code> 是相对于屏幕分辨率而言的一个单位，一般我们对于 pc 均会使用<code>px</code>作为单位，同时，一些固定大小、长度的我们同样使用 px 作为单位，这个也是我们上面说到的 CSS 像素，包含在设备独立像素内。</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p><code>em</code>是一个相对与其父元素的字体大小的一个单位，举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    font-size: 18px;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">      font-size: 2em; // 18 * 2 = 36px</span><br><span class="line"><span class="css">      <span class="selector-class">.grandson</span> &#123;</span></span><br><span class="line">        font-size: 0.5em; // 36 * 0.5 = 18px</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个单位对于一整块整体变换有很好的效果，比如我们有一个按钮，当我们想要整体放大一个按钮的时候，不需要去改变每一个字体的大小，设置 em 之后可以只改变其父级元素的字体大小来达到整体缩放的效果。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>为了移动端而生的单位，同样是一个相对单位，与 em 不同的是，rem 是相对于 html 根元素的字体大小，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line">  html &#123;</span><br><span class="line">      font-size: 10px;</span><br><span class="line"><span class="css">      <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">          font-size: 2rem; // 10 * 2 = 20px</span><br><span class="line"><span class="css">          <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">              font-size： 4rem; // 10 * 4 = 40px</span><br><span class="line"><span class="css">              <span class="selector-class">.grandson</span> &#123;</span></span><br><span class="line">                  font-size： 1.6rem; // 10 * 1.6 = 16px</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这样一个单位，对于我们移动端上的适配来说，绝对是一大助力，我们可以使用 rem 来适配不同分辨率的屏幕。 现在假设我们有一张 750 的设计稿，我们把设计稿分成一百份，把每十份当做一个 1rem，即设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  font-size: 75px; // 750 / 100 * 10 = 75px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在需要一个 150*150 的 div 时，我们可以使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的屏幕不同的时候，我们只需动态的更改根元素的字体大小即可。那么如何动态更改根元素的字体大小呢？在 CSS3 有一个新增的<strong>媒体查询</strong>，可以帮我们检测设备相关信息并根据这些信息使用不同的样式。</p><h3 id="media-媒体查询"><a href="#media-媒体查询" class="headerlink" title="@media/媒体查询"></a>@media/媒体查询</h3><p>这里有相关的资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries">MDN 媒体查询</a> 上面只是介绍了一些概念的东西，那么我们如何去使用媒体查询在我们的移动端适配上呢? 待续</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;历经好多时间= =，终于完成了一个小项目，再次更新了一些我的移动端知识，之前总是对概念有些不清晰，先梳理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="html" scheme="https://wingsico.github.io/tags/html/"/>
    
    <category term="移动端" scheme="https://wingsico.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    <category term="随笔" scheme="https://wingsico.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="项目总结" scheme="https://wingsico.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>满二叉树中树的深度、结点、分支结点、叶子结点等之间的数量关系</title>
    <link href="https://wingsico.github.io/2017/12/16/btree-number-relation/"/>
    <id>https://wingsico.github.io/2017/12/16/btree-number-relation/</id>
    <published>2017-12-16T08:44:37.000Z</published>
    <updated>2020-12-07T05:44:32.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对二叉树的简单总结</p><a id="more"></a><h2 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h2><p>对于普通的二叉树，假设<code>n</code>为总结点数，<code>n0</code>为度为 0 的结点（叶子结点）数，<code>n1</code>为度为 1 的结点数，<code>n2</code>为度为 2 的结点数。<code>m</code>为树的总度数。 有如下一般的数量关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树只含有度数为 0，1，2 的结点，因此总结点数等于他们的和</span></span><br><span class="line">n = n0 + n1 + n2</span><br><span class="line"><span class="comment">// 无需解释吧，m 为总度数</span></span><br><span class="line"><span class="number">0</span> _ n0 + <span class="number">1</span> _ n1 + <span class="number">2</span> \* n2 = m</span><br><span class="line"><span class="comment">// 除了根结点之外，每一个结点的上方都对应着一个度，因此总度数比总结点数少 1</span></span><br><span class="line">m = n - <span class="number">1</span></span><br><span class="line"><span class="comment">// 综合上面的三个式子</span></span><br><span class="line">n0 =  n2 + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>设深度为<code>h</code>，设<code>n</code>为总结点数，<code>k</code>为分支结点数，<code>m</code>为叶子结点数。 <strong>深度</strong>：树的最大层数； <strong>叶子结点</strong>：度为 0 的结点； <strong>分支结点</strong>：非叶子结点，即度不为零的结点。 则有如下的数量关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="number">2</span> ^ (h - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + ... + <span class="number">2</span> ^ (h - <span class="number">1</span>) = <span class="number">2</span> ^ h - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k = n - m = <span class="number">2</span> ^ (h - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n = <span class="number">2</span>m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n = <span class="number">2</span>k + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对二叉树的简单总结&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="数据结构" scheme="https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ssh: REMOTE HOST IDENTIFICATION HAS CHANGED 解决方案</title>
    <link href="https://wingsico.github.io/2017/12/16/ssh-host/"/>
    <id>https://wingsico.github.io/2017/12/16/ssh-host/</id>
    <published>2017-12-16T06:14:28.000Z</published>
    <updated>2020-12-07T05:44:32.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直使用<code>SSH Shell</code>来登录的服务器，用着觉得主题有点丑我就又用<code>iTerm</code>来用 ssh 登录服务器。</p><a id="more"></a><p>照常，我使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@wingsico.org</span><br></pre></td></tr></table></figure><p>登录服务器，突然，出现了一个错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ ~ ssh root@wingsico.org</span><br><span class="line"> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"> @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @</span><br><span class="line"> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"> IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line"> Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line"> It is also possible that a host key has just been changed.</span><br><span class="line"> The fingerprint <span class="keyword">for</span> the RSA key sent by the remote host is</span><br><span class="line"> SHA256:KDg0k+7eheoSVX0/HTzlWK66OI5sLrzgWc6cgXZDE6s.</span><br><span class="line"> Please contact your system administrator.</span><br><span class="line"> Add correct host key <span class="keyword">in</span> /Users/wingsico/.ssh/known_hosts to get rid of this message.</span><br><span class="line"> Offending RSA key <span class="keyword">in</span> /Users/wingsico/.ssh/known_hosts:7</span><br><span class="line"> RSA host key <span class="keyword">for</span> wingsico.org has changed and you have requested strict checking.</span><br><span class="line"> Host key verification failed.</span><br></pre></td></tr></table></figure><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>注意他的错误提示</p><p>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</p><p>意思就是：<strong>远程主机标识已更改</strong> 可能是因为我重装了一下服务器，导致远程主机标识的变化，这里就要说到服务器与客户端的连接的一些要点了。 在远程服务器上，在路径<code>/ect/ssh</code>下会有一些<code>.pub</code>后缀以及名字相同但无后缀的文件，这里存放的是服务器的指纹，目录类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_48_13_centos ssh]<span class="comment"># ls</span></span><br><span class="line">moduli ssh_host_dsa_key.pub ssh_host_ed25519_key.pub</span><br><span class="line">ssh_config ssh_host_ecdsa_key ssh_host_rsa_key</span><br><span class="line">sshd_config ssh_host_ecdsa_key.pub ssh_host_rsa_key.pub</span><br><span class="line">ssh_host_dsa_key ssh_host_ed25519_key</span><br></pre></td></tr></table></figure><p>其中，文件名为 <code>ssh_host_xxx_key</code> 和 <code>ssh_host_xxx_key.pub</code>就是我们服务器的指纹，分别为<strong>私钥</strong>和<strong>公钥</strong>，私钥是唯一一份的，不能泄露给他人，而公钥可以在各个地方使用，这个可以参考 git 仓库的建立。 当我们使用客户端第一次登录服务器时，会有如下一段提示：</p><blockquote><p>The authenticity of host ‘wingsico.org (xxx.xxx.xxx.xxx)’ can’t be established.<br>ECDSA key fingerprint is SHA256:+gFx5UGMm/739ut/jKZqJDm+TYSUxfZiC7IKG2PAVpA.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘wingsico.org,xxx.xxx.xxx.xxx’ (ECDSA) to the list of known hosts.</p></blockquote><p>这时候远程服务器的指纹如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECDSA key fingerprint is SHA256:+gFx5UGMm/739ut/jKZqJDm+TYSUxfZiC7IKG2PAVpA.</span><br></pre></td></tr></table></figure><p>与服务器远程验证，防止中间人攻击，这时候输入<code>yes</code>将会将指纹添加进本地的 <code>~/.ssh/know_hosts</code> 中去，远程主机和本机就拥有了一对指纹作为登录的验证，当本地的指纹与远程主机的指纹不一致时，将会弹出上面的警告信息拒绝登录。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>知道了原因，就很好处理了，因为我们重装了服务器，导致远程主机中<code>sshd</code>初始化，改变了远程主机的指纹，本地的指纹与远程主机的指纹不一致，导致登录被拒绝。所以我们只需要修改本地的指纹，也就是 <code>~/.ssh/know_hosts</code> 的内容即可，具体操作如下: 使用<code>nano</code>打开<code>know_hosts</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.ssh/know_hosts</span><br></pre></td></tr></table></figure><p>将对应远程主机的 ip 或者域名的指纹删除，然后重新登录。</p><p>重新将指纹添加进本地的<code>~/.ssh/know_hosts</code>内，即可登录成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前一直使用&lt;code&gt;SSH Shell&lt;/code&gt;来登录的服务器，用着觉得主题有点丑我就又用&lt;code&gt;iTerm&lt;/code&gt;来用 ssh 登录服务器。&lt;/p&gt;</summary>
    
    
    
    <category term="疑难杂症" scheme="https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="linux" scheme="https://wingsico.github.io/tags/linux/"/>
    
    <category term="服务器" scheme="https://wingsico.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="host" scheme="https://wingsico.github.io/tags/host/"/>
    
  </entry>
  
</feed>
