<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="wingsico的编程世界"><title>数据结构之图的应用 | wingsico</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><!-- hexo injector head_end start -->
<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构之图的应用</h1><a id="logo" href="/.">wingsico</a><p class="description">真正的大师，永远都怀着一颗学徒的心</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> Tags</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构之图的应用</h1><div class="post-meta">01-02-2018<span> | </span><span class="category"><a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">深入理解</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2018/01/02/graph/#vcomment"><span class="valine-comment-count" data-xid="/2018/01/02/graph/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">狄克斯特拉算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%96%91%E6%83%91"><span class="toc-number">2.</span> <span class="toc-text">疑惑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">3.2.</span> <span class="toc-text">输入与输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">实验分析与设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">3.5.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">3.6.</span> <span class="toc-text">调试结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>之前在算法图解里看见了关于最短路径的求解，对于无权值的图，我们可以采用<code>广度优先搜索</code>算法，找出的是经过最少的边的路径，而对于含有<code>边权</code>的图，若要找到其<code>最短路径</code>（更好的称为<code>最快路径</code>），可采用另一种算法，即<code>狄克斯特拉算法</code></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><a id="more"></a>

<h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><p>据我所知，狄克斯特拉算法<code>只适用于有向无环图</code>，这是为什么呢？ 假设有一个环，<code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> -&gt; <code>B</code> -&gt; <code>A</code>，这意味着你可以从一结点出发，走一圈之后又回到了这个结点，假设在这个带环的图内，你要找出从起点到终点的最短路径，绕环前行是否合理呢？</p>
<p>你可以选择避开环，也可以选择包含环的路径。这两条路径都可以到达终点，但环增加了权重，所以绕环的路径不可能是最短的路径。对于无向图，意味着两个节点互相指着对方，其实就是环，在无向图中，每一条边的都是环。所以狄克斯特拉算法只适用于<code>有向无环图</code> <code>狄克斯特拉算法</code>能否找出含有负权值的边呢？</p>
<p>答案是不能:(，因为在<code>狄克斯特拉算法</code>中，对于处理过的结点，就意味着没有前往该结点的更快的路径，但若含有负权值的边，你知道如果包含负权值的话，会更快到达该结点，但是该算法不会再用负权值去处理这个结点，因此<strong>该算法只适用于不含有负权值的图</strong>。 狄克斯特拉算法的核心思想为:</p>
<ol>
<li>找出“最便宜的结点”，即可在最短时间内到达的结点</li>
<li>更新该结点的邻居，检查是或否有前往他们的更短路径，如果有，就更新其开销</li>
<li>重复这个过程，知道对图中的每个结点都这样做了</li>
<li>计算最终路径</li>
</ol>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>由上面的一些知识可得，狄克斯特拉算法适用于<code>有向无环图</code>和<code>不存在负权值的图</code>。但是实验给了一张<code>权值为正的无环图</code>，这就有一些懵逼了，那么我还如何使用<code>狄克斯特拉算法</code>去解决一个无向图呢？ 、</p>
<p>为了解决这个问题，先进入实验，从实验中得到解决的方法。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个大学校内交通咨询系统，能让旅客咨询从任一楼到其余所有楼之间的最短路径。</p>
<h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>输入：输入图的顶点数，以及边数。 输出：一幢楼到其他楼之间的最短路径。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>1.建立交通网络图的存储结构。 2.解决单源最短路径问题。</p>
<h3 id="实验分析与设计"><a href="#实验分析与设计" class="headerlink" title="实验分析与设计"></a>实验分析与设计</h3><p>由实验图我们可以看出，这是一个<code>不含有负权值边的无向图</code>，由我们有向图<code>狄克斯特拉算法</code>可以延伸出一种处理无向图的最短路径的算法。 首先，我们需要先建立一个图结构，这个图应该包含以下一些东西：</p>
<ul>
<li>图的顶点数</li>
<li>图的边数</li>
</ul>
<p>还有什么呢？因为我们处理的是<code>单源最短路径</code>，所以需要存储<strong>源点到各个点的距离</strong>；除此之外，我们需要保存一条边的顶点之间的联系，我们使用一个<code>邻接矩阵</code>来存储这之间的联系；还有就是，由算法的原理可以知道，到每一个点的最短路径会在每一轮就确定下来，因此我们需要存储已经确定了最短路径的结点。</p>
<p>综上，我们可以知道，这个图结构应该包含完整的以下内容：</p>
<ul>
<li>图的顶点数</li>
<li>图的边数</li>
<li>源点到各个顶点的初始路程</li>
<li>顶点与顶点之间的联系，即边权值</li>
<li>已经确定最短路径的结点</li>
</ul>
<p>因此，我们使用一个<code>结构体</code>作为图的结构，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_node_count = <span class="number">20</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Type AdjacencyList[max_node_count][max_node_count]; <span class="comment">// 邻接矩阵存储顶点与顶点之间的联系</span></span><br><span class="line">    Type distances[max_node_count]; <span class="comment">// distances数组，1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    Type shortPaths[max_node_count]; <span class="comment">// shortPaths数组，存放已经确定最短路径的结点</span></span><br><span class="line">    Type vertex = <span class="number">0</span>; <span class="comment">// 图的顶点数</span></span><br><span class="line">    Type edge = <span class="number">0</span>; <span class="comment">// 图的边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure>

<p>采用邻接矩阵来存储顶点之间的联系。 根据实验要求，我们需要先初始化这个图，也就是初始化部分邻接矩阵以及他的顶点数和边数。容易知道的是，每个顶点和他自身的距离为 0，因此，在初始化的时候就可以直接设为 0，另外，对于其他的点，我们先初始化为无穷大的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的顶点数和边数: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g.vertex &gt;&gt; g.edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.edge; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = <span class="number">0</span>; <span class="comment">// 顶点与自身距离为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = inf; <span class="comment">// 某个顶点与其余顶点距离默认初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">之后我们便要读入对应的顶点和边权了，对于有向图，其是有固定的指向的，因此，在邻接矩阵中，若无环，且`AdjacencyList[<span class="number">3</span>][<span class="number">4</span>] ≠ ∞`，则`AdjacencyList[<span class="number">4</span>][<span class="number">3</span>] = ∞`，是一个对立的关系，那么对于无向图呢？ 其实只要让`AdjacencyList[<span class="number">3</span>][<span class="number">4</span>] = AdjacencyList[<span class="number">4</span>][<span class="number">3</span>]`即可，这样，即可使无向图也可以使用`狄克斯特拉算法`来寻找最快路径。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">status getGraph (Graph &amp;g) &#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// 边的左顶点</span></span><br><span class="line">    <span class="keyword">int</span> v2; <span class="comment">// 边的右顶点</span></span><br><span class="line">    <span class="keyword">int</span> e; <span class="comment">// 边的权值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.edge; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;</span>, i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e;</span><br><span class="line">        g.AdjacencyList[v1][v2] = e; <span class="comment">// 填入邻接矩阵</span></span><br><span class="line">        g.AdjacencyList[v2][v1] = e; <span class="comment">// 无向图处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还要初始化两个表，一个是初始路径的表，还有一个就是已经确定最短路径的表。 初始路径的表，即源点到各个点的初始路径，有些点不与源点直接相连，即可设置为无穷大；对于与源点直接相连的点，可以查看邻接矩阵中关于源点的顶点之间的联系，然后填入表内。 已经确定最短路径的表，在最开始只有源点是确定的，其他点均尚未确定，因此，初始化也非常简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dis数组，表示1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.distances[i] = g.AdjacencyList[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line">    <span class="comment">// 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.shortPaths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.shortPaths[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要做的就是依据邻接矩阵来不断更新这两个表的数据来计算所有点距离源点的最短路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min; <span class="comment">// 存储最小值</span></span><br><span class="line">    <span class="keyword">int</span> vmin; <span class="comment">// 存储最小值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex - <span class="number">1</span>; ++i) &#123; <span class="comment">// 最后一个点无需比较</span></span><br><span class="line">        <span class="comment">// 找到距离号顶点最近的顶点</span></span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.vertex; ++j) &#123; <span class="comment">// 遍历各个顶点，找出距离最近的未确定的结点</span></span><br><span class="line">            <span class="keyword">if</span> (g.shortPaths[j] == <span class="number">0</span> &amp;&amp; g.distances[j] &lt; min) &#123;</span><br><span class="line">                min = g.distances[j];</span><br><span class="line">                vmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g.shortPaths[vmin] = <span class="number">1</span>; <span class="comment">// 确定该顶点找到最小路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= g.vertex; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.AdjacencyList[vmin][k] &lt; inf) &#123; <span class="comment">// 若两个顶点直接相邻</span></span><br><span class="line">                <span class="keyword">if</span> (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; <span class="comment">// 若该距离更小，更新最短路径的数据</span></span><br><span class="line">                    g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释如注释。</p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_node_count = <span class="number">20</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">999999</span>; <span class="comment">// 存储一个可以当做相对无穷的值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Type AdjacencyList[max_node_count][max_node_count]; <span class="comment">// 邻接矩阵存储顶点与顶点之间的联系</span></span><br><span class="line">    Type distances[max_node_count]; <span class="comment">// distances数组，1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    Type shortPaths[max_node_count]; <span class="comment">// shortPaths数组，存放已经确定最短路径的结点</span></span><br><span class="line">    Type vertex = <span class="number">0</span>; <span class="comment">// 图的顶点数</span></span><br><span class="line">    Type edge = <span class="number">0</span>; <span class="comment">// 图的边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">const</span> status ok = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> status err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化邻接表</span></span><br><span class="line"><span class="function">status <span class="title">getGraph</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 读入边</span></span><br><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化distances数组</span></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span></span>; <span class="comment">// 计算得到所有节点确定最短路径长度的数组</span></span><br><span class="line"><span class="function">status <span class="title">displayClosestDistances</span> <span class="params">(Graph g)</span></span>; <span class="comment">// 输出最终得到到各个结点的最小路径数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DIJKSTRA 算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph traffic; <span class="comment">// 定义一个Graph变量</span></span><br><span class="line">    initGraph(traffic); <span class="comment">// 初始化图的邻接顺序表</span></span><br><span class="line">    getGraph(traffic); <span class="comment">// 读入边的相关信息</span></span><br><span class="line">    initDistances(traffic); <span class="comment">// 初始化各个顶点距离源点的路径顺序表</span></span><br><span class="line">    initShortPaths(traffic); <span class="comment">// 初始化各个已经确定最短顶点的顶点顺序表</span></span><br><span class="line">    makeClosestDistances(traffic);</span><br><span class="line">    displayClosestDistances(traffic);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *****************  函数库  *********************</span></span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的顶点数和边数: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g.vertex &gt;&gt; g.edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.edge; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = <span class="number">0</span>; <span class="comment">// 顶点与自身的距离为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.AdjacencyList[i][j] = inf; <span class="comment">// 某个顶点与其余顶点距离默认初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">getGraph</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// 边的左顶点</span></span><br><span class="line">    <span class="keyword">int</span> v2; <span class="comment">// 边的右顶点</span></span><br><span class="line">    <span class="keyword">int</span> e; <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.edge; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;</span>, i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e;</span><br><span class="line">        g.AdjacencyList[v1][v2] = e; <span class="comment">// 填入邻接矩阵</span></span><br><span class="line">        g.AdjacencyList[v2][v1] = e; <span class="comment">// 无向图处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dis数组，表示1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.distances[i] = g.AdjacencyList[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">initShortPaths</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化shortPaths数组</span></span><br><span class="line">    <span class="comment">// 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        g.shortPaths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.shortPaths[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">displayClosestDistances</span> <span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出各个顶点的距离1号顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号顶点距离源点(1号)的最短路径的长度为 %d\n&quot;</span>, i, g.distances[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">makeClosestDistances</span> <span class="params">(Graph &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min; <span class="comment">// 存储最小值</span></span><br><span class="line">    <span class="keyword">int</span> vmin; <span class="comment">// 存储最小值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.vertex - <span class="number">1</span>; ++i) &#123; <span class="comment">// 最后一个点无需比较</span></span><br><span class="line">        <span class="comment">// 找到距离号顶点最近的顶点</span></span><br><span class="line">        min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= g.vertex; ++j) &#123; <span class="comment">// 遍历各个顶点，找出距离最近的未确定的结点</span></span><br><span class="line">            <span class="keyword">if</span> (g.shortPaths[j] == <span class="number">0</span> &amp;&amp; g.distances[j] &lt; min) &#123;</span><br><span class="line">                min = g.distances[j];</span><br><span class="line">                vmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.shortPaths[vmin] = <span class="number">1</span>; <span class="comment">// 确定该顶点找到最小路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= g.vertex; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.AdjacencyList[vmin][k] &lt; inf) &#123; <span class="comment">// 若两个顶点直接相邻</span></span><br><span class="line">                <span class="keyword">if</span> (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; <span class="comment">// 若该距离更小，更新最短路径的数据</span></span><br><span class="line">                    g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/Users/wingsico/CLionProjects/dijkstra/cmake-build-debug/dijkstra</span><br><span class="line">输入图的顶点数和边数: 5 7</span><br><span class="line">输入第1条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 2 180</span><br><span class="line">输入第2条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 3 100</span><br><span class="line">输入第3条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 4 150</span><br><span class="line">输入第4条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 4 50</span><br><span class="line">输入第5条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 5 130</span><br><span class="line">输入第6条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 3 4 80</span><br><span class="line">输入第7条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 4 5 120</span><br><span class="line">1号顶点距离源点(1号)的最短路径的长度为 0</span><br><span class="line">2号顶点距离源点(1号)的最短路径的长度为 180</span><br><span class="line">3号顶点距离源点(1号)的最短路径的长度为 100</span><br><span class="line">4号顶点距离源点(1号)的最短路径的长度为 150</span><br><span class="line">5号顶点距离源点(1号)的最短路径的长度为 270</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个代码上还有可以改进的地方，这个算法的时间复杂度为<code>O(N^2)</code>，每次找到离源点最近的定点的时间复杂度是 O(N)(一个 for 循环遍历所有结点)，这里我们可以使用<code>堆</code>来优化，可以使这一部分的时间复杂度降低到<code>O(logN)</code>。</p>
<p>另外，对于稀疏图来说，我们可以使用<code>邻接表法</code>代替邻接矩阵，使得整个时间复杂度优化到<code>O((M+N)logN)</code>，但没有仔细研究，所以也不了了之。 对于选做题，有一定难度，不过了解<code>费洛伊德算法</code>即可解决，即<code>多源最短路径的算法</code>，其核心代码只有五行，利用了动态规划的思想，实现起来很简单，但由于时间有限，加之期末临近，只好作罢。 Over。</p>
</div><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>数据结构</a><a href="/tags/c/"><i class="fa fa-tag"></i>c++</a></div><div class="post-nav"><a class="pre" href="/2018/01/05/vue-cli-whitepage/">[vue-cli] 解决 npm run dev 之后在某些浏览器上一片空白</a><a class="next" href="/2017/12/24/unknowhtml-standard/">你所不知道的HTML —— 规范篇</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yd3glld8hGV5qBsgdj1wd0PN-gzGzoHsz',
  appKey:'6QgBEkctVPSnQKMI7G1n2EO2',
  placeholder:'if you have some questions, please comment',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E6%B2%BB%E6%87%92%E7%99%8C/">专治懒癌</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/">技术杂文</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">深入理解</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/">疑难杂症</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">21</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/some-of-leave/">临别有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/catch-me-if-you-can/">《猫鼠游戏》有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/js-number-scope/">JavaScript 中 Number 有多少个?</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/unicode-intro/">Unicode 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/js-spec-types/">JavaScript 规范类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/byteDance-intervies/">2019.6月 头条前端三面 面经</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/2019-plan-1/">2019年-2020年目标规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/mysql-password-reset/">Mac OS 重置MySQL密码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/vue-router-404/">vue-router 非定义路由的访问</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/functional-programming-1/">函数式编程之curry</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.lxxyx.cn/" title="繁易的前端乐园" target="_blank">繁易的前端乐园</a><ul></ul><a href="https://www.xiaohuochai.cc/" title="小火柴的前端小站" target="_blank">小火柴的前端小站</a><ul></ul><a href="https://www.haomwei.com/" title="屠夫9941" target="_blank">屠夫9941</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">wingsico.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.1"><script type="text/javascript" src="/js/search.js?v=0.0.1"></script><script>var search_path = '';
var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>