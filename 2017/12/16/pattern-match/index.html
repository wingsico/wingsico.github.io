<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="wingsico的编程世界"><title>串的模式匹配应用之文本编辑 | wingsico</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><!-- hexo injector head_end start -->
<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">串的模式匹配应用之文本编辑</h1><a id="logo" href="/.">wingsico</a><p class="description">真正的大师，永远都怀着一颗学徒的心</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> Tags</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">串的模式匹配应用之文本编辑</h1><div class="post-meta">12-16-2017<span> | </span><span class="category"><a href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.4k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 21</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2017/12/16/pattern-match/#vcomment"><span class="valine-comment-count" data-xid="/2017/12/16/pattern-match/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">串的表示方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91"><span class="toc-number">3.</span> <span class="toc-text">串应用——文本编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">关闭文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">写入文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-number">4.</span> <span class="toc-text">问题汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">5.</span> <span class="toc-text">总结和改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">程序源代码</span></a></li></ol></div></div><div class="post-content"><p>对 C 串结构的学习总结</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>老实说，串这一章学的并不好，感觉只了解相关概念，在我的印象中, 串就是代表字符串，而在 C/C++语言中，字符串又可用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> chs[<span class="number">100</span>]; <span class="comment">// 字符数组</span></span><br><span class="line"><span class="built_in">string</span> str; <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure>

<p>两种（简单）方法表示，结构上均与线性表无异，区别只在于串的数据对象被约束为字符集。但在操作上，串与线性表是存在较大差别的。 在线性表的基本操作中，大多以“单个元素”作为操作对象，例如查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等。 而在串的基本操作中，通常以“串的整体”作为操作对象，例如在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。 但如何实现一个串，如何实现一个符合情景的串是一个令我头疼的问题。如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。（这个非数值处理有点不太明白，串不都是字符类型吗？不是均为非数值吗？）</p>
<h2 id="串的表示方法"><a href="#串的表示方法" class="headerlink" title="串的表示方法"></a>串的表示方法</h2><blockquote>
<p>定长顺序存储表示</p>
</blockquote>
<p>类似线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列，给定一个预定义的大小，为每个定义的串变量分配一个固定长度的存储区，可以用如下代码描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[MAXSIZE + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>串的实际长度可以在预定义长度内随意，超过定义的长度就会被截断。在上面的代码中，我们设置了一个常量<code>MAXSIZE</code>，同时自定义了一个数据类型<code>sstring[]</code>，注意，我们定义的字符串预定义长度为<code>MAXSIZE + 1</code>，这是为了方便串操作，我们将串的长度存储在 0 号数据单元，当然，这也不是必须的，在 c 语言中，我们可以使用<code>strlen()</code>来获取<strong>字符数组</strong><code>char chs[]</code>的真实长度，用<code>str.length()</code>来获取字符串的长度。 这个为最简单也最常用的一种串的结构，也是我们这次实验需要用到的结构。接下来简要介绍一下另外两种串的表示方法（对于我来说不是很熟悉）</p>
<blockquote>
<p>堆分配存储表示</p>
</blockquote>
<p>对于第一种表示方法，会有一些问题：</p>
<ol>
<li>操作的时间复杂度基于串的长度，效率较低</li>
<li>在一些操作中出现串值序列的长度超过上界时，约定使用截尾法处理，也就是说会导致一些串值丢失的情况</li>
</ol>
<p>为了解决这些问题，我们采取<strong>不限制串的最大长度，而采用动态分配串值的存储空间</strong> 我们仍以一组地址连续的存储单元存放串值字符序列，但他们的存储空间是在程序执行过程中动态分配而得。在 C 语言中，存在一个称之为“堆”的自由存储区，并由 C 怨言的动态分配函数<code>malloc()</code>和<code>free()</code>来管理。利用<code>malloc()</code>来为每一个新产生的串分配一块实际船厂所需的存储空间。其代码表示如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch; <span class="comment">// 若是非空串，则按串长分配存储区，否则ch为 NULL</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 串长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更加的灵活，因此在串处理的应用程序中也经常被选用。</p>
<blockquote>
<p>串的块链存储表示</p>
</blockquote>
<p>既然线性表中有链式的表示方法，那么在串中也可以采用链表方式存储串值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHUNKSIZE = <span class="number">80</span>; <span class="comment">// 自定义大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Chunk *head, *tail; <span class="comment">// 头尾指针</span></span><br><span class="line">    <span class="keyword">int</span> curlen; <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;LString</span><br></pre></td></tr></table></figure>

<p>由代码很容易看出，一个块由数据域（字符数组）和指向下一个块的指针组成，同时<code>LString</code>表示的是字符串，其头指针指向其串首地址，还可以增设一个尾指针用来指向最后一个结点，并给出当前串的长度<code>curlen</code>，我们把这种串结构称作为<strong>块链结构</strong>，设置尾指针还有一个目的，<strong>是为了标语进行联结操作，但需要注意的是联结时需要处理第一个串尾的无效字符</strong>。 <strong>块链结构</strong>的串虽然对一些串操作比较方便，但不如前两种灵活，它占用内存大，且操作复杂，使用频率较少。</p>
<p>介绍完这三种表示方法，该进入我们今天的主题——<strong>文本编辑</strong></p>
<h2 id="串应用——文本编辑"><a href="#串应用——文本编辑" class="headerlink" title="串应用——文本编辑"></a>串应用——文本编辑</h2><p>想到大一上学期，C 语言的课程比较紧凑，于是对于课本后面的知识没有好好巩固，对于文件处理方面的知识非常模糊，于是先整理了一下 C++文件与流的一些知识要点。</p>
<p>到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 那么我们如何对文件进行输入和输出呢？这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： <code>ofstream</code> <strong>该数据类型表示输出文件流，用于创建文件并向文件写入信息。</strong> <code>ifstream</code> <strong>该数据类型表示输入文件流，用于从文件读取信息。</strong> <code>fstream</code> <strong>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</strong> 因此，要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <code>&lt;iostream&gt;</code> 和 <code>&lt;fstream&gt;</code>。</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<code>ofstream</code> 和 <code>fstream</code> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <code>ifstream</code> 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，open() 成员函数的第一参数<strong>指定要打开的文件的名称和位置</strong>，第二个参数<strong>定义文件被打开的模式</strong>。 <code>ios::app</code> <strong>追加模式。所有写入都追加到文件末尾。</strong> <code>ios::ate</code> <strong>文件打开后定位到文件末尾。</strong> <code>ios::in</code> <strong>打开文件用于读取。</strong> <code>ios::out</code> <strong>打开文件用于写入。</strong> <code>ios::trunc</code> <strong>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</strong> 可以把以上两种或两种以上的模式结合使用。例如，如果想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fstream  afile;</span><br><span class="line">afile.open(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>

<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 <code>close()</code> 函数的标准语法，<code>close()</code> 函数是 <code>fstream</code>、<code>ifstream</code> 和 <code>ofstream</code> 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 <code>ofstream</code> 或 <code>fstream</code> 对象，而不是 <code>cout</code> 对象。 ####读取文件 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <code>ifstream</code> 或 <code>fstream</code> 对象，而不是 <code>cin</code> 对象。</p>
<p>有了以上的知识，对于读写文件的话还是信手拈来的。接下来，我们来看看实验要求</p>
<ol>
<li>要求建立一个文本文件，每个单词子串不包含空格且不跨行，单词子串由字符序列构成，且区分大小写；</li>
<li>统计给定单词子串在文本文件中出现的总次数；</li>
<li>检索输出某个单词子串出现在文本中的行号、在该行中出现的次数以及位置。</li>
</ol>
<p>一个个来分析，对于第一个，不包含空格也就是不存在类似<code>hello world</code>这样的字符串，字符串不跨行意味着每一行只有一个字符串，区分大小写的话意义不大，因为读取的和比较的时候是肯定区分大小写的。所以，我们使用如下函数来创建一个文本文件并读入字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; // 文件流</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10000</span>; <span class="comment">// 预定义字符串最大长度</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize]; <span class="comment">// 自定义字符数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data; <span class="comment">// 声明一个sstring类型的变量，存储输入的字符，包含换行符以及空格</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 用于标记当前读入的字符在字符数组的位置</span></span><br><span class="line">    <span class="keyword">char</span> temp; <span class="comment">// 存储中间变量，读入当前字符值</span></span><br><span class="line"></span><br><span class="line">    ofstream outfile; <span class="comment">// 定义一个写入变量</span></span><br><span class="line">    outfile.open(<span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 执行打开文件方法，打开一个当前路径下的&quot;test.txt&quot;文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Write some strings to this file, if you want to stop, input a &#x27;#&#x27;: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((temp = getchar()) != <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 以#号结束输入</span></span><br><span class="line">            data[i++] = temp; <span class="comment">// 存入字符数组中</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次读入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 结束输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    getchar(); <span class="comment">// important 坑</span></span><br><span class="line">    outfile &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 将数据写入文件中</span></span><br><span class="line">    outfile.close(); <span class="comment">// 关闭对文件的访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，我们使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize];</span><br></pre></td></tr></table></figure>

<p>来定义一个字符数组类型而不是<code>unsigned char</code>，这么做的目的是为了后面的读取文件使格式保持一致，在后面会说到。 同时，在注释中标记<code>important</code>的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<p>为什么要在结束输入之后调用这个方法呢？原因在于：*<em>当我们输入#之后，字符数组剩余的部分的内容不确定，如果没有<code>getchar()</code>他将会得到一些乱码导致文件编码存在问题以及读取文件存在问题。我们使用<code>getchar()</code>来获取缓冲区的字符，避免将这些字符写入文件中去。(有待考证) 写入之后，我们就是需要读取文件的内容了。对于实验的要求，采用整行读取会较为方便，即使用<code>getline()</code>函数，读取是较为简单的，但是我们如何存储读取的数据呢？我们知道，读取的每一行的数据均为一个字符串，因此我们需要一个结构来存储每一个字符串。我第一反应就是字符串数组，这是在别的语言里非常常见的，但在 c 语言中，<code>char chs[]</code>只能存储字符串，无法使用它来存储多个字符串，所以，我想到了使用另一个类型 —— **string\</em>* 使用<code>string</code>，我们需要引入头文件 <code>#include &lt;string&gt;</code>，我们可以这样定义一个字符串数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> content[maxsize];</span><br><span class="line">...</span><br><span class="line">content[<span class="number">0</span>] = <span class="string">&quot;my world&quot;</span>;</span><br><span class="line">content[<span class="number">1</span>] = <span class="string">&quot;your name&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>因此，我们可以每读取一行，将该行的字符串存入字符串数组中去，同时，由于读取的内容几乎在每个函数内都需要使用，为了避免每次调用函数都需要传参的麻烦，我们将读取的内容存在全局的字符串数组内，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> content[maxsize]; <span class="comment">// 字符串数组，存储文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data; <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 存储当前字符串存入数组的下标</span></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>; <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">while</span> (infile.getline(data, maxsize)) &#123; <span class="comment">// 逐行读取</span></span><br><span class="line">        content[index++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    lineNumber = index; <span class="comment">// 内容的行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的 content 用于全局，所以我们无需穿参，在函数内直接对<code>content</code>进行修改。再设置了一个全局的变量 <code>lineNumber</code> 用于存储读取文件的行数，对后面的匹配要求做铺垫。 读写存储操作均完成了，我们来看下一个要求，需要统计子串在字符串出现的总次数，思路很简单，我们对每一行进行匹配，若匹配成功则计数器加一，同时要注意一行可能会有多个匹配的子串，所以一行需要进行多次匹配。 那么在统计次数之前，我们需要完成一个更重要的工作，如何进行匹配？也就是判断子串是否在主串内以及如何定位到子串在主串的位置，这样的操作我们通常称为<strong>模式匹配</strong>。 通过模式匹配，我们将返回子串的第一个字符在主串中的下标。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sstring sMain = <span class="string">&quot;abbbcbc&quot;</span>;</span><br><span class="line">sstring sChild = <span class="string">&quot;bc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>则子串在主串的位置为<code>1</code>，那么如何实现匹配呢？ 我们指定两个指针，一个指针 <code>i</code> 指向主串首个字符，一个指针 <code>j</code> 指向子串首个字符，逐个字符比较。当字符相等的时候， <code>i</code> 和 <code>j</code> 同时后移，匹配下一个字符；当字符不相等时， <code>j</code> 回到子串的首个字符的位置， <code>i</code> 则回溯到之前匹配到子串的第一个字符的位置的下一个位置。当 <code>j</code> 后移到子串之后的位置时，说明子串已经完全匹配，则此时 <code>i</code> 的指向为子串的最后一个字符在主串的位置的后一个位置。我们需要返回子串的位置，则需要找到匹配到的子串的首字符在主串中的位置，只需要将 <code>i</code> 后移子串长度个单位就可以了。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(sstring s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span> <span class="params">(<span class="built_in">string</span> s, sstring t, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回子串t在主串s中第pos个字符之后的位置。</span></span><br><span class="line">    <span class="comment">// 1 &lt;= pos &lt;= sLen</span></span><br><span class="line">    <span class="comment">// 匹配失败返回0</span></span><br><span class="line">    <span class="keyword">int</span> i = pos - <span class="number">1</span>, j = <span class="number">0</span>, sLen = s.length(), tLen = getLength(t);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 相等则主、子串指针均后移</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; <span class="comment">// 主串指针回溯</span></span><br><span class="line">            j = <span class="number">0</span>; <span class="comment">// 子串指针重新指向子串首字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == tLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - tLen + <span class="number">1</span>; <span class="comment">// 返回子串在主串的首位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没匹配到则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个函数 <code>getIndex()</code> 返回的是位置而不是下标，也就是是从 1 开始的，所以使用的时候要注意，它作为一个辅助函数，来实现我们两个主要功能的。 先来看计数功能，统计子串在主串中出现的总次数，在先前，我们已经将字符串存入了字符串数组，数组的每一个元素代表着每一行的字符串。因此我们需要便利这个字符串数组，对其每一个字符串进行匹配，得到最终的匹配个数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordCount</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring queryStr; <span class="comment">// 搜索的子串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 记录第几行</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入你要计数的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; queryStr;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lineNumber) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], queryStr, index) + <span class="number">1</span>; <span class="comment">// 多次匹配</span></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">// 匹配成功计数器加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++; <span class="comment">// 换行，对下一行进行匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，对于子串的定位，功能上感觉和计数有部分重合，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strFind</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring s;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入要定位的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNumber; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器，记录每一行子串出现的次数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], s, index) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;字符串 %s 在第 %d 行，第 %d 列.\n&quot;</span>, s, i + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在第%d行共出现了%d次\n&quot;</span>, i + <span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ol>
<li><p><code>using namespace std;</code> 的位置 我发现，这一句代码不能放在定义全局变量 <code>string</code> 的下面，如果在下面的话，将产生一个报错：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: unknown type name &#x27;string&#x27;; did you mean &#x27;std::string&#x27;?</span><br></pre></td></tr></table></figure>

<p> 意味着 string 是包含在命名空间 std 中的。</p>
</li>
<li><p> 何时使用 <code>getFileContent()</code> 这个函数的作用是读取指定文件内容，并存入全局的字符串数组中去。当第一次使用该程序时，指定文件还未创建，因此读取得到的是空字符串，当我们执行完写入操作后，需要再次执行该函数将内容存入全局字符串数组。因此，需要在刚进入主函数时调用以及完成写入操作之后调用一次。</p>
</li>
</ol>
<h2 id="总结和改进"><a href="#总结和改进" class="headerlink" title="总结和改进"></a>总结和改进</h2><p>关于这次实验，我更改了实验内容所提供的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> sstring[maxsize];</span><br></pre></td></tr></table></figure>

<p>而使用了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize];</span><br></pre></td></tr></table></figure>

<p>只是为了函数的参数格式化，但其中区别未深入了解。同时，为了方便加入了<code>string</code>类型的数据，并不是很好的完全符合实验，而且对于引用参数和指针参数的理解还有些偏差，导致调试过程中出现许多的问题，需要自己仔细的再进行学习。 对于函数 <code>strfind()</code> 和 <code>wordCount()</code> ，这两个函数有一些公共的部分，应该是可以把它独立出来作为一个单独的函数来调用，将会简洁许多。</p>
<h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">string</span> content[maxsize]; <span class="comment">// 字符串数组，存储文件内容</span></span><br><span class="line"><span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> sstring[maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordCount</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strFind</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFileContent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span> <span class="params">(<span class="built_in">string</span> s, sstring t, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(sstring s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> t = <span class="literal">true</span>;</span><br><span class="line">    getFileContent();</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (choose()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                createTextFile();</span><br><span class="line">                getFileContent(); <span class="comment">// 创建完之后需要重新调用一次content</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                wordCount();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                strFind();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                t = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功退出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTextFile</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Write some strings to this file, if you want to stop, input a &#x27;#&#x27;: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        temp = getchar();</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            data[i++] = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    outfile &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    outfile.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span> <span class="params">()</span> </span>&#123; <span class="comment">// 菜单函数</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t文本编辑系统菜单🈳️&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t1. 创建文本文件&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t2. 文件单词计数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t3. 文件单词定位&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t0. exit&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的选择: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring data; <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 存储当前字符串存入数组的下标</span></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>; <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">while</span> (infile.getline(data, maxsize)) &#123; <span class="comment">// 逐行读取</span></span><br><span class="line">        content[index++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    lineNumber = index; <span class="comment">// 内容的行数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span> <span class="params">(<span class="built_in">string</span> s, sstring t, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回子串t在主串s中第pos个字符之后的位置。</span></span><br><span class="line">    <span class="comment">// 1 &lt;= pos &lt;= sLen</span></span><br><span class="line">    <span class="comment">// 匹配失败返回0</span></span><br><span class="line">    <span class="keyword">int</span> i = pos - <span class="number">1</span>, j = <span class="number">0</span>, sLen = s.length(), tLen = getLength(t);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 相等则主、子串指针均后移</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; <span class="comment">// 主串指针回溯</span></span><br><span class="line">            j = <span class="number">0</span>; <span class="comment">// 子串指针重新指向子串首字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == tLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - tLen + <span class="number">1</span>; <span class="comment">// 返回子串在主串的首位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没匹配到则返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span> <span class="params">(sstring s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordCount</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring queryStr; <span class="comment">// 搜索的子串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 记录第几行</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入你要计数的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; queryStr;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lineNumber) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], queryStr, index) + <span class="number">1</span>; <span class="comment">// 多次匹配</span></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">// 匹配成功计数器加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++; <span class="comment">// 换行，对下一行进行匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strFind</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    sstring s;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入要定位的字符串: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNumber; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器，记录每一行子串出现的次数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = getIndex(content[i], s, index) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;字符串 %s 在第 %d 行，第 %d 列.\n&quot;</span>, s, i + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在第%d行共出现了%d次\n&quot;</span>, i + <span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>数据结构</a><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div class="post-nav"><a class="pre" href="/2017/12/16/ssh-host/">ssh: REMOTE HOST IDENTIFICATION HAS CHANGED 解决方案</a><a class="next" href="/2017/12/16/stack-calc/">基于栈结构的中缀表达式求值</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yd3glld8hGV5qBsgdj1wd0PN-gzGzoHsz',
  appKey:'6QgBEkctVPSnQKMI7G1n2EO2',
  placeholder:'if you have some questions, please comment',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E6%B2%BB%E6%87%92%E7%99%8C/">专治懒癌</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/">技术杂文</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">深入理解</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/">疑难杂症</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">21</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/07/202011-summary/">十一月碎语</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/some-of-leave/">临别有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/catch-me-if-you-can/">《猫鼠游戏》有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/js-number-scope/">JavaScript 中 Number 有多少个?</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/unicode-intro/">Unicode 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/js-spec-types/">JavaScript 规范类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/byteDance-intervies/">2019.6月 头条前端三面 面经</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/2019-plan-1/">2019年-2020年目标规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/mysql-password-reset/">Mac OS 重置MySQL密码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/vue-router-404/">vue-router 非定义路由的访问</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.lxxyx.cn/" title="繁易的前端乐园" target="_blank">繁易的前端乐园</a><ul></ul><a href="https://www.xiaohuochai.cc/" title="小火柴的前端小站" target="_blank">小火柴的前端小站</a><ul></ul><a href="https://www.haomwei.com/" title="屠夫9941" target="_blank">屠夫9941</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">wingsico.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.1"><script type="text/javascript" src="/js/search.js?v=0.0.1"></script><script>var search_path = '';
var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>