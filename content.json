{"meta":{"title":"wingsico","subtitle":"真正的大师，永远都怀着一颗学徒的心","description":"wingsico的编程世界","author":"wingsico","url":"https://wingsico.github.io","root":"/"},"pages":[{"title":"archives","date":"2020-03-31T13:22:18.000Z","updated":"2020-12-07T05:44:32.074Z","comments":true,"path":"archives/index.html","permalink":"https://wingsico.github.io/archives/index.html","excerpt":"","text":""},{"title":"导航","date":"2020-04-02T07:40:56.000Z","updated":"2020-12-07T05:44:32.075Z","comments":false,"path":"navigator/index.html","permalink":"https://wingsico.github.io/navigator/index.html","excerpt":"","text":"主要是一些快捷入口，用于管理员或游客使用 评论管理"},{"title":"关于我","date":"2020-03-31T13:21:51.000Z","updated":"2020-12-07T05:44:32.073Z","comments":false,"path":"about/index.html","permalink":"https://wingsico.github.io/about/index.html","excerpt":"","text":"大四毕业狗一名，末流 211，计算机专业，来自互联网社团家园工作室，前端切图仔一枚。 喜欢唱歌，萌宠，画画，游戏，还有一些二次元美图（但我不追番）。 喜欢一些无厘头搞怪的动漫，蜡笔小新、海绵宝宝、猫和老鼠之类的。 有个无敌可爱的女朋友，咱俩差一天生日，姓氏也一样（放心，没啥血缘关系） 毕业即将北漂，在字节跳动工作，其实还是比较喜欢字节跳动的，氛围和企业文化让我挺享受的。 未来可能要和女票异地几年，希望我们可以共同度过这段比较难的时间吧。 目前全职闲人，在家写毕设中，如果你对我感兴趣，可以看一下我的简历： 钟伟杰 - 前端工程师"},{"title":"留言","date":"2020-04-01T15:36:32.000Z","updated":"2020-12-07T05:44:32.075Z","comments":true,"path":"comments/index.html","permalink":"https://wingsico.github.io/comments/index.html","excerpt":"","text":"如果你有什么话想对我说，欢迎留言讨论~"},{"title":"404 Not Found","date":"2020-12-07T06:24:52.802Z","updated":"2020-12-07T05:44:32.057Z","comments":true,"path":"404.html","permalink":"https://wingsico.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"tags","date":"2020-03-31T13:21:53.000Z","updated":"2020-12-07T05:44:32.075Z","comments":false,"path":"tags/index.html","permalink":"https://wingsico.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"临别有感","slug":"some-of-leave","date":"2020-06-24T02:26:14.000Z","updated":"2020-12-07T05:44:32.066Z","comments":true,"path":"2020/06/24/some-of-leave/","link":"","permalink":"https://wingsico.github.io/2020/06/24/some-of-leave/","excerpt":"","text":"在刷着刷着LeetCode的时候，瞄了一眼时间，是上午9点57分，脑海里突然跳出一个词：感受孤独，不知为何眼角被泪水浸湿。可能是将要毕业的惆怅，可能是爱人离开的不舍，也可能是即将北漂的无奈。这些种种境况带给我的是孤独和惆怅。很久以前我认为自己是一个坚强的人，不在意孤独，不在意离别。可后来发现我错了，彻头彻尾地错了。表面的阳光开朗是由背地里无数次哭泣支撑着，不管是高中毕业离家的离别，还是北京出租屋里的孤独，都让我难以掩泣。孤独从四面八方涌来，好像要把我埋葬于此。不知为何，此时不管脑海里在思考着什么，那些东西全部都被孤独感侵蚀了，鼻酸的感觉时时刻刻充斥着我，视线也越来越模糊。孤独，也就是如此吧。 虽然我现在还在寝室，身边还有两个室友在谈论着什么，外面风和日丽，小鸟在欢快地嬉闹着。但这些却无法给我带来平静，我的孤独感充斥了我的脑海，将其他一切都沾染上了孤独的颜色。也许室友在谈论即将的离别，也许太阳也在散播着孤独的、惨白的光线，也许鸟儿也在独奏一曲忧伤的哀歌。悄悄是离别的笙箫，也许也吹奏了孤独的曲调，身边的一切，在悄悄地随着时间流逝，但这如此细微的悄悄，却让我感受到无比的孤独和惆怅。孤独，也就是如此吧。 我不知是害怕孤独，还是害怕离别。是即将离别给我的感伤，还是离别后的孤独让我难以承受，我已难以判断。现在似乎更能理解雨欣的眼泪了，当在以往触手可及的一切即将不复返地离你远去，我想，这似乎确实难以让人接受。离别，也就是如此吧。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"念","slug":"念","permalink":"https://wingsico.github.io/tags/%E5%BF%B5/"}]},{"title":"《猫鼠游戏》有感","slug":"catch-me-if-you-can","date":"2020-04-04T09:02:07.000Z","updated":"2020-12-07T05:44:32.060Z","comments":true,"path":"2020/04/04/catch-me-if-you-can/","link":"","permalink":"https://wingsico.github.io/2020/04/04/catch-me-if-you-can/","excerpt":"","text":"看完这部电影，对于结局我是非常喜欢的，我不喜欢悲剧，也不喜欢作为主人公的纯喜剧，对于 猫鼠游戏 中的双方共赢的具有教育意义的结局，让我在观影后不单纯只是了解了弗兰克的结局，而沉浸在这种略微喜悦的感觉中，而是也会让我去平静下来，去真正的作为一个旁观者的一个思考。 弗兰克的经历我觉得是很现实的，父亲由于税务问题导致破产，母亲也因此出轨。父亲对弗兰克影响颇深，他尊重父亲，也记住父亲说的每一句话和做的每一件事。只有父亲是真正关心他的，父子关心亲如朋友，这点从记住弗兰克生日和父子两的交谈中可以看出。在弗兰克心中，父亲占有很重要的地位。以至于后面父母的离婚，让他开始想要报复银行和政府，因为在它看来，是他们的不公平对待让父亲破产，家庭破裂。因此，他走上了支票诈骗的路。 在这条路上，弗兰克充分的展现了他的聪明才智和敏锐的观察力，情商更是超高。在一次次成功的欺骗背后，是对细节和人心的把控。不管是当飞行员前在电视上看的相关飞行员的谈话，还是当医生时在电视上的一些谈话，这些对细节的注意和提前规划让他顺利的实施这一切。 在这趟旅途中，警官卡尔这个角色，我觉得他既是一个抓捕罪犯的警官，其实也是弗兰克唯一可以说真话的朋友。在这场猫鼠游戏中，双方都对对方产生了奇妙的感情，卡尔虽然在追捕弗兰克，但同时也在保护他。 这场猫鼠游戏，由家庭开始，也由家庭结束，父亲的死，母亲的改嫁，让他最终放弃了这场游戏，这场游戏对于弗兰克来说，也就失去了它的意义。 在影片的最后的前一段，弗兰克为什么要离开，离开后去了哪里，我无从而知。但从他裁掉记录在档案中的弗兰克被捕的照片可以找到一些蛛丝马迹。被FBI聘用后，压抑的工作和卡尔的无视让他想要回到从前，回到那场猫鼠游戏，也许那样，他才有和卡尔或者其他相互信任的人交流的机会。 影片的最后，弗兰克和卡尔一起讨论，一起工作，内容依旧是支票诈骗，依旧是那场猫鼠游戏。只是，老鼠搅动奶油变成了黄油，从桶里逃出，最终变成猫了。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"JavaScript 中 Number 有多少个?","slug":"js-number-scope","date":"2020-04-01T15:42:39.000Z","updated":"2020-12-07T05:44:32.063Z","comments":true,"path":"2020/04/01/js-number-scope/","link":"","permalink":"https://wingsico.github.io/2020/04/01/js-number-scope/","excerpt":"","text":"JavaScript 中 Number 到底有多少个？为了弄清这个问题，并且了解 JavaScript 的 Number 类型设计，将从规范上进行探究。 这个问题的来源是 winter 老师的 #重学前端# 课程，在讲解 Number 类型时提到这样一句话： JavaScript 中的 Number 类型有 18437736874454810627(即 2^64 - 2^53 + 3) 个值。 对于这个 2^64 - 2^53 + 3，winter老师并没有给出相关的解释，为了弄清楚这个的来源去查阅相关资料后进行整理。 为了知道这个问题的答案，需要先了解一下在JavaScript中Number是如何表示的。 JavaScript中的Number从ECMAScript规范中得知, Number的值是： primitive value corresponding to a double-precision 64-bit binary format IEEE 754-2008 value 意思就是：符合IEEE 754-2008 格式的 64 位双精度二进制的原始值。 在 IEEE 754 中，64位双精度浮点数中的64位由以下部分组成： s - 符号位，占 1 bit (数符) e - 指数位，占 11 bit (阶码=阶码真值+偏移量) f - 小数位，占 52 bit (尾数) 在规范中也明确的给出了各种情况的计算方式： 如果指数位e全为1，即 e = 11111111111，也就是十进制的2047(2^11-1)，且小数位f不为0，就超过了最大值，这样的数字无法正确表示，表示为 NaN(Not a Number)，此时会无视作为符号位的s 如果指数为e全为1，但小数位f为0的话，则根据符号位s得到两个特殊的值((-1)^s)，当s为0时，得到正无穷大，对于JS中的Infinity;当s为1时，得到负无穷大，对应-Infinity 如果指数e在 0&lt;e&lt;2^11-1 之间，这个表示 IEEE 认为的正常的浮点数区间，那么对应的数字的计算公式为：(-1)sx(2e-1023)x(1.f) 对于e-1023和1.f可能会有些疑惑。其中 1023 代表指数的偏移量，那么为什么会有这个偏移量呢，首先，作为11位的阶码，如果是无符号，那么表示的范围为 [0-2047], 当处于我们第三种情况时，e的范围要去掉0和2047，变成 [1,2046]，如果要表示正负，则需要使用一个bit去作为符号位，范围为 [-1022, 1023]，如果没有偏移量，那么需要引入补码，计算更加复杂，为了简化运算，则使用无符号的阶码，引入了偏移量的概念，通过偏移将其转换成 [1,2046]，所以偏移量为 1023。 那么对于1.f来说，因为对于浮点数，在规范中采用科学计数法的方法，对于十进制12.34来说，用科学技术法表示为 1.234x10^2，不会表示为 0.1234x10^3，其首位肯定是一个不为0的数字，那么在二进制中，只有0和1，那么他的首位就只能是1（用科学计数法表示，首位不能为0）。因为对于所有的浮点数他的首位都是1，因此可以省略一位进行，不需要额外占用1位，所以f实际上的有效位数有53位（其中首位是1）。在计算时需要使用上这个隐含的1。这也是1.f的由来 当e为0且f不为0时，是非规范化的数字，用于表示那些非常接近0的数字。 非规格化下，指数为，000 00000000 - 011 11111111 (偏移量) = - 100 00000001（转成10进制，减1取反）= - 1023从指数看，得知最小值是2^-1023，然而如果尾数是0.00000000 00000000 00000000 00000000 00000000 00000000 0001 不为0的情况，52位尾数相当于小数点还能虚拟化的向右移动51，可以取得更小的 2^-51, 所以最小值为 2^-1074 = Math.pow(2,-1074) 约等于 5e-324而JS最小值常量Number.MIN_VALUE正是5e-324所以(-5e-324,5e-324)之间的数比可表示的最小数还要小，显示成0，叫反向溢出。 如果指数是0且尾数也是0，则表示正负0的情况 解释从上面的分类我们得知，前两种是非正常的值，第一种含有 2^52 种情况（尾数有52位），第二种含有两种情况（正无穷和负无穷），那么根据排列组合，共有 2*1*2^52 = 2^53 种情况。这些非正常的值在JS中以 NaN、+Infinity、-Infinity表示，因此在Number中多了三种情况。那么总数就是 2^64-2^53+3，算得有 18437736874454810627 个值。 其中也可以解释为什么 NaN != NaN，因为 NaN 代表了 2^52 种情况，不是一个固定的值，而是一批值，自然也不会等于自身了。","categories":[{"name":"深入理解","slug":"深入理解","permalink":"https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"规范","slug":"规范","permalink":"https://wingsico.github.io/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"Unicode 简介","slug":"unicode-intro","date":"2020-04-01T15:40:52.000Z","updated":"2020-12-07T05:44:32.071Z","comments":true,"path":"2020/04/01/unicode-intro/","link":"","permalink":"https://wingsico.github.io/2020/04/01/unicode-intro/","excerpt":"","text":"Unicode是一种编码格式，它出现的主要原因是为了统一全球的符号编码，因为在Unicode之前，对于一些基本字符通常采用ASCII码的方式表示，但ASCII码是由一个字节组成的，最多只可以表示256个字符。 那么ASCII码能表示的字符是相当的有限了，且和其他的编码方式不能共同使用。因为对于同一个字符，别的编码方式可能对应的数字和ASCII中的不一致，这就导致了不通用的问题，这也是Unicode致力于解决的问题，它希望给世界上每一种文字系统的每一个字符，都分配一个唯一的整数，这些整数叫做代码点（Code Points）。 Unicode的数量理论上是无限的，但从中分出了 UTF-8, UTF-16, UTF-32等，其中的数字代表他可以表示的字符最少占用的bit数量。也就是 UTF-8 最少可以用一个字节表示一个字符，UTF-16 最少要用两个字节表示一个字符，UTF-32 最少要用 4 个字节来表示一个字符。 其中 UTF-8 是最灵活的，可以使用 1 - 8 个字节来表示字符， UTF-16 可以用两个字节或四个字节来表示一个字符，UTF-32 只能用四个字节来表达一个字符。 Unicode编码使用16进制，表示方法为 U+xxxx，U+0000 ~ U+FFFF 为基本多文种平面 (Base Multilingual Plane)。Unicode规范上规定了17个代码平面，分为 #0 ~ #16，其中 #0 就是 BMP，这17个平面理论上可以编码110多万个字符。 根据情况合理利用 UTF-8，UTF-16 等可以节省空间 (UTF-8需要占用空间来表示这个字符需要几个字节) 参考 Unicode令人混淆的概念 图说我的Unicode的理解","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"unicode","slug":"unicode","permalink":"https://wingsico.github.io/tags/unicode/"}]},{"title":"JavaScript 规范类型","slug":"js-spec-types","date":"2020-04-01T15:27:52.000Z","updated":"2020-12-07T05:44:32.064Z","comments":true,"path":"2020/04/01/js-spec-types/","link":"","permalink":"https://wingsico.github.io/2020/04/01/js-spec-types/","excerpt":"每一种语言都有自己的类型，但基本上都是遵从语言的规范类型。对于一些规范类型，winter描述的并不详细。因此，在查阅相关资料后，对齐进行补充。","text":"每一种语言都有自己的类型，但基本上都是遵从语言的规范类型。对于一些规范类型，winter描述的并不详细。因此，在查阅相关资料后，对齐进行补充。 规范类型共有以下7种规范类型： List和Record：List是用来描述参数列表的执行，其实跟ES中规定的数组的意义相近，但是写规范的时候还不存在ES的数组类型，所以使用List代替，写作&lt;&lt;1,2&gt;&gt;。而Record是用来描述算法中的数据聚合的，可以简单理解为ES中的对象，这类类型的话内部聚合了一个或多个命名字段（可以理解为键值对），其中命名字段的值一般是ES规范中的值或者是Record类型关联的抽象值（可以简单对应为JS中的基本类型的值或者是对象类型的值），字段的名称始终用 [[name]] 表示。你可以在JS对象的原型链上或原型链中的某个属性中看到类型的表示，例如 [[Scopes]]，但一般涉及语言实现，不会对外暴露出具体信息。 Set和Relation：Set主要是解释内存模型中使用的无序元素集合，即数学意义上的集合，其中的元素出现不超过一次，应该与ES6中的Set类型对应，在语言层面上会用于描述字符集之类的。Relation用于解释Set之间的关系，例如包含、交叉等，可以参考数学定义上的集合关系。 Completion Record：翻译过来即是完成时的记录，这里的完成时一般是指语句执行后的完成状态。这个完成状态有几种类型，例如正常的复赋值语句完成后，他的完成状态就是normal，但例如break, continue,return, throw这些语句执行完成后，其完成状态就是对应的状态（break,continue,return,throw）。ECMAScript规范中的每个运行时语义都显式或隐式返回一个报告其结果的完成Completion Record。Completion Record是一个Record，所以就可以用对象来描述它，它有三个字段： 12345Completion Record = &#123; [[type]] // Completion的类型，有 normal, break, continue, return, throw 5种类型 [[value]] // 返回的值为ES语言值或空，仅当当[[type]] 为 normal,return, throw时有值 [[target]] // 定向控制转移的目标label，为string或空，仅当[[type]] 为break, continue时有值&#125; type 对应的是完成状态的类型。而value、target从字面理解就是完成后得到的值和需要跳转的目标，这个目标的话在我们使用 break, coutinue 的时候可以在后面跟一个 label， 来指定要跳转的模板，即 continue xxx。 只有当 type 为 [[normal]] 时，才是正常的完成状态，其他的类型均为 中断的完成状态 Reference类型：用来解释诸如delete，typeof，赋值运算符，super关键字和其他语言特征等运算符的行为。 简单理解，就是如何去解析这些运算符的使用，有点类似词法作用域中对变量的LHS，RHS的查找。 Reference一般由三个部件组成 12345&#123; BaseValue // 值为：undefined,Object,Boolean,String,Symbol,Number,Environment Record. ReferencedName // String或Symbol值。 StrictReference // 布尔值，标识是否为严格模式&#125; 举个例子： 123const a = &#123; b: true&#125; 那么在查找b的时候就会得到一个Reference类型： 12345&#123; BaseValue: a, ReferencedName: b, StrictReference: false&#125; 这个类型从语言规范层面来说，可以解释为什么可以直接对字符串字面量使用字符串方法，例如 &quot;ABC&quot;.toLowerCase()，要执行这个语句，就要知道&quot;ABC&quot;.toLowerCase是什么，才能执行函数。这个语句会得到以下的Reference： 12345&#123; BaseValue: &quot;ABC&quot;, ReferencedName: toLowerCase, StrictReference: false&#125; Reference内置了一些方法，对这个例子而言，对 . 运算符解释时会对 Base Value 执行 [[GetValue]] 内置方法，由于 “ABC” 是原始值类型的 （Primitive，也就是在拆箱转换的时候提到的），会对 BaseValue 进行 ToObject(BaseValue), 将其变成 String 对象，再调用 toLowerCase 方法。 还有一些其他的内置方法，就不展开描述了。 Property Descriptor类型：就是属性描述符，用来解释对象属性的特性的操作，其值为Record类型，分为数据属性描述符和访问器属性描述符。例如 [[Writable]]，[[Get]] 等 Lexical Environment和Environment Record类型：主要是用来描述ES里作用域，标识符绑定等等。这个要详细描述的话有点长，可以查询一下相关资料。关于作用域、闭包的解释都可以从这个层面来说明。 Data Blocks：主要是描述二进制数据，用来描述字节大小（8位）数值的不同且可变的序列。这个我也不太懂，就不详细说明了。 结语以上就是对 winter 对规范类型的补充说明，也是我自己刨根问底的一种尝试吧。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"规范","slug":"规范","permalink":"https://wingsico.github.io/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"2019.6月 头条前端三面 面经","slug":"byteDance-intervies","date":"2019-06-12T09:06:10.000Z","updated":"2020-12-07T05:44:32.060Z","comments":true,"path":"2019/06/12/byteDance-intervies/","link":"","permalink":"https://wingsico.github.io/2019/06/12/byteDance-intervies/","excerpt":"简单记录一下第二次面试的经历，之后总结各个不熟悉知识点再进行整理。","text":"简单记录一下第二次面试的经历，之后总结各个不熟悉知识点再进行整理。 为什么选择实习考研or实习都是一种选择，不同的人适合不同的路，都需要结合自己的实际情况来决定。 就拿我自己来说吧，从大一开始接触互联网，接触前端后，自己对考研就没有什么想法了，因为当时自己对考研也没有什么概念，而且也遇到了自己比较喜欢的前端，觉得做前端是一件很幸福的事情。再加上优秀的学长拿到各种offer，自己心里对以后的自己也更加期盼，希望自己和他们一样优秀。 一步步走来，也遇到了很多困惑，也经常陷入到非常迷茫的状态，总是反问自己，自己是否真的适合做前端呢？加上周边人都非常优秀，自卑和不自信总是让我焦躁不安。加上大二下学期 Teambition 的面试失利，更觉得自己出来是根本找不到好工作/实习。再加上家人希望我考研的想法、女票考研、想深造等等的原因让我在大三上学期中下旬做出了去考研的决定，觉得尝试过了，就算失败没考上也是不会后悔，而且就算失败了到时候出来凭借自己三年来所学的前端知识应该也不至于没事做。抱着这样的想法，我踏上了考研的征途。 我开始了解有关考研的一切：学校、科目、复习计划、书籍等等等，开始每天英语，数学的轮番轰炸，开始6点半起床7/8点开始学习，到晚上10点多结束的生活，也早早的定好了意向学校。每天就是看视频、记笔记、学英语，但是学校也有一些事情(比如徐某的作业)，也会干扰的自己的一些复习计划，加上女票因为一些身体原因也经常需要去医院之类的，我也应该陪同。在各种干扰下，自己的一个学习进度一直很缓慢，做题也非常的慢，心中难免会焦虑。而周某人=。=一天到晚给我发各种实习，扰乱我的心境(雾)，让我一再有屏蔽他的想法(23333)。 但自己还是硬着头皮坚持了几个月，但每天并没有学习一天的充实感，学习进展也随着难度的增大而更加缓慢。之后让我再去思考到底是考研或者实习就发生在彪彪去头条实习之后。我开始仔细考虑，自己是否真的要去考研。 花了一个星期，我一直考虑以下问题： 考研的目的是什么 以后想从事什么方面的工作 考研会给我带来什么，实习会给我带来什么 对于以后想从事的行业是否对学历有着硬性的要求 自己现在的水平能不能找到一份较为满意的实习 一年后如果失败了如何应对 是否会后悔自己的决定 我的想法依次如下： 对我而言，考研是为了： 提高学历 深造以获得更多选择 重新学习大学的课程 陪女票一起，度过这段困难的时期 满足家人的要求 提高自己的竞争力 了解了关于云计算、大数据之类的，再读了一些关于分布式的论文后觉得这行也挺有意思的，想着如果能考上研究生希望去研究这一方面的技术。或者继续从事前端相关的事情。但后面更深入的了解关于云计算、大数据的一些具体的东西，觉得自己可能不太适合。但事无绝对，你没有深入一个行业去了解你永远无法知道自己到底适不适合它。但至少，前端我是很喜欢的也愿意去做相关的行业。 考研给我带来的也就是我考研的目的，而实习的话我在最初的选择也只有前端这一个选择，那么实习给我带来的是更早的接触公司的一些实际需要考虑的一些问题，技术上的提升，更早的经济收入、社会了解等等。 如果从事前端，在学历要求上更没有其他岗位的那么严格，初级阶段门槛也比较低。但是如果想往人工智能、大数据等方向进行发展的话，大部分还是会要求一个研究生的学历的。因为它需要这样一个较高门槛才可以去真正做出一些东西来的。 对于自己的水平，我一直是不是很自信，觉得自己学的东西比较浅，也有一些浮躁。虽然之前大二Teambition面试失败，但是很大一部分原因归结于自己没有准备(裸试可还行。。)，所以对于自己的水平到底能否去承担起一个这样的职位还是没有底的。而后面彪彪拿到offer也给我了一些信心，我觉得我跟彪彪的水平差不多，我也许可以去尝试一下。 对于失败，我从一开始就非常的坚定，绝不二战的，失败了就直接去找前端的实习工作。但是，一年前端的空窗期会对自己的水平造成多大的影响以及前端行业的一年后会发展成什么样自己能否跟上，这些都是让我所担忧的。 选择前端，我不会后悔，至少我对考研我尝试过几个月，了解自己的一个学习状态。而对于选择考研，并不知道自己是否会后悔。 综合考虑一些问题之后，和家里人也沟通了很多次，各种思想斗争后，还是决定重拾前端。对于前端，我始终有着很大的热情，能够且愿意把时间花在上面，就算是遇到困难也会慢慢沉下心去解决。对于考研，我已经尝试过了，觉得自己的精力无法再全身心的投入进去，就算之后想起这个决定也不会觉得后悔。 就这样，我做出了这个决定，一个不再回头的决定 —— 找实习 实习准备由于花费了数个月去准备考研，对于前端的知识就忘了一些，在提前联系了在头条的学长咨询相关情况后，决定先花一个月来准备，刚开始的计划是这样： 每天两道leetcode算法题 刷面经 每天看看公众号文章以及掘金文章 做一个关于react + typescript的项目 读一本关于前端工程化的书，再看看你不知道javascript 限定自己最晚投简历的一个时间(定为5月31日，但实际上6月2日才投) 每天解决一个自己不熟悉的点，列出了一份清单并贴在墙上 后面发现写新的项目有点来不及，时间不是很充裕。真正做到了的也就是把一些不熟悉的清单项仔仔细细的去读懂，每天刷两道算法题(到了后面就刷的更少了)，读的书也只读了差不多一半，到后面快要到deadline就直接快速翻了翻相关的内容。 以上计划在这次面试除了第三点（也就是再去做个项目），都对这次面试起到了比较大的作用，其中起了较大作用的是 1， 2，6，7。然后最重要的就是刷面经了，通过刷面经，基本上解决了百分之六十的问题，很多被问到的问题也是我通过刷面经之后才知道的。所以刷面经很重要！！很重要！！很重要！！ 关于简历的话，我还是使用了子健学长的简历模板，然后彪彪用的也是(然后在面试的时候就问了为啥你俩简历看起来样子都差不多)。如果有内推的话，简历只要把你的信息写好，做过哪些项目，会什么技术之类的写好就行，主要还是看笔试面试。 然后在这篇文章的最后会给出我看的一些比较好的文章的链接。 面试每轮面试基本上都有一个自我介绍环境，简单介绍一下自己的信息，前端经历，项目经历，性格什么的。 一面第一面的面试官感觉是个很随和很好相处的人，给我的感觉就是聊天没有什么压力，如果你答对了会给你一些反馈，答错了也会给你解释一下(虽然我答错的题目他也不能很清晰说出个所以然来) 一面问的问题都比较基础，我把我能想起来的都写在下面： 自己实现一个bind 写一个算法：找到一个数组的子数组，使得这个子数组的和大于一个给定的值n，并且这个子数组最短。比如arr = [1,2,3,4,5,6]，n= 10，那么最短的就是 [5,6] vue.$nextTick原理，回退方案 异步队列，宏任务微任务(通过代码的执行顺序考察) 如何判断数据类型，为什么用 Object.prototype.toString.call() 来做，直接toString为什么不行 setImmediate和setTimeout区别 闭包 逻辑运算(&amp;&amp;, || , !)，运算符优先级 this指向 “aaa” == new String(“aaa”) // true or false null == undefined // true or false 字符串和数字运算得到的结果，比如 1 + “2” + 1 或者 “2” + 1 + “2” 或者 “2” - 0 + 3之类的 es6 modules 和 commonjs 模块方案之间的区别(不是用法上的区别) http状态码 CSRF是什么，如何防御 垂直居中方案 position:relative相对谁定位 new操作做了哪些事情 上面只是说了一个大概的，面试官实际上拿了一份pdf笔试题给我做了一下，然后能想起来就这么多，基本上都回答出来了，除了第13点,和第2点(基本思路对了，但是代码跑了个死循环=-=) 然后真心觉得面试官很能聊得来，就像聊天一样没有什么压力。 二面二面的面试官比较严肃，给人一种居高临下的压力。这轮面试表现不太好，一方面是因为面对比较严肃的面试官我内心压力挺大，很多问题都有点答非所问。另一方面有些场景下原理了解的不是特别深，被问到就有点慌了阵脚。 下面是我能回想起来的一些问题： cookie，sessionStorage, localStorage 作用和区别 写一个寄生组合式继承 说一下事件的执行机制(事件捕获、冒泡) 用过Jquery吗？$.on用过吗？ 介绍一下http https的通信原理 http2.0有哪些新特性 Vue的数据劫持，用Object.defineProperty相比于Proxy有什么缺点 Vue为什么需要this.$set requestAnimationFrame是什么，用它做动画和setTimeout有什么区别 前端路由的实现原理(history, hash) 使用命令式代码进行路由跳转的时候(Router.push)，如何监听url的变化，(Router.push的具体实现相当于黑盒，不能修改) 什么是反向代理 网页扫码登陆是怎么做的 同源策略，如何跨域请求资源 请求跨域资源要发几次请求，请求同源资源发几次请求，option请求是做什么的 http的请求中包含哪些属性(比如Content-type之类的) 了解哪些加密算法，有什么区别 资源的缓存(协商缓存、强缓存)，区别 说一下事件委托 对nodejs了解多少 你的优势是什么 你的缺点是什么 你有什么问题想问的吗？ 3,4,8,11,12,16,23这几点感觉回答的不太好，虽然原理都知道，但是进行一些扩展问一下就不懂了，比如说知道vue数据劫持的原理是什么，但是不知道那两个方案有什么区别。虽然知道路由实现的原理，但是对于后面的给出的场景(监听url变化)没有想到一个很好的解决方案(连最基本的暴力setInterval都没想到)。对于请求中包含的属性也没有说太多，感觉是因为紧张想不起来。 然后说缺点的时候有点作死，说自己对于不喜欢的事情可能不是那么上心。。然后面试官说那给你分配你一些你可能不喜欢的业务的时候你是不是也不上心不好好做。。这个缺点我没有提前去想好怎么说，然后感觉就比较作死。。 然后后面面试官也看出我比较紧张(虽然我也跟他说了)，然后让我调整心态，放松，不要沮丧。 wtf？我听到不要沮丧的时候我整个人都不好了。。难道我就死在二面了。。让我失败了也不要沮丧什么的。。当时我的心就凉了半截。。不过最后他说了这一轮给我过。。才放下心来。 后面问你有没有什么问题想问，我当时又作死去问他他觉得我表现怎么样。。不说了，最好不要问这个问题，现在想想脑子是不是哪根筋答错了。应该可以问问项目规划或者技术栈什么的。 对于二面，我想说的就是，学习知识的时候要多思考，多问问为什么，才能有去查看原理的一些问题。其次，面对自己不懂的问题，不要含糊的回答，大方的直截了当地说不懂就行了，不知道 &gt; 乱说。然后就是要调整好自己的心态，面对压力的表现也是考核的一部分。(然后吐槽一下我花了大量时间看React的东西然后一点没问。。) 三面三面面试官也比较随和，交流也很舒服。但是感觉说话不多，不过整个面试下来都是比较轻松的。 这一面关于技术的问的比较少，就问了一道leetcode上面的算法题。 寻找两个有序数组的中位数：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数。偶数需要将中间两个值除以二。 这道题我做过，在leetcode上是hard级别的题目，但是要求是O(log(n+m))的复杂度，我写了一个O(n+m)的。然后问我有没有更快的算法，有没有O(log(n+m))级别的实现。但这个复杂度的算法有点复杂，需要提前进行一些数学运算在结合二分查找来做优化，一时半会也没想出来，不过他也没有追究这个问题。 之后就问了项目相关，有没有什么项目可以给他看一下的，然后我就拿了重构的Us项目给他看(由于我已经没有一些权限了，所以只能看到家园圈子那一块)，然后问了问你做了哪些事情，怎么设计的之类的问题。这个就是结合项目和你当时做的一些方案去说了。(所以说项目很重要，项目经验很重要) 在之后就问问一下简历上写的用node做爬虫的，是怎么做的。然后我就说了一下具体的实现难点，比如异步、并发控制，代理ip池，缓存中间数据等等，然后问了我为什么做这个项目，就又说到了这个是拿去参加比赛的项目中的一部分。然后就问了问我比赛的流程，怎么比的，获奖了没有，小组几个人完成的之类。 在之后又问了问高考成绩，跟当时一本线比高了多少分什么的。再之后就谈了谈实习相关，比如能实习多久之类的 总得来说三面是最简单的，没有过多的技术谈话，整个过程基本上都是我在不停的说，然后也是三个面试中用时最短的了，面完结束后就让我等hr电话了。 HR(这个不算面试，就是聊天)这个就直接跟HR在电话中交谈，大概花了十多分钟。 问的问题： 家住哪 能实习多久 会去秋招吗 如果以后有更好的工作机会(腾讯阿里)，会去吗 对于北京觉不觉得太远了 毕业是考研还是工作呢 有什么想问的吗 对于会不会去秋招我的回答是会去，会去尝试一下更好的公司面试是怎么样的，看看自己水平如何，但是还是留在头条实习。对于以后有更好的机会我老老实实回答的会去。然后对于北京我觉得还是有点远的，不过实习嘛，地点在我看来就没有那么重要。 总结总的来说头条的面试效率很高，我提交简历一两个小时后就跟我联系约面试时间了，然后半个下午就完成了一二轮面试，第二天进行的第三面，每次面试持续时间一个小时左右。总之有几点建议： 面试的话一定要刷面经 一定要对自己学的知识再去深入的了解一下 要去做算法题 遇到不会的不要慌了阵脚，要及时调整好心态 知之为知之，不知为不知 至少做一个拿得出手项目 最后希望大家都能拿到自己心仪的offer。 参考链接 牛客网前端面试总结 小火柴的前端小站 面试官系列： 面试官系列(1): 如何实现深克隆 面试官系列(2): Event Bus的实现 面试官系列(3): 前端路由的实现 面试官系列(4): 基于Proxy 数据劫持的双向绑定优势所在 面试官系列(5): 你为什么使用前端框架 面试官系列(6): 写过『通用前端组件』吗? 面试官系列(7): 聊一聊 Babel 面试官(8): React 强调的『不可变数据结构』怎么实现? forthealllight’s blog 前端面试搜集 BAT前端开发面经 - 附解答 以上均为参考链接，且都有一些回答的。然后感觉刷面经的主要作用就是让你知道你自己哪里不懂，然后再去通过其他方式来","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://wingsico.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2019年-2020年目标规划","slug":"2019-plan-1","date":"2019-06-11T15:13:10.000Z","updated":"2020-12-07T05:44:32.060Z","comments":true,"path":"2019/06/11/2019-plan-1/","link":"","permalink":"https://wingsico.github.io/2019/06/11/2019-plan-1/","excerpt":"作为一个有略微拖延症的患者，觉得清单驱动行为是很有必要的。现将一些目标规划列出来，驱动自己将其完成。 在完成过程中，也将把其整理成博客，希望今年还能取得更多进步！","text":"作为一个有略微拖延症的患者，觉得清单驱动行为是很有必要的。现将一些目标规划列出来，驱动自己将其完成。 在完成过程中，也将把其整理成博客，希望今年还能取得更多进步！ 技术类HTML5深入理解系列 svg canvas video shadow-dom web-component web worker CSS3 Javascript深入理解系列 Proxy Class Generator Async Promise Blob 垃圾收集 正则表达式 Iterator Object.defineProperty() Reflection typescript ES6/7/8 等新特性 React深入理解系列 Fiber Hooks HoC render function immutable pure function 更新、渲染机制 jsx 设计方案 项目 React + typescript + [状态管理方案 Mobx,Redux] + antd 重构 US React + Koa2 + Mongodb 写一个自己的博客 Node深入理解系列 异步 IO 事件驱动 异步并发控制 V8 Buffer 中间件 流 Vue深入理解系列 mixins observable Vue.use diretives provide/inject 设计方案 通用理解并实践 Webpack Gulp PostCSS Scss 设计模式 算法 函数式编程 网络 数据结构 数据库 Git 测试 工程化 生活类 减肥 15 斤 养成良好作息习惯 学会炒更多菜 女票考研成功！ 坚持健身 存钱！ 认识更多的人 读一些非技术类的书 加油，为了美好青春而战，为了家人，也为了自己！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"规划","slug":"规划","permalink":"https://wingsico.github.io/tags/%E8%A7%84%E5%88%92/"}]},{"title":"Mac OS 重置MySQL密码","slug":"mysql-password-reset","date":"2018-03-27T08:26:53.000Z","updated":"2020-12-07T05:44:32.064Z","comments":true,"path":"2018/03/27/mysql-password-reset/","link":"","permalink":"https://wingsico.github.io/2018/03/27/mysql-password-reset/","excerpt":"如何在 Mac OS 上重置 MySQL 服务密码?","text":"如何在 Mac OS 上重置 MySQL 服务密码? 1. 停止 MySQL 服务1sudo /usr/local/mysql/support-files/mysql.server stop 2. 进入安全模式1sudo mysqld\\_safe --skip-grant-tables 这个地方，如果你 alias 了 mysqlld\\_safe 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 /usr/local/mysql/bin/mysqld/usafe。 说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。 这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。 3. 新打开一个终端，进入 MySQL1mysql -u root -p 这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： /usr/local/mysql/bin/mysql -u root -p 然后输入任意密码就可以进入 MySQL 了。 4. 修改密码进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。 MySQL 的用户信息是存在 mysql.user 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。 12use mysql; # 切换数据库describe user; # 查看user表的字段 然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。 然后修改密码： 1UPDATE mysql.user SET authentication\\_string=PASSWORD(&#x27;123456&#x27;) where User=&#x27;root&#x27;; # 将root用户密码改成 123456 5. 刷新权限，使配置生效1flush privileges; 最后再启动 MySQL 1sudo /usr/local/mysql/support-files/mysql.server start","categories":[{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://wingsico.github.io/tags/mysql/"}]},{"title":"vue-router 非定义路由的访问","slug":"vue-router-404","date":"2018-03-15T16:54:12.000Z","updated":"2020-12-07T05:44:32.072Z","comments":true,"path":"2018/03/16/vue-router-404/","link":"","permalink":"https://wingsico.github.io/2018/03/16/vue-router-404/","excerpt":"在写vue的路由表时，通常会遇到这样的一个问题，我已经定义了一系列路由，但我想要用户在访问非定义的路由的时候返回一个提示或者重定向至指定页面。该如何实现？","text":"在写vue的路由表时，通常会遇到这样的一个问题，我已经定义了一系列路由，但我想要用户在访问非定义的路由的时候返回一个提示或者重定向至指定页面。该如何实现？ 解决方案首先我想到的是监听hash的变化，根据已经定义的路由来判断是否是非定义的路由，但这样有个问题，当定义其他路由或修改路由的时候，监听路由变化的函数也要修改，这就造成了一个很强的耦合性，因此此方法并不实用。 但略微查看vue-router的官方文档，没有看到相关的解决方案，于是在 google 搜索相关的问题，在一篇博客里看到一句话： 又一个在使用 Vue 过程中遇到的新坑。首先踩这个坑都怪我自己看文档不够仔细，所以告诫大家，看文档真的一定要认认真真的一个个字的认真的品味。 vue-router 动态路由匹配 中有这么一段： 匹配优先级 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 吓得我又回去翻看了一下文档，果然，在最最下面有一个匹配优先级。。 因此，想到了一个更加简单的方法去实现限制非定义路由的访问： 123456789101112131415&#123; // 404 置后 path: &#x27;*&#x27;, component: &#123; beforeCreate () &#123; window.swal(&#123; type: &#x27;warning&#x27;, title: &#x27;404 NOT FOUND&#x27;, timer: 1000, showConfirmButton: false &#125;) this.$router.replace(&#x27;/&#x27;) &#125;, template: &#x27;&lt;div&gt;&lt;/div&gt;&#x27; &#125;&#125; 这里的window.swal是引用的sweetalert.js的一个方法，主要作用就是一个美化提示弹框。 而对于这个component对象内的beforeCreate就很陌生了，为什么配置路由的component会出现这个，难道是属于路由的生命周期？ 但转念一想，component里本来应该的数据是什么？ 1234&#123; ... component: require(&#x27;@/views/hello&#x27;) // 类似写法&#125; component 内本该是由一个单文件组件 (.vue 文件) export出来的，因此，我认为这里的beforeCreated其实是组件的生命周期，因为在非单文件组件中，定义一个组件的方式就是如此： 这是一个官方的 demo: 123456789101112var Child = &#123; template: &#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27;, data () &#123; ... &#125;&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父组件模板中可用 &#x27;my-component&#x27;: Child &#125;&#125;) 所以由此可以看出，我的判断应该无误，ok，大功告成！","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wingsico.github.io/tags/vue/"}]},{"title":"函数式编程之curry","slug":"functional-programming-1","date":"2018-03-15T15:43:03.000Z","updated":"2020-12-07T05:44:32.063Z","comments":true,"path":"2018/03/15/functional-programming-1/","link":"","permalink":"https://wingsico.github.io/2018/03/15/functional-programming-1/","excerpt":"前言最近开始学习函数式编程，对函数式编程有了更多的一点点认识，对函数的 curry 接触了一点点，以此作为记录，写下当前感悟","text":"前言最近开始学习函数式编程，对函数式编程有了更多的一点点认识，对函数的 curry 接触了一点点，以此作为记录，写下当前感悟 思考先来看一个常见的需求： 现给定一个字符串： const STRING = “This is the mid day show with Cheryl Waters” 请将空格替换成”-“ 这是一个很简单的需求，很自然的写下： 12345const replaceSpaceToStrike = str =&gt; &#123; return str.replace(/ /g, &quot;-&quot;);&#125;;replace(STRING); 或者是写个更具有拓展性的函数: 12345const replace = (reg, replacement, str) =&gt; &#123; return str.replace(reg, replacement);&#125;;replace(/\\s+/g, &quot;-&quot;, STRING); 发现参数多而杂乱。那么把它 curry 化我们应该如何去写: 1234567const replace = what =&gt; replacement =&gt; str =&gt; str.replace(what, replacement);const noSpaces = replace(/\\s+/g);const cenosred = noSpaces(&quot;-&quot;);cenosred(STRING); 这里可以看到 curry 化在完成最终需求之前生成了许多 curry 帮助函数, 这里表明了一种 预加载函数 的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 相比于之前的解决方案，它需要更多的代码，但只需要参入一部分参数，就能的到一个新的函数。相对于之前的方案，它更加灵活，同时减少了同时传参的个数。 这个例子可能没有突出函数式 curry 化的优点，再举一个例子： 1const getChildren = x =&gt; x.childNodes; // 获得一个节点的子节点 这是针对一个元素的函数， 利用curry化，我们可以很容易扩展到数组： 12const map = f =&gt; arr =&gt; arr.map(f);const getAllChildren = map(getChildren); 通常我们不定义直接操作数组的函数，因为只需内联调用 map(getChildren) 就能达到目的。这一点同样适用于 sort、filter 以及其他的 高阶函数（higher order function）（高阶函数：参数或返回值为函数的函数）。 小结curry 函数用起来非常得心应手，使用它简直就是一种享受。它堪称手头必备工具，能够让函数式编程不那么繁琐和沉闷。 通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。 此外，我们还可以引入 lodash 和 ramda 中的 curry 函数，帮助我们更好的实现curry化。","categories":[{"name":"深入理解","slug":"深入理解","permalink":"https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"函数式","slug":"函数式","permalink":"https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"代码片段理解(2)","slug":"codes-understanding-2","date":"2018-03-14T02:11:44.000Z","updated":"2020-12-07T05:44:32.061Z","comments":true,"path":"2018/03/14/codes-understanding-2/","link":"","permalink":"https://wingsico.github.io/2018/03/14/codes-understanding-2/","excerpt":"12345678910const pick = (field = &quot;&quot;, object = &#123;&#125;) =&gt; object[field];const pluck = (field, array) =&gt; array.map(object =&gt; pick(field, object));const deepPluck = (field, array) =&gt; array.map(object =&gt; deepPick(field, object));const deepPick = (fields, object = &#123;&#125;) =&gt; &#123; const [first, ...remaining] = fields.split(&quot;.&quot;); return remaining.length ? deepPick(remaining.join(&quot;.&quot;), object[first]) : object[first];&#125;;","text":"12345678910const pick = (field = &quot;&quot;, object = &#123;&#125;) =&gt; object[field];const pluck = (field, array) =&gt; array.map(object =&gt; pick(field, object));const deepPluck = (field, array) =&gt; array.map(object =&gt; deepPick(field, object));const deepPick = (fields, object = &#123;&#125;) =&gt; &#123; const [first, ...remaining] = fields.split(&quot;.&quot;); return remaining.length ? deepPick(remaining.join(&quot;.&quot;), object[first]) : object[first];&#125;; 预备知识接着之前那一段 函数嵌套 的代码，这一段我觉得简单许多，至少不会在一开始就比较懵逼，这里需要了解的知识主要有以下几个: 默认参数 Array.prototype.map 箭头函数 扩展运算符 默认参数默认参数没什么好说的，详情看ES6 函数的扩展 Array.proptotype.mapArray.prototype.map，参数为函数，函数的参数为数组中的一个值，对数组的每一个值执行一个操作，并把需要的值 return 出来，每一项 return 出来的值构成一个新的数组，不改变原数组。 箭头函数箭头函数这里也没有用到特殊的操作，与上一节一致 （ 扩展运算符主要是数组的解构赋值以及扩展运算符的结合。 举个例子 123let [first, ...rest] = [1, 2, 3, 4];console.log(first); // 1console.log(rest); // [2, 3, 4] 理解第一行第一行代码还是比较好理解的，平常也用的比较多，即提取出对象对应 key 的 value，用 es5 重写: 12345function pick(key, object) &#123; key = key === undefined ? &quot;&quot; : key; object = object || &#123;&#125;; return object[key];&#125; 但 es6 的写法清晰很多，默认参数可以让代码阅读更加明了，可以一目了然的看出哪些参数必须传，哪些参数可以不传，不需要查看函数内部，除此之外，还可以便于后期的迭代，如果之后不需要这个参数了，在对外接口中彻底拿掉这个函数，也不会导致不可用的问题出现。对于是否设置默认参数，要根据当前实际情况来看，如果参数有被遗漏的情况，则最好加上默认参数。 第二行作用：将一个由对象组成的数组中的每一项(object)中对应的(field)取出，并组成一个新的数组，需要注意的一点，对于数组中某一项没有对应的 key 的时候，不会跳过而是得到undefined，即长度始终保持与对象数组一致。 举个例子: 123let objs = [&#123; a: 1 &#125;, &#123; c: 1 &#125;, &#123; a: 3 &#125;];let key = &quot;a&quot;;pluck(key, objs); // [1, undefined, 3] 第三行与第二行形式结构一致，唯一不同的是 map 内参数函数的返回值。因此只需了解第四行代码即可。 第四行首先要注意的就是参数的命名，从pick中的field变为了fields，从函数体可以了解到该函数的功能： 采用递归的形式，取得对象更深层对象的属性值 用一个例子就很好解释: 12345678910// 一个具有多重对象嵌套的对象let example = &#123; a: &#123; b: &#123; c: &quot;1&quot; &#125; &#125;&#125;;let keys = &quot;a.b.c&quot;; // 即点操作符，取出c的值deepPluck(keys, example); // 1 小结分析代码的过程就是一个拆解代码的过程，将一个看似复杂的代码段逐步拆解，分解成一个个的小的易懂的片段，最后将其组合即可。分析后最好再自己实现一遍以加深印象。","categories":[{"name":"深入理解","slug":"深入理解","permalink":"https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://wingsico.github.io/tags/es6/"},{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"函数式","slug":"函数式","permalink":"https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"代码片段理解(1)","slug":"codes-understanding-1","date":"2018-03-13T14:57:18.000Z","updated":"2020-12-07T05:44:32.061Z","comments":true,"path":"2018/03/13/codes-understanding-1/","link":"","permalink":"https://wingsico.github.io/2018/03/13/codes-understanding-1/","excerpt":"12const compose = (...fns) =&gt; arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg);","text":"12const compose = (...fns) =&gt; arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg); 预备知识在学习 react 过程中碰到这样的一段代码，勉强能知道这是一段函数式的代码，并且配合 es6 的箭头函数以及扩展运算符组合而成的，但最初看到这段代码的时候还是把我难住了，主要问题有三个： 两个箭头函数写法 函数作为参数传递 Array.prototype.reduce 用法 () =&gt; () =&gt; console.log(1)这个不难理解，箭头函数可以省略大括号，则箭头后跟着的就是其返回值，在这里他的返回值就是一个函数，这里也就是一个函数式编程的思想，函数作为一等公民，和其他类型的值用法可以一致。用 es5 重写一下: 1234567var test = function() &#123; return function() &#123; console.log(1); &#125;;&#125;;test(); // 返回: function () &#123;console.log(1)&#125;test()(); // 1 (fn) =&gt; fn(‘我被参数执行了’)这个也比较好理解，根据第一点，函数可以作为返回值，也能作为参数，用一个简单的例子表示: 12345let fn = text =&gt; console.log(text)(function(fn) &#123; let text = &quot;我被参数执行了&quot;; fn(text); &#125;)(); // 打印出: 我被参数执行了 Array.prototype.reduce至于reduce，之前对他的了解只有是累加器，把数组前面的值与目前的值进行运算，并作为一个值与数组的下一项的值进行运算，是从这样一个例子得到的认知: 1[1, 2, 3].reduce((pre, cur) =&gt; pre + cur, 0); // 6 对 reduce 有一个模糊的认识，且不清楚他拥有的参数及其含义。查阅相关资料后，了解了： reduce 共有两个参数，第一个参数为callback，即回调函数，用于对数组内的值进行操作，且必须有返回值;第二个参数为initialValue，是一个可选的参数，即初始值，即第一个 pre 的值初始化，如果没有设置这个参数，则 pre 默认为第一个数组的值，需要注意的是，初始值的类型决定了最后得到的结果的类型，这两者是保持一致的 拿上面的那个例子来说： 1234567891011[1, 2, 3].reduce((pre, cur) =&gt; pre + cur, 0); // 6// 实际执行过程/* 1. pre === 0, cur === 1 2. pre === 0 + 1, cur === 2 3. pre === 0 + 1 + 2, cur === 3 4. pre === 0 + 1 + 2 + 3, cur === &quot;&quot; */// 比数组的长度多执行一次// 若没有设置初始值，则和数组的长度的执行次数一致 这个也很好理解，将前面 return 的值给下一次使用，但是，为了理解我们最开始给出的那段代码，这个值就是一个问题，这个也同样是和第一点和第二点一样, 甚至是第一点和第二点的结合，函数式编程思想，函数作为参数传递进来，又作为返回值给下一次使用。 这里只用到第二点，函数作为参数传递。 至此，解决了三个问题，为了读懂这一段代码，需要把这三个知识串在一起使用。 理解首先，要理解第一个参数fns，从参数的命名上看，我们可以知道fns应该表示成数组，然后需要注意的是：传递的参数不应该以数组的形式传递（这也是我一开始遇到的问题，并且困扰到最后，也是对扩展运算符的了解不够或者误解），而应该以多个参数的形式传递。具体详情查看es6 数组的扩展 再者是连续的两个双箭头，() =&gt; ... =&gt; ...意味着他是一个会返回函数的函数，第一次调用的结果: 1arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg); 通过对reduce的理解，composed为数组的前一个 return 的值(在 arg 缺省的情况下，数组的第一项作为 composed)，cur为当前的值。 注意这里对值的定义，对于 reduce 来说，值可以是任何一种类型（当没有初始值限制的时候），当然也包括函数，对于我们这一段代码来说，当初始值缺省时，第一项的返回值可以不为函数，最后一项的返回值也可以不为函数，也可以没有返回值，但中间部分的返回值必须为一个函数，由f(composed)可以了解到这一点； 当初始值存在时，则从第一项到倒数第二项的参数的返回值必须为函数（因为第一项需要接受初始值作为参数的传递）。 之前还是没看懂，现在终于了解了，对于这个代码，每一个参数必须为函数，且均要有参数（如果没有给 arg 赋值的话，第一个可以没有参数），这个函数的返回值与参数 arg 有关，arg 是一直存在的，之前没搞懂这一点，就算调用时不赋值，也为 undefined，因此第一个 pre 永远为 undefined（除非你给 arg 赋值），且除了最后一个函数外，均必须要有返回值，若最后一个函数没有返回值，则整体就没有返回值。 由此，可以得到这个compose函数的用法 12345678let first = () =&gt; 1;let second = a =&gt; a + 1;let last = b =&gt; console.log(b);let result = compose(first, second, last)(); // 打印出 2，不是返回值为2console.log(result); // undefinedlast = b =&gt; b + 1;result = compose(first, second, last)(); // 返回值为3console.log(result); // 3 相当于 1last(second(first())); // 返回值为2 小结至此，终于搞明白了compose函数的作用，就是为了以一个简明的方式实现函数的嵌套，即组合嵌套函数，有多个参数，实参为函数的形式存在，其返回值也为函数，即组合之后的函数。","categories":[{"name":"深入理解","slug":"深入理解","permalink":"https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://wingsico.github.io/tags/es6/"},{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"函数式","slug":"函数式","permalink":"https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"[nginx] 服务器无法访问 + 502 bad gateway","slug":"nginx-502","date":"2018-01-13T01:38:19.000Z","updated":"2020-12-07T05:44:32.065Z","comments":true,"path":"2018/01/13/nginx-502/","link":"","permalink":"https://wingsico.github.io/2018/01/13/nginx-502/","excerpt":"在腾讯云制作镜像的时候强制关闭了服务器，后面外网就访问不了服务器了。记录一下解决过程","text":"在腾讯云制作镜像的时候强制关闭了服务器，后面外网就访问不了服务器了。记录一下解决过程 解决过程一开始以为是文件丢失了，后面用 vnc 上去看了之后文件都还在，然后我就又重启了好几遍，网页还是访问不了，于是我先放在一边。 第二天再看了一下，发现二级域名下的资源可以访问，但主域名的无法访问，显示 502 bad gateway。 于是觉得应该是 nginx 的问题，试图重启 nginx 1systemctl reload nginx 失败，报了个错: 1Job for nginx.service invalid. 难道是没有开启？ 1systemctl start nginx 。。报了个更长的错 1Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details. 根据它的提示我试了一下 1systemctl status nginx.service 得到如下的信息: 123456789101112131415161718● nginx.service - The nginx HTTP and reverse proxy server Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled) Active: failed (Result: exit-code) since Fri 2018-01-12 20:33:08 CST; 27s ago Process: 2702 ExecStart=/usr/sbin/nginx (code=exited, status=1/FAILURE) Process: 2698 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS) Process: 2697 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)Jan 12 20:33:06 VM_48_13_centos nginx[2702]: nginx: [emerg] bind() to [::]:80 failed (98: ...e)Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] bind() to 0.0.0.0:80 failed (9...e)Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] bind() to [::]:80 failed (98: ...e)Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] bind() to 0.0.0.0:80 failed (9...e)Jan 12 20:33:07 VM_48_13_centos nginx[2702]: nginx: [emerg] bind() to [::]:80 failed (98: ...e)Jan 12 20:33:08 VM_48_13_centos nginx[2702]: nginx: [emerg] still could not bind()Jan 12 20:33:08 VM_48_13_centos systemd[1]: nginx.service: control process exited, code=e...s=1Jan 12 20:33:08 VM_48_13_centos systemd[1]: Failed to start The nginx HTTP and reverse pr...er.Jan 12 20:33:08 VM_48_13_centos systemd[1]: Unit nginx.service entered failed state.Jan 12 20:33:08 VM_48_13_centos systemd[1]: nginx.service failed.Hint: Some lines were ellipsized, use -l to show in full. 不是很看得懂，看到一堆 failed 和 disabled. 先看一下 nginx 的进程。 1234ps -ef | grep nginxroot 2516 1 0 Jan12 ? 00:00:00 nginx: master process nginxnginx 2517 2516 0 Jan12 ? 00:00:00 nginx: worker processroot 5308 4831 0 09:04 pts/1 00:00:00 grep --color=auto nginx 把 nginx 进程关闭 1pkill -9 nginx 再次启动 nginx 1systemctl start nginx 嗯，没有消息就是最好的消息，没有报错了，启动成功。但这个时候主域名还是访问不了，想到主域名上面放的是博客，博客是 wordpress 驱动的，用的 php，想到可能是 php 挂死了，那重启一下 php-fpm 吧。 12killall php-fpm./opt/php56/sbin/php-fpm 再访问一下主域名，ok，博客成功显示。","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://wingsico.github.io/tags/nginx/"},{"name":"服务器","slug":"服务器","permalink":"https://wingsico.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"[vue-cli] 解决 npm run dev 之后在某些浏览器上一片空白","slug":"vue-cli-whitepage","date":"2018-01-05T08:02:33.000Z","updated":"2020-12-07T05:44:32.072Z","comments":true,"path":"2018/01/05/vue-cli-whitepage/","link":"","permalink":"https://wingsico.github.io/2018/01/05/vue-cli-whitepage/","excerpt":"使用开发模式启动项目后，在同一局域网通过手机连接项目，在一些手机厂商自带浏览器上产生空白页面，渲染失败。","text":"使用开发模式启动项目后，在同一局域网通过手机连接项目，在一些手机厂商自带浏览器上产生空白页面，渲染失败。 问题分解npm run dev在 vue-cli 中，这可能是我们用的最频繁的命令了，来看一下package.json 里: 123456&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot;&#125;, 主要看 dev 这个属性的值: 1webpack-dev-server --inline --progress --config build/webpack.dev.conf.js 来解读一下这一行命令 webpack-dev-server找到 node_modules 目录下的 webpack-dev-server，看它的readme 中可以得到以下信息： 123Either method will start a server instance and begin listening for connections from `localhost` on port `8080`.webpack-dev-server is configured by default to support live-reload of files as you edit your assets while the server is running. 意思是，输入命令 webpack-dev-server 就会在 8080 端口启动一个本地服务器，支持热重载，也就是你修改了静态文件内容无需刷新，页面直接更新的意思。 那后面那些参数什么意思呢？ 首先是 --inline，这是支持自动刷新的一种模式，还有另一种是--iframe。 在 iframe 模式下：页面是嵌套在一个 iframe 下的，在代码发生改动的时候，这个 iframe 会重新加载； 在 inline 模式下：一个小型的 webpack-dev-server 客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。 不过 Iframe mode 和 Inline mode 最后达到的效果都是一样的，都是监听文件的变化，然后再将编译后的文件推送到前端，完成页面的 reload 的。 对于 --process，是用于显示打包的进度，如果我们去掉它，或者换成 --quiet，就不会出现那些百分比的东西。 最后 --config，config 后面跟着一串路径，指定的是 webpack 配置文件的路径。 ok，介绍完了，进入今天的正题 调试执行 npm run dev 之后，pc 端正常访问，手机局域网访问一片空白，无法正常访问，但是 build 之后可以正常访问，于是开启了 qq 浏览器的调试，发现有这样一个报错: 1SyntaxError: Use of const in strict mode 发现是 es6 的语法不兼容，但一想到 dev 和 pro 模式的不同表现，那应该是就 babel 在 dev 与 pro 之间的配置不同。 解决方案进入 webpack.base.conf.js 里面，找到 12345&#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)]&#125;, 将其改成 12345&#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;), resolve(&#x27;node_modules/webpack-dev-server/client&#x27;)]&#125;, 再将.babelrc添加一行: 1[&quot;es2015&quot;, &#123;&quot;modules&quot;: false&#125;], 重新启动npm run dev 再用手机访问，OK，成功了。","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://wingsico.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://wingsico.github.io/tags/webpack/"}]},{"title":"数据结构之图的应用","slug":"graph","date":"2018-01-02T06:16:54.000Z","updated":"2020-12-07T05:44:32.063Z","comments":true,"path":"2018/01/02/graph/","link":"","permalink":"https://wingsico.github.io/2018/01/02/graph/","excerpt":"之前在算法图解里看见了关于最短路径的求解，对于无权值的图，我们可以采用广度优先搜索算法，找出的是经过最少的边的路径，而对于含有边权的图，若要找到其最短路径（更好的称为最快路径），可采用另一种算法，即狄克斯特拉算法","text":"之前在算法图解里看见了关于最短路径的求解，对于无权值的图，我们可以采用广度优先搜索算法，找出的是经过最少的边的路径，而对于含有边权的图，若要找到其最短路径（更好的称为最快路径），可采用另一种算法，即狄克斯特拉算法 狄克斯特拉算法据我所知，狄克斯特拉算法只适用于有向无环图，这是为什么呢？ 假设有一个环，A -&gt; B -&gt; C -&gt; B -&gt; A，这意味着你可以从一结点出发，走一圈之后又回到了这个结点，假设在这个带环的图内，你要找出从起点到终点的最短路径，绕环前行是否合理呢？ 你可以选择避开环，也可以选择包含环的路径。这两条路径都可以到达终点，但环增加了权重，所以绕环的路径不可能是最短的路径。对于无向图，意味着两个节点互相指着对方，其实就是环，在无向图中，每一条边的都是环。所以狄克斯特拉算法只适用于有向无环图 狄克斯特拉算法能否找出含有负权值的边呢？ 答案是不能:(，因为在狄克斯特拉算法中，对于处理过的结点，就意味着没有前往该结点的更快的路径，但若含有负权值的边，你知道如果包含负权值的话，会更快到达该结点，但是该算法不会再用负权值去处理这个结点，因此该算法只适用于不含有负权值的图。 狄克斯特拉算法的核心思想为: 找出“最便宜的结点”，即可在最短时间内到达的结点 更新该结点的邻居，检查是或否有前往他们的更短路径，如果有，就更新其开销 重复这个过程，知道对图中的每个结点都这样做了 计算最终路径 疑惑由上面的一些知识可得，狄克斯特拉算法适用于有向无环图和不存在负权值的图。但是实验给了一张权值为正的无环图，这就有一些懵逼了，那么我还如何使用狄克斯特拉算法去解决一个无向图呢？ 、 为了解决这个问题，先进入实验，从实验中得到解决的方法。 实验问题描述设计一个大学校内交通咨询系统，能让旅客咨询从任一楼到其余所有楼之间的最短路径。 输入与输出输入：输入图的顶点数，以及边数。 输出：一幢楼到其他楼之间的最短路径。 需求分析1.建立交通网络图的存储结构。 2.解决单源最短路径问题。 实验分析与设计由实验图我们可以看出，这是一个不含有负权值边的无向图，由我们有向图狄克斯特拉算法可以延伸出一种处理无向图的最短路径的算法。 首先，我们需要先建立一个图结构，这个图应该包含以下一些东西： 图的顶点数 图的边数 还有什么呢？因为我们处理的是单源最短路径，所以需要存储源点到各个点的距离；除此之外，我们需要保存一条边的顶点之间的联系，我们使用一个邻接矩阵来存储这之间的联系；还有就是，由算法的原理可以知道，到每一个点的最短路径会在每一轮就确定下来，因此我们需要存储已经确定了最短路径的结点。 综上，我们可以知道，这个图结构应该包含完整的以下内容： 图的顶点数 图的边数 源点到各个顶点的初始路程 顶点与顶点之间的联系，即边权值 已经确定最短路径的结点 因此，我们使用一个结构体作为图的结构，代码如下: 123456789const int max_node_count = 20; // 最大顶点数typedef int Type;typedef struct &#123; Type AdjacencyList[max_node_count][max_node_count]; // 邻接矩阵存储顶点与顶点之间的联系 Type distances[max_node_count]; // distances数组，1号顶点到其余各个顶点的初始路程 Type shortPaths[max_node_count]; // shortPaths数组，存放已经确定最短路径的结点 Type vertex = 0; // 图的顶点数 Type edge = 0; // 图的边数&#125;Graph; 采用邻接矩阵来存储顶点之间的联系。 根据实验要求，我们需要先初始化这个图，也就是初始化部分邻接矩阵以及他的顶点数和边数。容易知道的是，每个顶点和他自身的距离为 0，因此，在初始化的时候就可以直接设为 0，另外，对于其他的点，我们先初始化为无穷大的值。 12345678910111213141516171819202122232425262728293031status initGraph (Graph &amp;g) &#123; std::cout &lt;&lt; &quot;输入图的顶点数和边数: &quot;; std::cin &gt;&gt; g.vertex &gt;&gt; g.edge; for(int i = 1; i &lt;= g.vertex; ++i) &#123; for(int j = 1; j &lt;= g.edge; ++j) &#123; if (i == j) &#123; g.AdjacencyList[i][j] = 0; // 顶点与自身距离为0 &#125; else &#123; g.AdjacencyList[i][j] = inf; // 某个顶点与其余顶点距离默认初始化为无穷大 &#125; &#125; &#125; return ok;&#125;之后我们便要读入对应的顶点和边权了，对于有向图，其是有固定的指向的，因此，在邻接矩阵中，若无环，且`AdjacencyList[3][4] ≠ ∞`，则`AdjacencyList[4][3] = ∞`，是一个对立的关系，那么对于无向图呢？ 其实只要让`AdjacencyList[3][4] = AdjacencyList[4][3]`即可，这样，即可使无向图也可以使用`狄克斯特拉算法`来寻找最快路径。```c++status getGraph (Graph &amp;g) &#123; int v1; // 边的左顶点 int v2; // 边的右顶点 int e; // 边的权值 for (int i = 1; i &lt;= g.edge; ++i) &#123; printf(&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;, i); std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e; g.AdjacencyList[v1][v2] = e; // 填入邻接矩阵 g.AdjacencyList[v2][v1] = e; // 无向图处理 &#125; return ok;&#125; 我们还要初始化两个表，一个是初始路径的表，还有一个就是已经确定最短路径的表。 初始路径的表，即源点到各个点的初始路径，有些点不与源点直接相连，即可设置为无穷大；对于与源点直接相连的点，可以查看邻接矩阵中关于源点的顶点之间的联系，然后填入表内。 已经确定最短路径的表，在最开始只有源点是确定的，其他点均尚未确定，因此，初始化也非常简单。 1234567891011121314151617status initDistances (Graph &amp;g) &#123; // 初始化dis数组，表示1号顶点到其余各个顶点的初始路程 for (int i = 1; i &lt;= g.vertex; ++i) &#123; g.distances[i] = g.AdjacencyList[1][i]; &#125; return ok;&#125;status initShortPaths (Graph &amp;g) &#123; // 初始化shortPaths数组 // 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径 for (int i = 1; i &lt;= g.vertex; ++i) &#123; g.shortPaths[i] = 0; &#125; g.shortPaths[1] = 1; return ok;&#125; 接下来我们要做的就是依据邻接矩阵来不断更新这两个表的数据来计算所有点距离源点的最短路径。 1234567891011121314151617181920212223status makeClosestDistances (Graph &amp;g) &#123; int min; // 存储最小值 int vmin; // 存储最小值对应的顶点 for (int i = 1; i &lt;= g.vertex - 1; ++i) &#123; // 最后一个点无需比较 // 找到距离号顶点最近的顶点 min = inf; for (int j = 1; j &lt;= g.vertex; ++j) &#123; // 遍历各个顶点，找出距离最近的未确定的结点 if (g.shortPaths[j] == 0 &amp;&amp; g.distances[j] &lt; min) &#123; min = g.distances[j]; vmin = j; &#125; &#125; g.shortPaths[vmin] = 1; // 确定该顶点找到最小路径 for (int k = 1; k &lt;= g.vertex; ++k) &#123; if (g.AdjacencyList[vmin][k] &lt; inf) &#123; // 若两个顶点直接相邻 if (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; // 若该距离更小，更新最短路径的数据 g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k]; &#125; &#125; &#125; &#125; return ok;&#125; 解释如注释。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;const int max_node_count = 20; // 最大顶点数const int inf = 999999; // 存储一个可以当做相对无穷的值typedef int Type;typedef struct &#123; Type AdjacencyList[max_node_count][max_node_count]; // 邻接矩阵存储顶点与顶点之间的联系 Type distances[max_node_count]; // distances数组，1号顶点到其余各个顶点的初始路程 Type shortPaths[max_node_count]; // shortPaths数组，存放已经确定最短路径的结点 Type vertex = 0; // 图的顶点数 Type edge = 0; // 图的边数&#125;Graph;typedef int status;const status ok = 1;const status err = 0;status initGraph (Graph &amp;g); // 初始化邻接表status getGraph (Graph &amp;g); // 读入边status initDistances (Graph &amp;g); // 初始化distances数组status initShortPaths (Graph &amp;g); // 初始化shortPaths数组status makeClosestDistances (Graph &amp;g); // 计算得到所有节点确定最短路径长度的数组status displayClosestDistances (Graph g); // 输出最终得到到各个结点的最小路径数组// DIJKSTRA 算法int main() &#123; Graph traffic; // 定义一个Graph变量 initGraph(traffic); // 初始化图的邻接顺序表 getGraph(traffic); // 读入边的相关信息 initDistances(traffic); // 初始化各个顶点距离源点的路径顺序表 initShortPaths(traffic); // 初始化各个已经确定最短顶点的顶点顺序表 makeClosestDistances(traffic); displayClosestDistances(traffic); return 0;&#125;// ***************** 函数库 *********************status initGraph (Graph &amp;g) &#123; std::cout &lt;&lt; &quot;输入图的顶点数和边数: &quot;; std::cin &gt;&gt; g.vertex &gt;&gt; g.edge; for(int i = 1; i &lt;= g.vertex; ++i) &#123; for(int j = 1; j &lt;= g.edge; ++j) &#123; if (i == j) &#123; g.AdjacencyList[i][j] = 0; // 顶点与自身的距离为0 &#125; else &#123; g.AdjacencyList[i][j] = inf; // 某个顶点与其余顶点距离默认初始化为无穷大 &#125; &#125; &#125; return ok;&#125;status getGraph (Graph &amp;g) &#123; int v1; // 边的左顶点 int v2; // 边的右顶点 int e; // 边的权值 for (int i = 1; i &lt;= g.edge; ++i) &#123; printf(&quot;输入第%d条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): &quot;, i); std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e; g.AdjacencyList[v1][v2] = e; // 填入邻接矩阵 g.AdjacencyList[v2][v1] = e; // 无向图处理 &#125; return ok;&#125;status initDistances (Graph &amp;g) &#123; // 初始化dis数组，表示1号顶点到其余各个顶点的初始路程 for (int i = 1; i &lt;= g.vertex; ++i) &#123; g.distances[i] = g.AdjacencyList[1][i]; &#125; return ok;&#125;status initShortPaths (Graph &amp;g) &#123; // 初始化shortPaths数组 // 0 表示该顶点未确定为最短路径，1 表示该顶点确定为最短路径 for (int i = 1; i &lt;= g.vertex; ++i) &#123; g.shortPaths[i] = 0; &#125; g.shortPaths[1] = 1; return ok;&#125;status displayClosestDistances (Graph g) &#123; // 输出各个顶点的距离1号顶点的最短路径 for (int i = 1; i &lt;= g.vertex; ++i) &#123; printf(&quot;%d号顶点距离源点(1号)的最短路径的长度为 %d\\n&quot;, i, g.distances[i]); &#125; return ok;&#125;status makeClosestDistances (Graph &amp;g) &#123; int min; // 存储最小值 int vmin; // 存储最小值对应的顶点 for (int i = 1; i &lt;= g.vertex - 1; ++i) &#123; // 最后一个点无需比较 // 找到距离号顶点最近的顶点 min = inf; for (int j = 1; j &lt;= g.vertex; ++j) &#123; // 遍历各个顶点，找出距离最近的未确定的结点 if (g.shortPaths[j] == 0 &amp;&amp; g.distances[j] &lt; min) &#123; min = g.distances[j]; vmin = j; &#125; &#125; g.shortPaths[vmin] = 1; // 确定该顶点找到最小路径 for (int k = 1; k &lt;= g.vertex; ++k) &#123; if (g.AdjacencyList[vmin][k] &lt; inf) &#123; // 若两个顶点直接相邻 if (g.distances[k] &gt; g.distances[vmin] + g.AdjacencyList[vmin][k]) &#123; // 若该距离更小，更新最短路径的数据 g.distances[k] = g.distances[vmin] + g.AdjacencyList[vmin][k]; &#125; &#125; &#125; &#125; return ok;&#125; 调试结果12345678910111213141516/Users/wingsico/CLionProjects/dijkstra/cmake-build-debug/dijkstra输入图的顶点数和边数: 5 7输入第1条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 2 180输入第2条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 3 100输入第3条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 1 4 150输入第4条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 4 50输入第5条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 2 5 130输入第6条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 3 4 80输入第7条边的两个端点以及权值(如1 2 8表示顶点1与顶点2的距离为8): 4 5 1201号顶点距离源点(1号)的最短路径的长度为 02号顶点距离源点(1号)的最短路径的长度为 1803号顶点距离源点(1号)的最短路径的长度为 1004号顶点距离源点(1号)的最短路径的长度为 1505号顶点距离源点(1号)的最短路径的长度为 270Process finished with exit code 0 总结这个代码上还有可以改进的地方，这个算法的时间复杂度为O(N^2)，每次找到离源点最近的定点的时间复杂度是 O(N)(一个 for 循环遍历所有结点)，这里我们可以使用堆来优化，可以使这一部分的时间复杂度降低到O(logN)。 另外，对于稀疏图来说，我们可以使用邻接表法代替邻接矩阵，使得整个时间复杂度优化到O((M+N)logN)，但没有仔细研究，所以也不了了之。 对于选做题，有一定难度，不过了解费洛伊德算法即可解决，即多源最短路径的算法，其核心代码只有五行，利用了动态规划的思想，实现起来很简单，但由于时间有限，加之期末临近，只好作罢。 Over。","categories":[{"name":"深入理解","slug":"深入理解","permalink":"https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++","slug":"c","permalink":"https://wingsico.github.io/tags/c/"}]},{"title":"你所不知道的HTML —— 规范篇","slug":"unknowhtml-standard","date":"2017-12-24T15:45:53.000Z","updated":"2020-12-07T05:44:32.071Z","comments":true,"path":"2017/12/24/unknowhtml-standard/","link":"","permalink":"https://wingsico.github.io/2017/12/24/unknowhtml-standard/","excerpt":"","text":"资源引入 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。这是因为使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境 1&lt;script src=&quot;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js&quot;&gt;&lt;/script&gt; 结构优化 尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度 结构顺序和视觉顺序基本保持一致，按照从上至下、从左到右的视觉顺序书写 HTML 结构。有时为了便于搜索引擎抓取，也会将重要内容在 HTML 结构顺序上提前 结构、表现、行为三者分离，避免内联 每一个块级元素都另起一行，每一行都使用 Tab 缩进对齐（head 和 body 的子元素不需要缩进）。删除冗余的行尾空格 对于内容较为简单的表格，建议将 tr 写成单行 可以在大的模块之间用空行隔开，使模块更清晰 语义化浏览器会根据标签的语义给定一个默认的样式。判断网页标签语义化是否良好的一个简单方法：去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性 尽可能少地使用无语义标签 span 和 div 在语义不明显，既可以使用 p 也可以使用 div 的地方，尽量用 p 在既可以使用 div 也可以使用 section 的地方，尽量用 section 不要使用纯样式标签，如 b、u 等，而改用 CSS 设置 命名 同一页面，应避免使用相同的 name 与 id。因为 IE7-浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心 标签 标签名小写 无需自闭合的标签，不要自闭合 对于html5中规范中允许省略的闭合标签，不要省略 属性 属性和值全部小写 属性值必须用双引号包围 布尔类型的属性，建议不添加属性值 自定义属性建议以 xxx- 为前缀，推荐使用 data- 可以省略 style 标签和 script 标签的 type 属性 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性 1234567idclassnamedata-xxxsrc, for, type, hreftitle, altaria-xxx, role 特殊元素图片 禁止 img 的 src 取值为空，否则会导致部分浏览器重新加载一次当前页面 为图片添加 alt 属性，提高图片加载失败时的用户体验 避免为 img 添加不必要的 title 属性，多余的 title 影响看图体验，并且增加了页面尺寸 为图片添加 width 和 height 属性，以避免页面抖动 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载, 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 css 背景图实现 表单 有文本标题的控件使用 label 标签将其与其标题相关联。最好将控件置于 label 内，以减少不必要的 id 123&lt;label &gt;&lt;input type=&quot;checkbox&quot; name=&quot;confirm&quot; value=&quot;on&quot; /&gt; 我已确认上述条款&lt;/label&gt; 使用 button 元素时必须指明 type 属性值。因为 button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交 1&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;取消&lt;/button&gt; 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性，能获得友好的输入体验 1&lt;input type=&quot;date&quot; /&gt;","categories":[{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"你所不知道的HTML","slug":"你所不知道的HTML","permalink":"https://wingsico.github.io/tags/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84HTML/"}]},{"title":"vue build 过程中遇到的坑","slug":"vue-build-kengs","date":"2017-12-23T09:23:09.000Z","updated":"2020-12-07T05:44:32.071Z","comments":true,"path":"2017/12/23/vue-build-kengs/","link":"","permalink":"https://wingsico.github.io/2017/12/23/vue-build-kengs/","excerpt":"","text":"一号坑[npm install] - 已解决问题描述github 项目迁移至 coding，本地切换到另一个文件夹，重新 npm install 失败。 调试npm install: 时间长，且结束后报错 yarn: 一直处于安装状态，但目录下生成了 node_modules，尝试 npm run build 后报错。 解决方案使用 cnpm 解决（ cnpm 真好用 _(:з ゝ ∠)_） 二号坑[static 文件 404] - 已解决问题描述build 成功之后，得放在服务器上跑，build 之后也有提示: Tip: built files are meant to be served over an HTTP server.Opening index.html over file:// won’t work. 于是，我便将文件夹上传服务器 1scp -r ~/my-github/ncuniversity/gpa/gpa-static/dist xxx@xxx.xxx:/path/ 上传好后访问网站，控制台一堆 404 错误，而且加载的比较慢。 调试看了一下资源请求的路径，竟然全是 /static，这就尴尬了，想了想本地跑没问题，应该是 webpack 打包的问题，于是重新看了一下webpack的配置文件 config/index.js 中，在 build &#123;&#125; 内，有一行 12345&#123; ... assetsPublicPath: &#x27;/&#x27;, ...&#125; 应该就是这个了，使我的资源一直处于绝对路径下。 解决方案将上面代码改成： 12345&#123; ... assetsPublicPath: &#x27;./&#x27;, ...&#125; 这样应该就能使资源处于相对路径下了~ 重新 build 后发现问题解决。 三号坑[请求 404] - 已解决问题描述 发送请求，显示请求 404 请求跨域 调试本地为了解决跨域，使用了 proxy-table 去代理，然后请求的路径那里写的绝对路径: 1234567async getUserInfo () &#123; this.$http(&#123; url: /api/common/&#x27; + this.user.username.value, mothod: &#x27;GET&#x27;, timeout: 4000 &#125;).then(_ =&gt; ...)&#125; 但是打包后 proxy-table 就会失效。 解决方案在 nginx 服务器上配置反向代理，将请求本机服务器的请求转发到目标服务器上。具体可以参见 nginx 反向代理。 如果遇到跨域问题可以让后端配置 CORS","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://wingsico.github.io/tags/vue/"}]},{"title":"项目总结(一) —— 移动端适配","slug":"mobile-adaptation","date":"2017-12-22T17:07:04.000Z","updated":"2020-12-07T05:44:32.064Z","comments":true,"path":"2017/12/23/mobile-adaptation/","link":"","permalink":"https://wingsico.github.io/2017/12/23/mobile-adaptation/","excerpt":"历经好多时间= =，终于完成了一个小项目，再次更新了一些我的移动端知识，之前总是对概念有些不清晰，先梳理一下。","text":"历经好多时间= =，终于完成了一个小项目，再次更新了一些我的移动端知识，之前总是对概念有些不清晰，先梳理一下。 像素概念 CSS 像素(CSS Pixel) CSS 代码中的逻辑像素，是一个抽象的东西，实际并不存在。 设备独立像素(Device Independent Pixel) 与设备无关的逻辑像素，可以通过虚拟程序来设置，包含了 CSS 像素 设备像素(Device Pixel) 物理像素，设备能控制显示的最小单位，类似 1920 * 1080 像素分辨率这种的。 关系 设备像素与设备独立像素 对于 PC 页面：在未缩放的情况下，1设备像素 === 1设备独立像素，若缩放为 200%时，可以说 2设备像素 === 1设备独立像素。 对于移动端页面： 根据设备不同有一些差异，其引起差异的原因主要在于一个被称之为ppi(pixel per inc)的东西。 PPI 从名字上就知道是 每英寸设备有多少像素，这里的像素指的是设备像素，即物理像素，其数值越高，每英寸设备里的像素就越高，画面也就越清晰。 计算方式为: 像苹果的 Retina 屏的 ppi 就比较高，所以清晰度很高。 还有一个很重要的概念就是dpr(device pixel ratio) DPR 设备像素比，这个设备像素比就是物理像素与独立像素，独立像素之前说到，包含着CSS像素，所以 dpr 即提供了一个我们代码中的像素与设备实际像素之间的一个转换关系。 计算公式： 1dpr = 设备像素 / 设备独立像素 像苹果手机的 dpr 一般为 2，即意味着 1 长度的设备像素里有 2 长度的设备独立像素，换做面积来算的话就是 1 设备像素包含着 4 设备独立像素，即成平方关系，所以清晰明了，dpr 越高，屏幕清晰度也越高，与 ppi 有些相似，用一张图看看： 大概需要了解的就这些，我在实际运用中用到的也就如下几点： dpr px device-width (屏幕宽度) 运用对于 dpr，一般用于两个地方，一个是字体大小，一个是背景图片大小 对于字体，也是用 px 堆起来的，因此 dpr 也会影响到字体的显示，当 dpr 较大时，为了同比例显示字体大小，就会去检测其 dpr 的值，根据 dpr 的不同来设置不同比例的字体大小，可以用如下一段sass的混合宏来适配字体显示: 123456789@mixin font-dpr($font-size) &#123; font-size: $font-size / 2; [data-dpr=&quot;2&quot;] &amp; &#123; font-size: $font-size; &#125; [data-dpr=&quot;3&quot;] &amp; &#123; font-size: $font-size * 3 / 2; &#125;&#125; 这里有个data-dpr，即根据 dpr 不同来应用不同的字体样式，此外，这里将传入的字体大小除以 2，这是因为一般设计给的视觉稿都是 iphone6 的二倍稿，因此，为了显示正常字体大小，将其标注的字体大小除以二，再根据 dpr 来适配字体大小。 移动端运用到图片几乎是必然的，一般设计师会给出两种图片，一种为@2x 图，一种为@3x 图，不过这个主要是用来出来高清屏下图片较为高清的显示，对于普通的安卓机，dpr 一直都是 1，意义不大，用普通的@2x 图即可达到高清的显示，但是对于 ios 系统，存在 dpr 为 2、dpr 为 3 的情况，为了图片的一个等比例缩放，我们根据 dpr 的不同来使用不同倍数的图片以达到与标准屏幕一致的感受。同样的，我们也可以使用sass的混合宏来适配背景图片： 123456@mixin bg-image($url) &#123; background-image: url($url+&quot;@2x.png&quot;); @media (-webkit-min-device-pixel-ratio: 3), (min-device-pixel-ratio: 3) &#123; background-image: url($url+&quot;@3x.png&quot;); &#125;&#125; 除这两点之外，我暂时没有用到 dpr 其他的使用方法。 布局适配布局和适配其实我一直难以分辨这两个概念，我就把它罗列在一起吧。 为了达到想要的效果，我的历程如下： meta 设置 viewport -&gt; width=device-width… rem 布局 flex-box flexible.js 视口单位 vw,vh calc 计算 calc + 视口单位 calc + 视口单位 + 媒体查询 百分比布局 删除 6、7、8, 9 重归 flexible 加上媒体查询，适配特殊机型，如 Nexus 5X 妈耶心好累，布局适配改改改改好头疼，不过还好都解决了。 meta1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;/&gt; 这行代码作用是设置理想视口，什么是视口？什么又是理想视口，要说明这个，对于viewport就要讲很多了。 这里有一个链接，我觉得写的很好，很多内容都非常清晰的表达了出来: 移动端之 viewport rem 布局rem、px、em均是常用的单位，他们都是相对长度单位，在不同的地方我们需要配合起来使用。 pxpx(Pixel) 是相对于屏幕分辨率而言的一个单位，一般我们对于 pc 均会使用px作为单位，同时，一些固定大小、长度的我们同样使用 px 作为单位，这个也是我们上面说到的 CSS 像素，包含在设备独立像素内。 emem是一个相对与其父元素的字体大小的一个单位，举个例子 1234567891011&lt;style lang=&quot;scss&quot;&gt; .parent &#123; font-size: 18px; .child &#123; font-size: 2em; // 18 * 2 = 36px .grandson &#123; font-size: 0.5em; // 36 * 0.5 = 18px &#125; &#125; &#125;&lt;/style&gt; 这个单位对于一整块整体变换有很好的效果，比如我们有一个按钮，当我们想要整体放大一个按钮的时候，不需要去改变每一个字体的大小，设置 em 之后可以只改变其父级元素的字体大小来达到整体缩放的效果。 rem为了移动端而生的单位，同样是一个相对单位，与 em 不同的是，rem 是相对于 html 根元素的字体大小，举个例子： 1234567891011121314&lt;style lang=&quot;scss&quot;&gt; html &#123; font-size: 10px; .parent &#123; font-size: 2rem; // 10 * 2 = 20px .child &#123; font-size： 4rem; // 10 * 4 = 40px .grandson &#123; font-size： 1.6rem; // 10 * 1.6 = 16px &#125; &#125; &#125; &#125;&lt;/style&gt; 有了这样一个单位，对于我们移动端上的适配来说，绝对是一大助力，我们可以使用 rem 来适配不同分辨率的屏幕。 现在假设我们有一张 750 的设计稿，我们把设计稿分成一百份，把每十份当做一个 1rem，即设置： 123html &#123; font-size: 75px; // 750 / 100 * 10 = 75px&#125; 那么我们在需要一个 150*150 的 div 时，我们可以使用 1234.box &#123; width: 2rem; height: 2rem;&#125; 当我们的屏幕不同的时候，我们只需动态的更改根元素的字体大小即可。那么如何动态更改根元素的字体大小呢？在 CSS3 有一个新增的媒体查询，可以帮我们检测设备相关信息并根据这些信息使用不同的样式。 @media/媒体查询这里有相关的资料：MDN 媒体查询 上面只是介绍了一些概念的东西，那么我们如何去使用媒体查询在我们的移动端适配上呢? 待续","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"移动端","slug":"移动端","permalink":"https://wingsico.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"项目总结","slug":"项目总结","permalink":"https://wingsico.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}]},{"title":"满二叉树中树的深度、结点、分支结点、叶子结点等之间的数量关系","slug":"btree-number-relation","date":"2017-12-16T08:44:37.000Z","updated":"2020-12-07T05:44:32.060Z","comments":true,"path":"2017/12/16/btree-number-relation/","link":"","permalink":"https://wingsico.github.io/2017/12/16/btree-number-relation/","excerpt":"对二叉树的简单总结","text":"对二叉树的简单总结 普通二叉树对于普通的二叉树，假设n为总结点数，n0为度为 0 的结点（叶子结点）数，n1为度为 1 的结点数，n2为度为 2 的结点数。m为树的总度数。 有如下一般的数量关系 12345678// 二叉树只含有度数为 0，1，2 的结点，因此总结点数等于他们的和n = n0 + n1 + n2// 无需解释吧，m 为总度数0 _ n0 + 1 _ n1 + 2 \\* n2 = m// 除了根结点之外，每一个结点的上方都对应着一个度，因此总度数比总结点数少 1m = n - 1// 综合上面的三个式子n0 = n2 + 1 满二叉树设深度为h，设n为总结点数，k为分支结点数，m为叶子结点数。 深度：树的最大层数； 叶子结点：度为 0 的结点； 分支结点：非叶子结点，即度不为零的结点。 则有如下的数量关系： 1234567891011m = 2 ^ (h - 1);n = 1 + 2 + 4 + ... + 2 ^ (h - 1) = 2 ^ h - 1;k = n - m = 2 ^ (h - 1) - 1;k = m - 1;n = 2m - 1;n = 2k + 1;","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ssh: REMOTE HOST IDENTIFICATION HAS CHANGED 解决方案","slug":"ssh-host","date":"2017-12-16T06:14:28.000Z","updated":"2020-12-07T05:44:32.067Z","comments":true,"path":"2017/12/16/ssh-host/","link":"","permalink":"https://wingsico.github.io/2017/12/16/ssh-host/","excerpt":"之前一直使用SSH Shell来登录的服务器，用着觉得主题有点丑我就又用iTerm来用 ssh 登录服务器。","text":"之前一直使用SSH Shell来登录的服务器，用着觉得主题有点丑我就又用iTerm来用 ssh 登录服务器。 照常，我使用 1ssh root@wingsico.org 登录服务器，突然，出现了一个错误。 1234567891011121314➜ ~ ssh root@wingsico.org @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is SHA256:KDg0k+7eheoSVX0/HTzlWK66OI5sLrzgWc6cgXZDE6s. Please contact your system administrator. Add correct host key in /Users/wingsico/.ssh/known_hosts to get rid of this message. Offending RSA key in /Users/wingsico/.ssh/known_hosts:7 RSA host key for wingsico.org has changed and you have requested strict checking. Host key verification failed. 错误分析注意他的错误提示 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 意思就是：远程主机标识已更改 可能是因为我重装了一下服务器，导致远程主机标识的变化，这里就要说到服务器与客户端的连接的一些要点了。 在远程服务器上，在路径/ect/ssh下会有一些.pub后缀以及名字相同但无后缀的文件，这里存放的是服务器的指纹，目录类似： 12345[root@VM_48_13_centos ssh]# lsmoduli ssh_host_dsa_key.pub ssh_host_ed25519_key.pubssh_config ssh_host_ecdsa_key ssh_host_rsa_keysshd_config ssh_host_ecdsa_key.pub ssh_host_rsa_key.pubssh_host_dsa_key ssh_host_ed25519_key 其中，文件名为 ssh_host_xxx_key 和 ssh_host_xxx_key.pub就是我们服务器的指纹，分别为私钥和公钥，私钥是唯一一份的，不能泄露给他人，而公钥可以在各个地方使用，这个可以参考 git 仓库的建立。 当我们使用客户端第一次登录服务器时，会有如下一段提示： The authenticity of host ‘wingsico.org (xxx.xxx.xxx.xxx)’ can’t be established.ECDSA key fingerprint is SHA256:+gFx5UGMm/739ut/jKZqJDm+TYSUxfZiC7IKG2PAVpA.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘wingsico.org,xxx.xxx.xxx.xxx’ (ECDSA) to the list of known hosts. 这时候远程服务器的指纹如下 1ECDSA key fingerprint is SHA256:+gFx5UGMm/739ut/jKZqJDm+TYSUxfZiC7IKG2PAVpA. 与服务器远程验证，防止中间人攻击，这时候输入yes将会将指纹添加进本地的 ~/.ssh/know_hosts 中去，远程主机和本机就拥有了一对指纹作为登录的验证，当本地的指纹与远程主机的指纹不一致时，将会弹出上面的警告信息拒绝登录。 解决方案知道了原因，就很好处理了，因为我们重装了服务器，导致远程主机中sshd初始化，改变了远程主机的指纹，本地的指纹与远程主机的指纹不一致，导致登录被拒绝。所以我们只需要修改本地的指纹，也就是 ~/.ssh/know_hosts 的内容即可，具体操作如下: 使用nano打开know_hosts： 1nano ~/.ssh/know_hosts 将对应远程主机的 ip 或者域名的指纹删除，然后重新登录。 重新将指纹添加进本地的~/.ssh/know_hosts内，即可登录成功。","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"},{"name":"服务器","slug":"服务器","permalink":"https://wingsico.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"host","slug":"host","permalink":"https://wingsico.github.io/tags/host/"}]},{"title":"串的模式匹配应用之文本编辑","slug":"pattern-match","date":"2017-12-16T00:57:58.000Z","updated":"2020-12-07T05:44:32.066Z","comments":true,"path":"2017/12/16/pattern-match/","link":"","permalink":"https://wingsico.github.io/2017/12/16/pattern-match/","excerpt":"对 C 串结构的学习总结","text":"对 C 串结构的学习总结 引言老实说，串这一章学的并不好，感觉只了解相关概念，在我的印象中, 串就是代表字符串，而在 C/C++语言中，字符串又可用 12char chs[100]; // 字符数组string str; // 字符串 两种（简单）方法表示，结构上均与线性表无异，区别只在于串的数据对象被约束为字符集。但在操作上，串与线性表是存在较大差别的。 在线性表的基本操作中，大多以“单个元素”作为操作对象，例如查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等。 而在串的基本操作中，通常以“串的整体”作为操作对象，例如在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。 但如何实现一个串，如何实现一个符合情景的串是一个令我头疼的问题。如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。（这个非数值处理有点不太明白，串不都是字符类型吗？不是均为非数值吗？） 串的表示方法 定长顺序存储表示 类似线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列，给定一个预定义的大小，为每个定义的串变量分配一个固定长度的存储区，可以用如下代码描述： 12const int MAXSIZE = 255;typedef char sstring[MAXSIZE + 1]; 串的实际长度可以在预定义长度内随意，超过定义的长度就会被截断。在上面的代码中，我们设置了一个常量MAXSIZE，同时自定义了一个数据类型sstring[]，注意，我们定义的字符串预定义长度为MAXSIZE + 1，这是为了方便串操作，我们将串的长度存储在 0 号数据单元，当然，这也不是必须的，在 c 语言中，我们可以使用strlen()来获取字符数组char chs[]的真实长度，用str.length()来获取字符串的长度。 这个为最简单也最常用的一种串的结构，也是我们这次实验需要用到的结构。接下来简要介绍一下另外两种串的表示方法（对于我来说不是很熟悉） 堆分配存储表示 对于第一种表示方法，会有一些问题： 操作的时间复杂度基于串的长度，效率较低 在一些操作中出现串值序列的长度超过上界时，约定使用截尾法处理，也就是说会导致一些串值丢失的情况 为了解决这些问题，我们采取不限制串的最大长度，而采用动态分配串值的存储空间 我们仍以一组地址连续的存储单元存放串值字符序列，但他们的存储空间是在程序执行过程中动态分配而得。在 C 语言中，存在一个称之为“堆”的自由存储区，并由 C 怨言的动态分配函数malloc()和free()来管理。利用malloc()来为每一个新产生的串分配一块实际船厂所需的存储空间。其代码表示如下： 1234typedef struct &#123; char *ch; // 若是非空串，则按串长分配存储区，否则ch为 NULL int length; // 串长&#125; 由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更加的灵活，因此在串处理的应用程序中也经常被选用。 串的块链存储表示 既然线性表中有链式的表示方法，那么在串中也可以采用链表方式存储串值。 12345678910const int CHUNKSIZE = 80; // 自定义大小typedef struct Chunk &#123; char ch[CHUNKSIZE]; struct Chunk *next;&#125;typedef struct &#123; Chunk *head, *tail; // 头尾指针 int curlen; // 串的当前长度&#125;LString 由代码很容易看出，一个块由数据域（字符数组）和指向下一个块的指针组成，同时LString表示的是字符串，其头指针指向其串首地址，还可以增设一个尾指针用来指向最后一个结点，并给出当前串的长度curlen，我们把这种串结构称作为块链结构，设置尾指针还有一个目的，是为了标语进行联结操作，但需要注意的是联结时需要处理第一个串尾的无效字符。 块链结构的串虽然对一些串操作比较方便，但不如前两种灵活，它占用内存大，且操作复杂，使用频率较少。 介绍完这三种表示方法，该进入我们今天的主题——文本编辑 串应用——文本编辑想到大一上学期，C 语言的课程比较紧凑，于是对于课本后面的知识没有好好巩固，对于文件处理方面的知识非常模糊，于是先整理了一下 C++文件与流的一些知识要点。 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 那么我们如何对文件进行输入和输出呢？这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 因此，要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 &lt;iostream&gt; 和 &lt;fstream&gt;。 打开文件在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 可以把以上两种或两种以上的模式结合使用。例如，如果想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么可以使用下面的语法： 12ofstream outfile;outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc ); 类似地，如果想要打开一个文件用于读写，可以使用下面的语法： 12fstream afile;afile.open(&quot;file.dat&quot;, ios::out | ios::in ); 关闭文件当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void close(); 写入文件在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 ####读取文件 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 有了以上的知识，对于读写文件的话还是信手拈来的。接下来，我们来看看实验要求 要求建立一个文本文件，每个单词子串不包含空格且不跨行，单词子串由字符序列构成，且区分大小写； 统计给定单词子串在文本文件中出现的总次数； 检索输出某个单词子串出现在文本中的行号、在该行中出现的次数以及位置。 一个个来分析，对于第一个，不包含空格也就是不存在类似hello world这样的字符串，字符串不跨行意味着每一行只有一个字符串，区分大小写的话意义不大，因为读取的和比较的时候是肯定区分大小写的。所以，我们使用如下函数来创建一个文本文件并读入字符串： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;fstream&gt; // 文件流const int maxsize = 10000; // 预定义字符串最大长度typedef char sstring[maxsize]; // 自定义字符数组类型void createTextFile ();...void createTextFile () &#123; sstring data; // 声明一个sstring类型的变量，存储输入的字符，包含换行符以及空格 int i = 0; // 用于标记当前读入的字符在字符数组的位置 char temp; // 存储中间变量，读入当前字符值 ofstream outfile; // 定义一个写入变量 outfile.open(&quot;test.txt&quot;); // 执行打开文件方法，打开一个当前路径下的&quot;test.txt&quot;文件 cout &lt;&lt; &quot;Write some strings to this file, if you want to stop, input a &#x27;#&#x27;: &quot; &lt;&lt; endl; while (true) &#123; if ((temp = getchar()) != &#x27;#&#x27;) &#123; // 以#号结束输入 data[i++] = temp; // 存入字符数组中 continue; // 继续下一次读入 &#125; break; // 结束输入 &#125; getchar(); // important 坑 outfile &lt;&lt; data &lt;&lt; endl; // 将数据写入文件中 outfile.close(); // 关闭对文件的访问&#125; 在代码中，我们使用 1typedef char sstring[maxsize]; 来定义一个字符数组类型而不是unsigned char，这么做的目的是为了后面的读取文件使格式保持一致，在后面会说到。 同时，在注释中标记important的代码 123 ...&#125;getchar(); 为什么要在结束输入之后调用这个方法呢？原因在于：*当我们输入#之后，字符数组剩余的部分的内容不确定，如果没有getchar()他将会得到一些乱码导致文件编码存在问题以及读取文件存在问题。我们使用getchar()来获取缓冲区的字符，避免将这些字符写入文件中去。(有待考证) 写入之后，我们就是需要读取文件的内容了。对于实验的要求，采用整行读取会较为方便，即使用getline()函数，读取是较为简单的，但是我们如何存储读取的数据呢？我们知道，读取的每一行的数据均为一个字符串，因此我们需要一个结构来存储每一个字符串。我第一反应就是字符串数组，这是在别的语言里非常常见的，但在 c 语言中，char chs[]只能存储字符串，无法使用它来存储多个字符串，所以，我想到了使用另一个类型 —— **string\\* 使用string，我们需要引入头文件 #include &lt;string&gt;，我们可以这样定义一个字符串数组： 12345string content[maxsize];...content[0] = &quot;my world&quot;;content[1] = &quot;your name&quot;;... 因此，我们可以每读取一行，将该行的字符串存入字符串数组中去，同时，由于读取的内容几乎在每个函数内都需要使用，为了避免每次调用函数都需要传参的麻烦，我们将读取的内容存在全局的字符串数组内，代码如下： 12345678910111213const int maxsize = 10000;int lineNumber = 0;string content[maxsize]; // 字符串数组，存储文件内容void getFileContent() &#123; sstring data; // 字符数组 int index = 0; // 存储当前字符串存入数组的下标 ifstream infile(&quot;test.txt&quot;); // 读取文件 while (infile.getline(data, maxsize)) &#123; // 逐行读取 content[index++] = data; &#125; lineNumber = index; // 内容的行数&#125; 因为我们的 content 用于全局，所以我们无需穿参，在函数内直接对content进行修改。再设置了一个全局的变量 lineNumber 用于存储读取文件的行数，对后面的匹配要求做铺垫。 读写存储操作均完成了，我们来看下一个要求，需要统计子串在字符串出现的总次数，思路很简单，我们对每一行进行匹配，若匹配成功则计数器加一，同时要注意一行可能会有多个匹配的子串，所以一行需要进行多次匹配。 那么在统计次数之前，我们需要完成一个更重要的工作，如何进行匹配？也就是判断子串是否在主串内以及如何定位到子串在主串的位置，这样的操作我们通常称为模式匹配。 通过模式匹配，我们将返回子串的第一个字符在主串中的下标。举个例子： 12sstring sMain = &quot;abbbcbc&quot;;sstring sChild = &quot;bc&quot;; 则子串在主串的位置为1，那么如何实现匹配呢？ 我们指定两个指针，一个指针 i 指向主串首个字符，一个指针 j 指向子串首个字符，逐个字符比较。当字符相等的时候， i 和 j 同时后移，匹配下一个字符；当字符不相等时， j 回到子串的首个字符的位置， i 则回溯到之前匹配到子串的第一个字符的位置的下一个位置。当 j 后移到子串之后的位置时，说明子串已经完全匹配，则此时 i 的指向为子串的最后一个字符在主串的位置的后一个位置。我们需要返回子串的位置，则需要找到匹配到的子串的首字符在主串中的位置，只需要将 i 后移子串长度个单位就可以了。具体实现如下： 1234567891011121314151617181920212223int getLength (sstring s) &#123; return strlen(s);&#125;int getIndex (string s, sstring t, int pos) &#123; // 返回子串t在主串s中第pos个字符之后的位置。 // 1 &lt;= pos &lt;= sLen // 匹配失败返回0 int i = pos - 1, j = 0, sLen = s.length(), tLen = getLength(t); while (i &lt; sLen &amp;&amp; j &lt; tLen) &#123; if (s[i] == t[j]) &#123; // 相等则主、子串指针均后移 i++; j++; &#125; else &#123; i = i - j + 1; // 主串指针回溯 j = 0; // 子串指针重新指向子串首字符 &#125; &#125; if (j == tLen) &#123; return i - tLen + 1; // 返回子串在主串的首位置 &#125; return 0; // 没匹配到则返回0&#125; 注意，这个函数 getIndex() 返回的是位置而不是下标，也就是是从 1 开始的，所以使用的时候要注意，它作为一个辅助函数，来实现我们两个主要功能的。 先来看计数功能，统计子串在主串中出现的总次数，在先前，我们已经将字符串存入了字符串数组，数组的每一个元素代表着每一行的字符串。因此我们需要便利这个字符串数组，对其每一个字符串进行匹配，得到最终的匹配个数： 12345678910111213141516171819void wordCount () &#123; sstring queryStr; // 搜索的子串 int i = 0; // 记录第几行 int count = 0; // 计数 cout &lt;&lt; &quot;输入你要计数的字符串: &quot;; cin &gt;&gt; queryStr; while (i &lt; lineNumber) &#123; int index = 1; while (true) &#123; index = getIndex(content[i], queryStr, index) + 1; // 多次匹配 if (index - 1 == 0) &#123; break; &#125; count++; // 匹配成功计数器加一 &#125; i++; // 换行，对下一行进行匹配 &#125; cout &lt;&lt; count &lt;&lt; endl;&#125; 相应的，对于子串的定位，功能上感觉和计数有部分重合，代码如下： 12345678910111213141516171819void strFind () &#123; sstring s; int index = 1; cout &lt;&lt; &quot;输入要定位的字符串: &quot;; cin &gt;&gt; s; for (int i = 0; i &lt; lineNumber; i++) &#123; int count = 0; // 计数器，记录每一行子串出现的次数 while (true) &#123; index = getIndex(content[i], s, index) + 1; if (index - 1 != 0) &#123; count++; printf(&quot;字符串 %s 在第 %d 行，第 %d 列.\\n&quot;, s, i + 1, index - 1); continue; &#125; break; &#125; printf(&quot;在第%d行共出现了%d次\\n&quot;, i + 1, count); &#125;&#125; 问题汇总 using namespace std; 的位置 我发现，这一句代码不能放在定义全局变量 string 的下面，如果在下面的话，将产生一个报错： 1Error: unknown type name &#x27;string&#x27;; did you mean &#x27;std::string&#x27;? 意味着 string 是包含在命名空间 std 中的。 何时使用 getFileContent() 这个函数的作用是读取指定文件内容，并存入全局的字符串数组中去。当第一次使用该程序时，指定文件还未创建，因此读取得到的是空字符串，当我们执行完写入操作后，需要再次执行该函数将内容存入全局字符串数组。因此，需要在刚进入主函数时调用以及完成写入操作之后调用一次。 总结和改进关于这次实验，我更改了实验内容所提供的 1typedef unsigned char sstring[maxsize]; 而使用了 1typedef char sstring[maxsize]; 只是为了函数的参数格式化，但其中区别未深入了解。同时，为了方便加入了string类型的数据，并不是很好的完全符合实验，而且对于引用参数和指针参数的理解还有些偏差，导致调试过程中出现许多的问题，需要自己仔细的再进行学习。 对于函数 strfind() 和 wordCount() ，这两个函数有一些公共的部分，应该是可以把它独立出来作为一个单独的函数来调用，将会简洁许多。 程序源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int maxsize = 10000;string content[maxsize]; // 字符串数组，存储文件内容int lineNumber = 0;typedef char sstring[maxsize];void createTextFile ();void wordCount ();void strFind ();void getFileContent();int getIndex (string s, sstring t, int pos);int choose ();int getLength (sstring s);int main () &#123; bool t = true; getFileContent(); while (t) &#123; switch (choose()) &#123; case 1: &#123; createTextFile(); getFileContent(); // 创建完之后需要重新调用一次content cout &lt;&lt; endl; break; &#125; case 2: &#123; wordCount(); cout &lt;&lt; endl; break; &#125; case 3: &#123; strFind(); cout &lt;&lt; endl; break; &#125; case 0: &#123; t = false; cout &lt;&lt; &quot;成功退出&quot; &lt;&lt; endl; break; &#125; default: &#123; cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;void createTextFile () &#123; sstring data; int i = 0; char temp; ofstream outfile; outfile.open(&quot;test.txt&quot;); cout &lt;&lt; &quot;Write some strings to this file, if you want to stop, input a &#x27;#&#x27;: &quot; &lt;&lt; endl; while (true) &#123; temp = getchar(); if (temp != &#x27;#&#x27;) &#123; data[i++] = temp; &#125; else &#123; break; &#125; &#125; getchar(); outfile &lt;&lt; data &lt;&lt; endl; outfile.close();&#125;int choose () &#123; // 菜单函数 int c; cout &lt;&lt; &quot;\\t文本编辑系统菜单🈳️&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;\\t1. 创建文本文件&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t2. 文件单词计数&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t3. 文件单词定位&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t0. exit&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入你的选择: &quot;; cin &gt;&gt; c; cin.ignore(); return c;&#125;void getFileContent() &#123; sstring data; // 字符数组 int index = 0; // 存储当前字符串存入数组的下标 ifstream infile(&quot;test.txt&quot;); // 读取文件 while (infile.getline(data, maxsize)) &#123; // 逐行读取 content[index++] = data; &#125; lineNumber = index; // 内容的行数&#125;int getIndex (string s, sstring t, int pos) &#123; // 返回子串t在主串s中第pos个字符之后的位置。 // 1 &lt;= pos &lt;= sLen // 匹配失败返回0 int i = pos - 1, j = 0, sLen = s.length(), tLen = getLength(t); while (i &lt; sLen &amp;&amp; j &lt; tLen) &#123; if (s[i] == t[j]) &#123; // 相等则主、子串指针均后移 i++; j++; &#125; else &#123; i = i - j + 1; // 主串指针回溯 j = 0; // 子串指针重新指向子串首字符 &#125; &#125; if (j == tLen) &#123; return i - tLen + 1; // 返回子串在主串的首位置 &#125; return 0; // 没匹配到则返回0&#125;int getLength (sstring s) &#123; return strlen(s);&#125;void wordCount () &#123; sstring queryStr; // 搜索的子串 int i = 0; // 记录第几行 int count = 0; // 计数 cout &lt;&lt; &quot;输入你要计数的字符串: &quot;; cin &gt;&gt; queryStr; while (i &lt; lineNumber) &#123; int index = 1; while (true) &#123; index = getIndex(content[i], queryStr, index) + 1; // 多次匹配 if (index - 1 == 0) &#123; break; &#125; count++; // 匹配成功计数器加一 &#125; i++; // 换行，对下一行进行匹配 &#125; cout &lt;&lt; count &lt;&lt; endl;&#125;void strFind () &#123; sstring s; int index = 1; cout &lt;&lt; &quot;输入要定位的字符串: &quot;; cin &gt;&gt; s; for (int i = 0; i &lt; lineNumber; i++) &#123; int count = 0; // 计数器，记录每一行子串出现的次数 while (true) &#123; index = getIndex(content[i], s, index) + 1; if (index - 1 != 0) &#123; count++; printf(&quot;字符串 %s 在第 %d 行，第 %d 列.\\n&quot;, s, i + 1, index - 1); continue; &#125; break; &#125; printf(&quot;在第%d行共出现了%d次\\n&quot;, i + 1, count); &#125;&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"https://wingsico.github.io/tags/C/"}]},{"title":"基于栈结构的中缀表达式求值","slug":"stack-calc","date":"2017-12-15T17:26:23.000Z","updated":"2020-12-07T05:44:32.070Z","comments":true,"path":"2017/12/16/stack-calc/","link":"","permalink":"https://wingsico.github.io/2017/12/16/stack-calc/","excerpt":"关于中缀表达式的 C++实现和原理介绍","text":"关于中缀表达式的 C++实现和原理介绍 引言栈这个东西，说简单也简单，就是一种数据结构，只是与顺序表，链表什么的不同，它遵循的是LIFO(后进先出)原则，阿这不是很简单么，只要时刻记住这一点就好了，只能从结构的一端进入和同一端出来就好了，这两个操作分别称为入栈和出栈。可以把它比喻成一筒可比克薯片，它是只有一边有盖子，称之为栈顶，它有一个金属的底部，防止薯片从底下漏出来了，称之为栈底。如果底部破了，薯片从底部漏了出来，称之为栈下溢；如果薯片装的过满了从顶部溢出来掉地上了，称之为栈上溢。关于这两个概念应该很好理解，但是这不是今天的重点，暂且不理它。 关于栈的概念应该大致清楚了，因为标题的缘故我再稍稍提一下队列。队列很好理解，从字面意思上我们就好理解了，就像排队一样，比如坐火车前去自动取票机取票，你得等你前面的人取完票你才能取票，当然队列里的数据元素都是遵纪守法的好公民，不存在插队现象（特意去搜了一下，栈应该是不存在自身插队的问题的），这就是FIFO(先进先出)原则，队列在遵循这个原则产生了多种变种比如双端队列、链队列、循环队列等。诶又扯远了，现在就正式开始吧。 思考本次应用实例是一个 基于栈结构的中缀表达式求值的一个程序，先不提实验本身，先搞清楚什么是中缀表达式，以及前缀和后缀表达式才是当务之急。 在表达式表示中，我们依照运算符相对运算数的位置不同，把这三个表达式分为： 中缀表达式 前缀表达式（波兰式） 后缀表达式（逆波兰式） 中缀表达式举例： 1(3 + 4) * 5 - 6 概念：中缀表达式的运算符以中缀形式处于运算数的中间。 前缀表达式举例： 1- * + 3 4 5 6 概念：前缀表达式的运算符位于运算数之前。 后缀表达式举例： 13 4 + 5 * 6 - 概念：后缀表达式的运算符位于运算数之间。 对于中缀表达式，不用过多的解释，这个是我们日常使用的表达方式，一眼就能看出答案为 29。但是对于不了解的人来说，后面两个可能就不太看得懂了，其实，根据概念我们就可以大概猜出来了。由于加减乘除都是双运算数运算符，我们对于一个运算符要找出两个运算数与之搭配。先来看更简单易懂的后缀表达式（逆波兰式）求值，始终记住双运算数运算符。 从左到右取出第一个运算符前两个运算数 3 4 取出该运算符 + 将两个运算数和运算符按照中缀表达式结合 3 + 4 将使用了的运算符和运算数去除，将得到的结果放回原表达式 7 5 * 6 - 重复 1 ～ 4，扫描的起始位置更改为之前运算符+所在位置 直到表达式中运算符被使用完毕，最后的到的运算数就是最终的值 29 接下来看稍微复杂一点的前缀表达式（波兰式），由于部分复杂，我将采用图示法。 表达式从右向左扫描，遇到数字则把数字压入栈中，直到遇到非数字的运算符 +, 得到一个数字栈 3 4 5 6 将栈顶元素出栈作为第一个运算数 a a = 3, 再执行一次出栈操作拿到栈顶元素作为第二个运算数 b b = 4，用～代表之前拿到的第一个运算符+，执行式子 a ~ b = 3 + 4 = 7 将运算结果7再次压栈，将～ +丢弃，从之前+所在的位置继续向左扫描 重复 1-3 步骤，直到扫描到最左边无运算符，停止运算，最后栈中剩下的数字就是求值的最后结果 29 通过我以上的描述，应该可以较明确的解释前缀、中缀、后缀表达式如何计算它们，下面给出一个更加复杂的前中后缀表达式，应该也很好计算。 中缀：1 + ( ( 2 + 3 ) × 4 ) - 5前缀：- + 1 × + 2 3 4 5后缀：1 2 3 + 4 × + 5 - 答案均为 16 经过上面的解释，不难看出，中缀和后缀表达式是比较好被计算机来解析并运算的，虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。 但是！我们先把转换表达式的方法放到最后来说，我们这里使用另一种简单直观、广为使用的方法来求解中缀表达式——算符优先算法 算符优先算法什么是算符优先算法呢？简单来说： 算符优先算法是根据运算优先关系的规定来实现对表达式的编译或解释执行的 举个例子，我们从小学就学过了四则运算的规则： 先乘除后加减 从左算到右 先算括号内再算括号外 所以对于以下式子，我们可以很快给出计算顺序然后得出正确的答案： 1234567894 + 2 * 3 - 10 / 5(1) 4 + 2 * 3 - 10 / 5(2) 2 * 3 = 6(3) 4 + 6 - 10 / 5(4) 10 - 10 / 5(5) 10 / 5 = 2(6) 10 - 2(7) 8 为了下面更好的理解一些术语词，先放上一段术语介绍： 任何一个表达式都是由操作数、运算符和界限符组成的，我们称它们为单词。一般地，操作数既可以是常数也可以是被说明为变量或常量标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有左右括号和表达式结束符等等。 我们把运算符和界限符统称为算符，它们构成的集合命名为 OP 容易看出，像 + - * / 为运算符， # ( ) 为界限符**(#为表达式结束符)**，则 OP 为这样一个集合 [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;] 那么我们如何让计算机在运算中判断两个相继出现的算符 ß1 和 ß2 之间的优先关系呢？ 通过算符优先级表！ PS: 纵轴符号为运算符 ß1，横轴符号为运算符 ß2 ß1 代表运算符栈顶元素，ß2 代表输入的算符 &gt; 代表 ß1 优先级高于 ß2 = 代表 ß1 优先级等于 ß2 &lt; 代表 ß1 优先级低于 ß2 可以看到，表中有内容为空的单元格，这是因为表达式中不允许他们相继出现，一旦有这种情况，我们可以把它当作出现了错误的表达式，在下面的讨论中我们假定所输入的表达式不会出现语法错误，关于这个表的具体使用方法，我们在下面的讨论中会提到。 磨刀不误砍柴功，在我们正式开始编码之前，举出一些问题并想到解决办法会让我们的编程思路更加清晰。 如何读取输入的中缀表达式 如何实现算符优先算法 如何寄存运算数和运算符 如何使用算符优先级表判断运算符优先级 如何实现多位数字和小数的存储 如何判断输入的字符是否为数字 … 有一些问题需要随着我们深入编码才会逐渐浮现出来，所以在下面再提出并解决吧～现在，就来正式开始编码之旅 Coding先来解决上面已经列出来的问题吧！ 如何读取输入的中缀表达式？ 针对这个问题，书上给出了一种方式，使用getchar()，一开始我也确实是使用这种方法的，但后面暴露了一些问题： 每次只能读取一位字符，比如输入 10 只能分开读取为 1，0，导致难以判断是多位数字还是个位数字 还有一个问题到后面再提，这里先mark一下 于是我放弃了使用getchar()，决定使用一个字符数组来存储我所输入的中缀表达式，初始代码如下： 123456789int main() &#123; char express[STACK_INIT_SIZE]; // 存储中缀表达式 int result; // 存储运算结果 cout &lt;&lt; &quot;输入中缀运算式: &quot;; cin &gt;&gt; express; // 直接用cin读取中缀表达式 result = MidExpression_Eval(express); // 这是定义的解析中缀表达式的函数 cout &lt;&lt; express &lt;&lt; &#x27;=&#x27; &lt;&lt; result &lt;&lt; endl; // 输出等式 return 0;&#125; 上面的STACK_INIT_SIZE是我一开始在程序头部定义的一个常数： 1const int STACK_INIT_SIZE = 100; 用途除了初始化存储中缀表达式的数组的内存空间、还用于初始化栈，会在下面说到。 针对这个问题，以上代码其实很明显的暴露了一些问题： 运算中免不了有除法，所以会出现有小数的情况 每次输入运算符都要自己手动在末尾加入运算结束符#，很麻烦 在输出等式的时候，会将运算结束符也输出，即会出现1+3*2/5#=2.2的情况 解决方法很简单： int result 写成 float result，实在不放心还能写成 double result 在输入的时候不输入 #，在代码中将 # 添加到字符数组的最后面 123...express[strlen(express)] = &#x27;#&#x27;; // 一定要放在下一句的前面result = MidExpression_Eval(express); strlen() 的功能就是返回数组内实际所占的长度，不记录\\0，这里 就不过多的描述了。 举个例子就明白了： 1234char test[100] = &#123;&#x27;2&#x27;, &#x27;+&#x27;, &#x27;3&#x27;, &#x27;*&#x27;, &#x27;4&#x27;&#125;;cout &lt;&lt; strlen(test); // 5test[strlen(test)] = &#x27;#&#x27; // 相当于 test[5] = &#x27;#&#x27;cout &lt;&lt; test; // 2+3*4# 通过上面的方法，我们免去了输入中缀表达式的结束符#，但是我们实际上express的内容仍带有 #，所以，我们在输出等式之前，可以先把结束符去除: 123result = MidExpression_Eval(express);express[strlen(express) - 1] = &#x27;\\0&#x27;; // 必须放在上面那个式子的后面cout &lt;&lt; express &lt;&lt; &#x27;=&#x27; &lt;&lt; result &lt;&lt; endl; 解释一下，由于在解决 2 里面将 # 加了 express 内，会使expresss 的长度增加 1，也就是strlen(express) 的值会比原来大 1，因此 # 的位置就在 express[strlen(express) - 1]，把这个位置的字符替换成 \\0，因为 cout 在输出字符数组的时候会截止于 \\0 三个问题都解决了，最后代码清单： 12345678910int main() &#123; char express[STACK_INIT_SIZE]; // 存储中缀表达式 float result; cout &lt;&lt; &quot;输入中缀运算式: &quot;; cin &gt;&gt; express; express[strlen(express)] = &#x27;#&#x27;; result = MidExpression_Eval(express); express[strlen(express) - 1] = &#x27;\\0&#x27;; cout &lt;&lt; express &lt;&lt; &#x27;=&#x27; &lt;&lt; result &lt;&lt; endl; return 0;&#125; 但是这样真的好了吗? (😏 笑) 其实上面还有一个问题，暂时还没有暴露出来。在这里就提前说了吧！ 注意到我们的中缀表达式字符数组只是定义了但没有初始化，一开始我也觉得应该没有什么问题，但直到我把所有程序完成执行输出的时候这个问题才暴露了出来： cout &lt;&lt; express 并没有在预期的位置(设置’\\0’的地方)停止输出，而是在后面的一些的位置停止，导致输出了一些乱码。这是为什么呢？ 在数组初始化之前，数组里的每一个数据单元的内容都是不确定的，如果我们不进行初始化的话，就会导致数组未赋值的区域内容不确定，就有可能出现上述情况，因此，我们做出一个改进，即初始化express数组： 1char express[STACK_INIT_SIZE] = &#123;&#125;; 这样就解决了不在预期停止输出的 bug。 好了，接下去下一个大问题。 如何实现算符优先算法算法思想： 首先置运算数栈为空栈，表达式起始符 # 作为运算符栈的栈底元素 依次读入表达式中的每一个字符，若是运算数则进运算数栈，若是运算符则和运算符栈中的栈顶运算符比较优先级后作相应操作，直至整个表达式求值完毕（即运算符栈的栈顶元素和当前读入的字符均为 # 如何寄存运算符和运算数我的自我对算符优先的认识（没有具体考证，待指正。）： 算符优先算法的求解过程跟后缀表达式求值过程十分相似，均是使用 压栈_， _入栈_， _栈外运算 等操作完成的。 因此，我们需要使用 栈 来存储我们的运算数和运算符，因此我们需要声明、定义和初始化栈，版本 1 的代码如下： 123456789typedef struct Sqstack &#123; char *base, *top; // 栈顶和栈底指针 int stacksize; // 栈的内存大小&#125; Sqstack0, Sqstack1; // 运算数栈1 ／ 运算符栈0...// 在某个函数内Sqstack0 OPTR; // 运算符栈Sqstack1 OPND; // 运算数栈 只声明了一个栈类型，但定义了两个结构体变量，分别用来存储运算数和运算符，这样做有一个好处： 只需要写一个初始化栈、入栈、出栈、获取栈顶元素函数 但是相比于它所带来的缺点，这个优点可以忽略了： 运算符和运算数都用同一个类型的栈，其内部的指针均为字符类型，对于运算数会产生许多麻烦的事情，比如： 对于多位数字，无法存入数字类型，且作为字符也只能一个个存，且转换成数字很麻烦 从运算数数栈中取出的是字符，无法直接参与运算 解决的话可以使用两个不同的栈分别存储运算数和运算符： 1234567891011typedef struct /* 运算符栈 */&#123; char *base, *top; int stacksize;&#125; SqStack;typedef struct /* 运算数栈 */&#123; int *base, *top; int stacksize;&#125; SqStack1; 上面对于不同的栈指定了不同的指针类型，但运算数栈的指针类型真的正确吗？想一想看，这个栈是用来寄存运算数的，而在运算过程中可能会产生浮点类型的数字，因此我们要改成： 12345typedef struct /* 运算数栈 */&#123; float *base, *top; int stacksize;&#125; SqStack1; 如何判断一个字符是否为数字答: ASCII 码 众所周知，字符在内部是以 ASCII码 来存储的，数字 0 ～ 9 都是使用连续的 ASCII码 表示的，且有一个更重要的是，字符之间是可以比较大小的，比较的就是 ASCII码 的大小，因此，我们可以据此实现判断一个字符是否为数字的方法： 123bool isNumber(char c) &#123; return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;); // 是数字返回 true，不是则返回 false&#125; 如何实现多位数字以及小数的存储来看一个式子： 16 + 12 * 3 / 9 // 10 按照我们的算法思想，首先先使用上面写的 isNumber(char c) 函数，判断该字符是否为一个数字，如果是，我们需要先把它转换成真正的数字，比如说第一个遇到了字符 &#39;6&#39;，我们可以这样把它转换成数字： 123...int num;num = c - &#x27;0&#x27;; // num 为 6 记住，字符也是可以进行运算的（用 ASCII 码），查 ASCII码表 就可以知道，字符 &#39;6&#39; 的 ASCII码 为 64，&#39;0&#39; 的 ASCII码 为 48，则两个字符相减刚好为数字 6， 这样就将字符转换成了数字。 但是，当我们遇到 12 的时候又会出现什么问题呢，12 会被拆分成 &#39;1&#39;, &#39;2&#39;，如果我们不经过任何处理就压入运算数栈的话是会出问题的，那么该如何解决呢？代码如下： 123456789101112131415161718192021...i = 0theChar = express[i]; // 拿到表达式的第一个值while (theChar != &#x27;#&#x27; || GetTop(Op_char) != &#x27;#&#x27;) &#123; // 判断表达式是否结束 char numbers[20]; // 用于存储多位数字 int j = 0; // 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度 while (isNumber(theChar)) &#123; // 若是数字，则循环读取 numbers[j] = theChar; i++; j++; theChar = express[i]; &#125; if (j &gt; 0) &#123; // 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈 float sum = 0; for (int k = 0; k &lt; j; k++) &#123; sum += (numbers[k] - &#x27;0&#x27;) * pow(10, j - 1 - k); // 将字符转换成对应的数字 &#125; Push1(Op_float, sum); &#125; else &#123; ... &#125;; // 若不是数字则执行else里的操作&#125; 关于除了处理多位数字的代码，上面都有详细的注释，这里着重解释多位数字的存储。 首先我们定义了字符数组，分配了 20 个内存单元，因为我们读入的数字不管是 int类型还是 float 类型进行四则运算一般不超过这个长度；同时，使用一个变量 j 来存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度，还能通过判断是否为 0 来辨别是运算数还是运算符。 若扫描到某一位为数字，不会直接将其压入运算符栈中，而是会继续获取下一位，直到获取到非数字时，while 才会跳出循环，进行数字位数(j)的判断。若是多位数字，则循环遍历存储着多位数字的数组 numbers[]，将其转换成真正的数字。 for 循环里面的那句语句如何理解呢？举个例子，假设： 1char numbers[20] = &#123;&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;&#125; 我们知道这是一个三位数字，值为123，那么如何根据其下标转换成数字呢？ 我们上面提到了如何将单个字符转换成单个数字，所以 numbers[k] - &#39;0&#39;就很好理解，pow() 函数是一个求次方的函数， pow(10, 2) 是求 10 的二次方，观察我假设的这个字符数组，我们可以获得三个信息： 长度j为 3 对应下标k为 0, 1, 2 值为 123 其次，123 可以拆分成 1 * 10^2 + 2 * 10^1 + 3 * 10^0，所以答案一目了然，10 的幂可以由公式 j - k - 1（数组长度 - 当前数字字符下标 - 1）求出， 所以转换公式为 1(numbers[k] - &#x27;0&#x27;) * pow(10, j - 1 - k) 运算结束后，将累加得到的数字 sum 压入运算数栈，大功告成。 且慢，如果数字是小数怎么办？同样的思路，我们来将之前的代码改进一下： 123456789101112131415161718192021222324252627282930313233i = 0theChar = express[i]; // 拿到表达式的第一个值while (theChar != &#x27;#&#x27; || GetTop(Op_char) != &#x27;#&#x27;) &#123; char numbers[10]; // 用于存储多位数字 int j = 0; // 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度 while (isNumber(theChar) || theChar == &#x27;.&#x27;) &#123; // 若是数字或小数点，则循环读取 numbers[j] = theChar; i++; j++; theChar = express[i]; &#125; if (j &gt; 0) &#123; // 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈 float sum = 0; int dot = getIndex(numbers, &#x27;.&#x27;); // 若无小数点则返回-1 for (int k = 0; k &lt; j; k++) &#123; if (numbers[k] == &#x27;.&#x27;) &#123; continue; &#125; if (dot != -1) &#123; if (k &lt; dot) &#123; sum += (numbers[k] - &#x27;0&#x27;) * pow(10, j - 1 - k - dot - 1); // 将字符转换成对应的多位数字 &#125; else if (k &gt; dot) &#123; // 若没有小数点，这个块不执行 sum += (numbers[k] - &#x27;0&#x27;) * pow(10, dot - k); &#125; &#125; else &#123; sum += (numbers[k] - &#x27;0&#x27;) * pow(10, j - 1 - k); &#125; &#125; Push1(Op_float, sum); &#125; else &#123;...&#125; // 若不是数字则执行else里的操作&#125; 小数转换的思路就不多说了，和上面是一样的，用小数点所在的位置减去小数点后面的数字的位置得到的就是其10的幂的值。 但是，这里面还是有一些要小心的陷阱： j 会因为含有小数点而增加长度，因此不能再使用 j - 1 - k 来确定整数部分乘以10的幂的值了, 应该将长度j减去小数点占的一个元素再减去小数点所在的下标dot。 区分小数点前后的转换规则，若 k &lt; dot 执行整数部分转换， 若 k &gt; dot 执行小数部分转换 除此之外，里面增加了一个新的函数 getIndex(numbers, &#39;.&#39;)，是为了寻找小数点，找到了则返回小数点的下标，没有找到则返回 -1，根据下标是否等于 -1 判断是否是一个小数。来看这个函数的内部实现： 12345678int getIndex(char ops[], char e) &#123; for (int i = 0; i &lt; 7; i++) &#123; if (e == ops[i]) &#123; return i; &#125; &#125; return -1;&#125; ok，这个问题也解决了，下面解决最让人疑惑的部分。 如何使用算符优先级表判断运算符优先级算符优先级表我之前已经给出了，对于这样一个表，第一反应就是将它转换成二维数组，行代表输入的字符，列代表运算符栈顶元素： 123456789const char priority[7][7] = &#123; &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // + &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // - &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // * &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // / &#123;&#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27; &#x27;&#125;, // ( &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27; &#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // ) &#123;&#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27; &#x27;, &#x27;=&#x27;&#125; // #&#125;; 对于这张表，我们需要做什么呢，在上面介绍这张表的时候，已经给出了一些关于 &#39;&gt;&#39;, &#39;=&#39;, &#39;&lt;&#39; 的具体含义，我们要做的就是根据输入的字符和运算符栈顶元素来从这张表中获取它们的优先级比较。 具体做法： 我们先创建一个运算符全集数组，用来对应优先级表的第一行和第一列的元素符元素（看之前的那张图）: 12// 与比较符号优先级二维数组对应的操作符全集char OP[] = &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;#&#x27;&#125;; 有了这个，我们只需要找出输入的字符在这个数组中对应的下标 i**以及运算符栈顶元素在这个数组中对应的下标 j，就可以通过 priority[i][j] 来获取 **运算符栈顶元素 和 输入的算符 之间的优先关系。用一个十分精简的函数 Precede 实现获取其优先关系: 1234char Precede(char top, char c) &#123; // top 为运算符栈顶元素，c为输入的算符 return priority[getIndex(OP, top)][getIndex(OP, c)];&#125; 其中使用了 getIndex() 辅助函数。 这个函数我们有三个可能的返回值： &lt; 栈顶元素优先级低，将输入的算符压入运算符栈，因为栈的LIFO原则，越靠近栈顶的元素会有更高的优先级去进行运算，之后继续读取下一个字符。 = 优先级相等，除了 &#39;#&#39; 与 &#39;#&#39;之间，就只有 &#39;(&#39; 和 &#39;)&#39;了，但是 &#39;#&#39; 是不可能出现在这一层函数的，它会在最外部的 while 循环中判断。所以这里的作用就是将运算符栈处于栈顶位置的 &#39;(&#39;脱去，并读取下一个字符，以便其他算符的运算 ‘&gt;’ 栈顶元素优先级高，将优先处理栈顶元素：将运算符栈顶元素取出，同时取出两次运算数栈顶元素，将其组合成中缀表达式进行运算，将运算结果再重新压入运算数栈内，达到优先运算的预期要求（此时无需读取下一个字符，因为输入的字符还未使用）。 实现的代码如下： 1234567891011121314151617181920switch (Precede(GetTop(Op_char), theChar)) &#123; case &#x27;&lt;&#x27;: // 栈顶元素优先级比此时的取值更低 Push(Op_char, theChar); // 压入运算符栈 theChar = express[++i]; // 使读取的位置后移，并取到下一个字符 break; case &#x27;=&#x27;: char x; Pop(Op_char, x); // 脱括号并读取下一个字符 theChar = express[++i]; break; case &#x27;&gt;&#x27;: // 出栈并将运算结果入栈 char theta; float a, b; Pop(Op_char, theta); Pop1(Op_float, b); Pop1(Op_float, a); Push1(Op_float, Operate(a, theta, b)); default: break;&#125;; theChar 来用保存当前读取的字符，Op_char 是定义并经过初始化的运算符栈， Op_float 是定义并经过初始化的运算数栈，Push 和 Pop 是对运算符栈的入栈和出栈， Push1 和 Pop1 是对运算数栈的入栈和出栈。它们对应的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SqStack Op_char; // 声明运算符栈SqStack1 Op_float; // 声明运算数栈char theChar; // 记录目前读取表达式的字符InitStack(Op_char); // 初始化运算符栈Push(Op_char, &#x27;#&#x27;); // 将最低优先级的&#x27;#&#x27;起始符压入操作数栈InitStack1(Op_float); // 初始化运算数栈...void InitStack(SqStack &amp;s) &#123; // 初始化运算符栈 s.base = (char *) malloc(STACK_INIT_SIZE * sizeof(char)); s.top = s.base; s.stacksize = STACK_INIT_SIZE;&#125;void Push(SqStack &amp;s, char e) &#123; // 将运算符压入运算符栈 if (s.top - s.base &gt;= s.stacksize) &#123; s.base = (char *) realloc(s.base, (s.stacksize + STACK_INCREMENT) * sizeof(char)); s.top = s.base + s.stacksize; s.stacksize += STACK_INCREMENT; &#125; *s.top++ = e;&#125;void Pop(SqStack &amp;s, char &amp;e) &#123; // 将运算符栈顶元素出栈 if (s.top != s.base) e = *--s.top;&#125;void InitStack1(SqStack1 &amp;s) &#123; // 初始化运算符栈 s.base = (float *) malloc(STACK_INIT_SIZE * sizeof(float)); s.top = s.base; s.stacksize = STACK_INIT_SIZE;&#125;void Push1(SqStack1 &amp;s, float e) &#123; // 将运算数压入运算数栈 if (s.top - s.base &gt;= s.stacksize) &#123; s.base = (float *) realloc(s.base, (s.stacksize + STACK_INCREMENT) * sizeof(float)); s.top = s.base + s.stacksize; s.stacksize += STACK_INCREMENT; &#125; *s.top++ = e;&#125;void Pop1(SqStack1 &amp;s, float &amp;e) &#123; // 将运算数栈顶元素出栈 if (s.top != s.base) e = *--s.top;&#125; 这上面的代码都是对栈的基本操作，就不详细解释了。 除此之外，之前的代码里还有一个 Operate() 函数，其作用就是实现双操作符的运算的，返回的是运算的结果，代码如下： 1234567891011121314151617181920float Operate(float a, char x, float b) &#123; float result = 0; switch (x) &#123; case &#x27;+&#x27;: result = a + b; break; case &#x27;*&#x27;: result = a * b; break; case &#x27;-&#x27;: result = a - b; break; case &#x27;/&#x27;: result = a / b; break; default: break; &#125; return result;&#125; 由于代码简单，没有什么技术含量，也不详细解释了。 = 至此，我们已经把提出的所有的问题解决了，下面附上源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;// 定义栈类型typedef struct /* 运算符栈 */&#123; char *base, *top; int stacksize;&#125; SqStack;typedef struct /* 运算数栈 */&#123; float *base, *top; int stacksize;&#125; SqStack1;// 定义所使用的常量集const int STACK_INIT_SIZE = 100;const int STACK_INCREMENT = 10;/* 用于比较符号优先级的全局二维数组 */const char priority[7][7] = &#123; &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // + &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // - &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // * &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // / &#123;&#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27; &#x27;&#125;, // ( &#123;&#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;, &#x27; &#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;&#125;, // ) &#123;&#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;, &#x27; &#x27;, &#x27;=&#x27;&#125; // #&#125;;// 与比较符号优先级二维数组对应的操作符全集char OP[] = &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;#&#x27;&#125;;// 函数预定义// 操作结果：初始化运算符栈void InitStack(SqStack &amp;s);// 操作结果：得到运算符栈的栈顶元素char GetTop(SqStack &amp;s);// 操作结果：对运算符栈进行压栈操作void Push(SqStack &amp;s, char e);// 操作结果：对运算符栈进行出栈操作void Pop(SqStack &amp;s, char &amp;e);// 操作结果：初始化运算数栈void InitStack1(SqStack1 &amp;s);// 操作结果：得到运算数栈的栈顶元素float GetTop1(SqStack1 &amp;s);// 操作结果：对运算数栈进行压栈操作void Push1(SqStack1 &amp;s, float e);// 操作结果：对运算数栈进行出栈操作void Pop1(SqStack1 &amp;s, float &amp;e);// 操作结果：判断一个字符是否是数字bool isNumber(char c);// 操作结果：计算中缀表达式的值float MidExpression_Eval(char Express[]);// 操作结果：计算表达式axb，并返回结果float Operate(float a, char x, float b);// 操作结果：获取操作符在全集操作符中的位置，并返回下标，此函数为辅助函数int getIndex(char ops[], char e);char Precede(char top, char c);// 操作结果：获取算符优先级关系，并返回具体优先级符号，如&#x27;&lt;&#x27;,&#x27;&gt;&#x27;等int main() &#123; char express[STACK_INIT_SIZE] = &#123;&#125;; // 存储中缀表达式 float result; cout &lt;&lt; &quot;输入中缀运算式: &quot;; cin &gt;&gt; express; express[strlen(express)] = &#x27;#&#x27;; result = MidExpression_Eval(express); express[strlen(express) - 1] = &#x27;\\0&#x27;; cout &lt;&lt; express &lt;&lt; &#x27;=&#x27; &lt;&lt; result &lt;&lt; endl; return 0;&#125;// 函数实现void InitStack(SqStack &amp;s) &#123; // 初始化运算符栈 s.base = (char *) malloc(STACK_INIT_SIZE * sizeof(char)); s.top = s.base; s.stacksize = STACK_INIT_SIZE;&#125;char GetTop(SqStack &amp;s) &#123; // 获取运算符栈的栈顶元素 if (s.top != s.base) &#123; return *(s.top - 1); &#125;;&#125;void Push(SqStack &amp;s, char e) &#123; // 将运算符压入运算符栈 if (s.top - s.base &gt;= s.stacksize) &#123; s.base = (char *) realloc(s.base, (s.stacksize + STACK_INCREMENT) * sizeof(char)); s.top = s.base + s.stacksize; s.stacksize += STACK_INCREMENT; &#125; *s.top++ = e;&#125;void Pop(SqStack &amp;s, char &amp;e) &#123; // 将运算符栈顶元素出栈 if (s.top != s.base) e = *--s.top;&#125;void InitStack1(SqStack1 &amp;s) &#123; // 初始化运算符栈 s.base = (float *) malloc(STACK_INIT_SIZE * sizeof(float)); s.top = s.base; s.stacksize = STACK_INIT_SIZE;&#125;float GetTop1(SqStack1 &amp;s) &#123; // 获取运算数栈的栈顶元素 if (s.top != s.base) &#123; return *(s.top - 1); &#125;&#125;void Push1(SqStack1 &amp;s, float e) &#123; // 将运算数压入运算数栈 if (s.top - s.base &gt;= s.stacksize) &#123; s.base = (float *) realloc(s.base, (s.stacksize + STACK_INCREMENT) * sizeof(float)); s.top = s.base + s.stacksize; s.stacksize += STACK_INCREMENT; &#125; *s.top++ = e;&#125;void Pop1(SqStack1 &amp;s, float &amp;e) &#123; // 将运算数栈顶元素出栈 if (s.top != s.base) e = *--s.top;&#125;bool isNumber(char c) &#123; return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;);&#125;float Operate(float a, char x, float b) &#123; float result = 0; switch (x) &#123; case &#x27;+&#x27;: result = a + b; break; case &#x27;*&#x27;: result = a * b; break; case &#x27;-&#x27;: result = a - b; break; case &#x27;/&#x27;: result = a / b; break; default: break; &#125; return result;&#125;int getIndex(char ops[], char e) &#123; for (int i = 0; i &lt; 7; i++) &#123; if (e == ops[i]) &#123; return i; &#125; &#125; return -1;&#125;char Precede(char top, char c) &#123; return priority[getIndex(OP, top)][getIndex(OP, c)];&#125;float MidExpression_Eval(char express[]) &#123; SqStack Op_char; // 声明运算符栈 SqStack1 Op_float; // 声明运算数栈 int i = 0; // 记录表达式读取位置 char theChar; // 记录目前读取表达式的字符 InitStack(Op_char); // 初始化运算符栈 Push(Op_char, &#x27;#&#x27;); // 将最低优先级的&#x27;#&#x27;起始符压入操作数栈 InitStack1(Op_float); // 初始化运算数栈 theChar = express[i]; // 拿到表达式的第一个值 while (theChar != &#x27;#&#x27; || GetTop(Op_char) != &#x27;#&#x27;) &#123; char numbers[10]; // 用于存储多位数字 int j = 0; // 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度 while (isNumber(theChar) || theChar == &#x27;.&#x27;) &#123; // 若是数字或小数点，则循环读取 numbers[j] = theChar; i++; j++; theChar = express[i]; &#125; if (j &gt; 0) &#123; // 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈 float sum = 0; int dot = getIndex(numbers, &#x27;.&#x27;); // 若无小数点则返回-1 for (int k = 0; k &lt; j; k++) &#123; if (numbers[k] == &#x27;.&#x27;) &#123; continue; &#125; if (dot != -1) &#123; if (k &lt; dot) &#123; sum += (numbers[k] - &#x27;0&#x27;) * pow(10, j - 1 - k - dot - 1); // 将字符转换成对应的多位数字 &#125; else if (k &gt; dot) &#123; // 若没有小数点，这个块不执行 sum += (numbers[k] - &#x27;0&#x27;) * pow(10, dot - k); &#125; &#125; else &#123; sum += (numbers[k] - &#x27;0&#x27;) * pow(10, j - 1 - k); &#125; &#125; Push1(Op_float, sum); &#125; else &#123; switch (Precede(GetTop(Op_char), theChar)) &#123; case &#x27;&lt;&#x27;: // 栈顶元素优先级比此时的取值更低 Push(Op_char, theChar); // 压入运算符栈 theChar = express[++i]; // 使读取的位置后移，并取到下一个字符 break; case &#x27;=&#x27;: char x; Pop(Op_char, x); theChar = express[++i]; break; case &#x27;&gt;&#x27;: char theta; float a, b; Pop(Op_char, theta); Pop1(Op_float, b); Pop1(Op_float, a); Push1(Op_float, Operate(a, theta, b)); default: break; &#125; &#125; &#125; return GetTop1(Op_float);&#125; 结束吗看上去我们的代码已经很完善了，其实我们还有一些东西没有处理： 如果输入了错误的中缀表达式？ 某些地方的代码可以更加优雅？ 大量的中缀表达式验证正确性？ 对于第一点，我是假设于使用程序的人都会输入正确的中缀表达式，并没有对错误的中缀表达式进行处理和反馈提示，因此对用户有一些不友好，待改进；其次，像一些 for 循环，if else 语句可以更加精简、优雅，没有对代码进行多次提炼，待改进；这个应用程序没有经过大量、多样的测试来验证其准确性，所以并不能保证其完全正确，待改进。 深入与思考 如何求后缀表达式的值，以及中缀表达式如何转换为后缀表达式？ 对于前一个问题，我在 Thinking 里已经描述过了，这里就不再再次阐述，对于后一个问题，有了上面的基础，也是很容易实现的，这里就不用代码描述了，就用文字描述一下大概的思路： 初始化两个栈：运算符栈 S1 和储存中间结果的栈 S2； 从左至右扫描中缀表达式； 遇到操作数时，将其压入 S2； 遇到运算符时，比较其与 S1 栈顶运算符的优先级： 如果 S1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入 S1； 否则，将 S1 栈顶的运算符弹出并压入到 S2 中，再次转到4-i与 S1 中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入 S1； 如果是右括号“)”，则依次弹出 S1 栈顶的运算符，并压入 S2，直到遇到左括号为止，此时将这一对括号丢弃； 重复步骤2 至 5，直到表达式的最右边； 将 S1 中剩余的运算符依次弹出并压入 S2； 依次弹出 S2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。 总结通过这次的程序和记录总结，我学到了很多，其中最值得一提的就是编码方式。 在编写程序的时候，我可以先不管各个功能的具体实现（比如Operate()啊，Pop()啊什么的）， 我只需要关注完成这个程序需要什么功能，先写下来，完成一个主函数的逻辑，到后面再去分别实现一个个的辅助函数的逻辑，领悟了这一点对我来说是非常有帮助的，这可以大大的提高我函数式编程的思维。 除此之外，实现一些辅助函数的辅助函数的时候也对我的思维进行了锻炼，比如说精简的Precede()，对多位数字和小数的处理，以及整个中缀表达式求值思维得到了巩固和拓展，对于克服种种难题有满满的成就感。 好了，就这样吧，这应该是我写的最认真的一篇记录了，加油。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"https://wingsico.github.io/tags/C/"}]},{"title":"自动签到续篇 —— Linux定时服务","slug":"linux-crontab","date":"2017-11-13T14:42:02.000Z","updated":"2020-12-07T05:44:32.064Z","comments":true,"path":"2017/11/13/linux-crontab/","link":"","permalink":"https://wingsico.github.io/2017/11/13/linux-crontab/","excerpt":"Linux 利用 crontab 实现简单的定时任务","text":"Linux 利用 crontab 实现简单的定时任务 准备工作自己的电脑是 Mac OS，命令跟 linux 差不多吧，但是定时任务也不应该在自己的电脑上跑吧，因为自己的电脑总会关的，服务也会停止的。所以我选择了我的博客所在的服务器，这个是 linux centos 系统。这个是我在腾讯云花一元/月领的（现在这个活动已经结束啦），ok，自动签到 js 脚本和服务器都有了，可以开始我们的任务了。 开始首先，服务器上还没有我们的脚本，我们需要把我们的脚本上传到服务器里，怎么上传呢？ 在 mac os 里（may linux 里也有），进入我们脚本所在目录: 1234➜ ~ cd ~/my-github/nodejs/util➜ ~ scp checkin.js root@wingsico.org:/home/checkin.jspassword:ok 这样就上传到我们服务器的/home 目录下，并将文件命名为 checkin.js 可以通过 ssh 进入服务器查看一下，很好，/home 目录下已经有我们的脚本文件 checkin.js 了，先尝试运行一波: 12345[root@VM_48_13_centos ~/home]# node checkin.js[root@VM_48_13_centos ~\\]# cd /var/spool/mail/[root@VM_48_13_centos mail]# nano root// 翻到最后一行OK &#123;&quot;msg&quot;:&quot;签到成功&quot;,&quot;ret&quot;:1&#125; 签到成功了，ok，那么我们就开始写定时服务。 定时服务在 linux 中我们使用 crontab 这个命令来管理定时任务,我们可以使用 crontab –help(其实是靠输入错误来弹出相关提示…)来查看相关命令: 12345678usage: crontab [-u user] filecrontab [-u user] [ -e | -l | -r ](default operation is replace, per 1003.2)-e (edit user&#x27;s crontab)-l (list user&#x27;s crontab)-r (delete user&#x27;s crontab)-i (prompt before deleting user&#x27;s crontab)-s (selinux context) 为了更好的运行脚本，我们写一个 shell 脚本来运行 js 脚本: 12#!/bin/sh/root/.nvm/versions/node/v8.7.0/bin/node /home/checkin.js 发现了吗？我们这里没有直接用 node 来运行 js 脚本，因为 shell 脚本运行的环境不同，不能直接通过 node 来运行 js 脚本，我们使用which node来找到 node 的运行的源文件，保存在统一目录下，命名为 checkin.sh，接下来我们在定时任务里就可以直接运行这个脚本就好了，现在来编辑定时任务了，输入crontab -e，添加 110 09 * * * sudo bash /home/checkin.sh &amp; 前面的参数的含义就是 每天的 9 点 10 分，这个命令就是在每天 9 点 10 分运行一次 checkin.sh 脚本，记得加 sudo，不然会在日志中提示权限不够。好了，之后输入: 1[root@VM_48_13_centos ~]# /sbin/service crond start 开启定时服务～之后如果修改 crontab 的话使用 1[root@VM_48_13_centos ~]# /sbin/service crond restart","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"}]},{"title":"用node实现一个每日签到脚本","slug":"node-checkin","date":"2017-11-12T05:44:26.000Z","updated":"2020-12-07T05:44:32.065Z","comments":true,"path":"2017/11/12/node-checkin/","link":"","permalink":"https://wingsico.github.io/2017/11/12/node-checkin/","excerpt":"曾在大一的时候就听田大佬写了一个每日自动签到的脚本，觉得很牛逼，不过现在看起来确实和当初田大佬说的那样简单&gt;,&lt;，话不多说，直接开始吧。","text":"曾在大一的时候就听田大佬写了一个每日自动签到的脚本，觉得很牛逼，不过现在看起来确实和当初田大佬说的那样简单&gt;,&lt;，话不多说，直接开始吧。 准备工作首先这个签到是我学校的一个工作室的内部网站的签到。一开始认为只需要登录了就算签到了（大一不了解的时候），现在知道了，其浏览器上的流程大概是： 打开登录页面 ——&gt; 输入账号密码 ——&gt; 点击登录 ——&gt; 登录成功&amp;自动完成签到; 其内部实现为: 输入网址 ——&gt; 发送 get 请求 ——&gt; 拿到返回的 html 并展示 ——&gt; 输入账号密码 ——&gt; 将账号密码放在请求体内通过 post 请求发送到对应的登录 api ——&gt; 拿到对应 api 所返回的数据（这里我们只需要 token） ——&gt; 对签到的 api 发送一个 post 请求，将 token 放入请求头中发送 ——&gt; 签到成功. 那么如何实现以上操作呢？ 实现首先，打开 us.ncuos.com(我们内部的网站), f12 打开 chrome debugger tools，点击 network，钩上 presever log，然后输入账号密码，点击登录，成功之后右边就会出现一堆请求，我们找到 Name 为 login 的包，这里标清楚了请求的 url，method 和请求体的类型，根据这三个我们可以很简单的写一个模拟登录来拿到对应的 token： 12345678910111213141516171819202122232425var request = require(&quot;request&quot;); // 引入request包var contents = &#123; username: &quot;613*****&quot;, password: &quot;******&quot;, remember_me: false&#125;; // 请求体，目前为一个对象var options = &#123; url: &quot;http://us.ncuos.com/api/user/login&quot;, // 请求的url method: &quot;POST&quot;, // 请求的方式 post headers: &#123; // 设置请求头 &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot; &#125;, body: JSON.stringify(contents) // 对象JSON化&#125;;// 发送一个请求，request(options, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var token = response.headers.authorization; // 响应头里存储着token console.log(token); &#125;&#125;); ok，是不是很简单呢，这样我们就拿到了 token，就可以为所欲为了啊嘎嘎，比如爬个帖子内容啥的！哦不，回归正题，签到签到，我们再次回到浏览器，我们登录之后还请求了一些别的数据，比如 Name 为 checkin 的就是我们要找的签到的 api，由于这个接口是没有请求体的，所以我们不需要类似上面的 contents 了，只需要在登录之后再发送一个 post 请求，设置好请求头就可以了，由于代码比较短，就直接放在登录成功后的 if 语句内: 123456789101112131415161718192021request(options, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var token = response.headers.authorization; // 响应头里存储着token var params = &#123; url: &quot;http://us.ncuos.com/api/checkin&quot;, // 请求url method: &quot;POST&quot;, // 请求方式 headers: &#123; // 请求头 &quot;Content-Type&quot;: &quot;Application/json&quot;, // 请求体格式 Authorization: token // auth token授权 &#125; &#125;; request(params, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body); // 打印出响应体 &#125; else &#123; console.log(error); &#125; &#125;); &#125;&#125;); 写好了之后，保存为 checkin.js， 执行 node checkin.js，发现打印出来的是 null，什么情况，为了查看原因，我们将签到请求做出一些修改: 12345678request(params, (error, response, body) =&gt; &#123; console.log(response.statusCode, response.statusMessage); if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body); // 打印出响应体 &#125; else &#123; console.log(error); &#125;&#125;); 发现打印了 400，forbidden，null，再打印了一下整个response，发现在error里有更加详细的一个报错: 1body: &#x27;&#123;&quot;error&quot;: &quot;InvalidData&quot;, &quot;message&quot;: &quot;invalid json content&quot;, &quot;status&quot;: 400&#125;&#x27; &#125; &#x27;&#123;&quot;error&quot;: &quot;InvalidData&quot;, &quot;message&quot;: &quot;invalid json content&quot;, &quot;status&quot;: 400&#125;&#x27; 很容易看出，error 为非法 json 格式内容。wtf?啥情况，我这个根本不需要请求体啊，为什么还来个这个错误呢，于是走上了漫漫排查之路。 debugger我首先先尝试了一下console.log(params)，发现headers里的Authorization少了引号，难道是这个的原因吗？然后我尝试了各种方法还是不能将引号加上，不过JSON.stringify(params) 之后是有引号的，所以觉得不是这个问题。苦思冥想无果之后，求助了一下学长，把情况说清楚之后，学长给出了一个尝试建议： 把 headers 里面的’Content-Type’去掉试试，去掉之后，我靠真的就成功了。之后探其原因是设置请求头中多余地规定了请求体的格式，但是你并没有也不需要发送请求体（对于这个 api），但设置了这个请求头之后就强制的要求了你的格式，所以导致上面的报错信息，非法的 content。为了验证这个想法，我把 Content-type 重新加上，写了一个 json 格式的请求体，里面数据随便填，果然也成功了！至此，我们的这个签到脚本就完成了。最终代码如下： 12345678910111213141516171819202122232425262728293031323334353637var http = require(&quot;http&quot;);var request = require(&quot;request&quot;);var contents = &#123; username: &quot;username&quot;, password: &quot;password&quot;, remember_me: false&#125;;var options = &#123; url: &quot;http://us.ncuos.com/api/user/login&quot;, method: &quot;POST&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot; &#125;, body: JSON.stringify(contents)&#125;;request(options, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var token = response.headers.authorization; var params = &#123; url: &quot;http://us.ncuos.com/api/checkin&quot;, method: &quot;POST&quot;, headers: &#123; Authorization: token &#125; &#125;; request(params, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body); &#125; else &#123; console.log(error); &#125; &#125;); &#125;&#125;); 但是这样每天我们还是需要去自己执行一下这个脚本，还是不如自己手动去登录一下签到呢，所以等下我们就要实现的是 Linux 服务器定时任务，可以每日定时执行这个脚本，就可以每日自动签到了，这个留到下一篇博客讲吧～先去睡觉～","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wingsico.github.io/tags/nodejs/"}]},{"title":"顺序表、链表的JS实现","slug":"squence-link","date":"2017-11-10T15:29:16.000Z","updated":"2020-12-07T05:44:32.067Z","comments":true,"path":"2017/11/10/squence-link/","link":"","permalink":"https://wingsico.github.io/2017/11/10/squence-link/","excerpt":"要实现顺序表和链表，首先我们需要知道的是，何为顺序表，何为链表。","text":"要实现顺序表和链表，首先我们需要知道的是，何为顺序表，何为链表。 顺序表这个很简单，在 JS 中，数组就是顺序表的实例，它具有顺序表的一切性质： 存放在连续的内存当中，物理位置相邻，换句话说，其数据元素都是用一组地址连续的存储单元以此存储在线性表当中； 只要确定了存储线性表的起始位置，顺序表中任一数据元素都可以随机存取； 具有线性表的性质（关于线性表，这里不作介绍，可以在这里了解线性表 所以，在 JS，要初始化一个空的顺序表是十分简单的: 1234567891011121314// 方式一var ary1 = []; // []// 方式二var ary2 = new Array(); // []// 神经病方式var ary3 = [...&quot;&quot;]; // []var ary4 = [...new Set()]; // []var ary5 = [...new Map()]; // []var ary6 = [...new String()]; // []var ary7 = &quot;&quot;.split(&quot;&quot;); // []var ary8 = Array.prototype.slice.call(&quot;&quot;); // []// 终极神经病方式var obj = &#123;&#125;;var ary9 = [...obj[Symbol.iterator]]; // [] 既然是自己实现顺序表，自然不能使用 js 数组中自带的方法啦，一般来说，顺序表有以下几个基本方法： createList() initList(L) getLength(L) insertList(L, i, e) deleteList(L, i , e) getListElem(L, i) getElemIndex(L, e) So, 接下来一个个实现吧～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//createListfunction createList(): any[] &#123; var array = new Array(); // [] return array;&#125;// initList(L)function initList(list: any[]): number[] &#123; if (list instanceof Array) &#123; var length = 15; // 由于js本身不能自己输入值，所以采用自己赋值来初始化一个顺序表 for (let i = 0; i &lt; length; i++) &#123; list[i] = i + 1; &#125; return list; &#125;&#125;// getLength(L)function getLength(list: number[]): number &#123; let len: number = 0; while (L[len] !== undefined) &#123; // 循环遍历每一个数据元素, 一个不为空则计数器加一 len++; &#125; return len;&#125;// insertList(L, i, e)function insertList(list: number[], index: number, item: number): number[] &#123; let i: number; let len = getLength(list); for (i = len - 1; i &gt;= index - 1; i--) &#123; list[i + 1] = list[i]; // 位置index之后的元素（包括index）全部往后移一个单元 &#125; list[index - 1] = item; return list;&#125;// deleteList(L, i)function deleteList(list: number[], index: number): number &#123; if (index &gt; getLength(list) + 1 || index &lt; 1) &#123; return -1; &#125; let i: number = index - 1; let len: number = getLength(list); let e = list[i]; for (; i &lt; len; i++) &#123; list[i] = list[i + 1]; // index之后的每一个元素往前移一个单元 &#125; list.length--; // 长度减1 return e;&#125;// getListElemfunction getListElem(list: number[], index: number): number &#123; if (index &gt; getLength(list) + 1 || index &lt; 1) &#123; return -1; &#125; return list[index - 1];&#125;// getElemIndex(L, e)function getIndex(list: number[], value: number): number &#123; let i: number = 0; for (; i &lt; getLength(list); i++) &#123; if (list[i] === value) &#123; return i; &#125; &#125;&#125; 最后再用一个 test 函数测试： 123456789101112131415161718function test() &#123; let sqList = createList(); console.log(&quot;创建空顺序表：&quot; + sqList); initList(sqList); console.log(&quot;初始化一个数字类型顺序表：&quot; + sqList); let elem = getListElem(sqList, 5); console.log(&quot;获取第五个元素：&quot; + elem); let index = getListIndex(sqList, 6); console.log(&quot;获取值为6的游标：&quot; + index); insertList(sqList, 4, 999); console.log(&quot;在第四个位置插入999：&quot; + sqList); let e = deleteList(sqList, 4); console.log(&quot;删除第四个位置的元素：&quot; + sqList, &quot;被删除的元素：&quot; + e); console.log(&quot;表长为：&quot; + getLength(sqList)); console.log(&quot;所有元素为：&quot;); consAll(sqList); // 输出所有元素&#125;test(); 一个简单的顺序表就完成了～，接下来介绍链表。 链表先介绍以下何为链表 链表也是线性表中的一元，它也是一个连续的表，不过相比于顺序表，它不要求物理位置上相邻，但要求的是逻辑位置上相邻，因此他没有顺序表所具有的弱点——删除、插入等需要移动大量的数据元素，但是也失去了顺序表随机存储的优点。 对于一个数据元素，我们这里把它叫做结点好了，一个结点（Node）中包含两个域，一个是存储自身信心的数据域，另一个是指向下一个结点的指针域，由于 js 里没有指针，那么我暂且称之为链域，指向的是该结点的下一个结点。从上图我们还发现了一个 head 结点，我们把它称之为 头指针，他的数据域可以不存储任何数据，也可以存储像表长等信息，其链域中存储的是指向链表的第一个结点的链。可能现在会对头指针的存在产生一个疑惑，那么我举个例子就明白了，试想一下，如果没有头指针，我们如何在第一个结点前再插入一个结点呢？这个操作很简单，就是把你新创建的结点的链域指向第一个结点，但是如果你不是插入到链表的最前面呢？你要先创建一个结点，然后让想插入的那个位置的前一个结点的链域指向你新创建的结点，再让你的链域指向你想插入的位置的那个结点。发现了吗？插入第一个和插入中间其他位置的操作是不相同的，为了简化和统一像这样的操作，于是引入头指针。链表的最后一个结点之后没有结点的存在，因此让他的链指向NULL 在传统语言如 c/c++中，因为有指针的存在，可以很明确的创建一个链表，而 js 中是没有指针的（this 应该不算吧）,那我们要如何去实现一个链表的结点呢？一开始想到用对象Object实现，但是对象复制有一些麻烦，于是转而选择了类function，看以下代码： 1234function LNode(): void &#123; this.data = null; this.next = null;&#125; 用公用属性 data 当作结点的数据域，用公有属性 next 当作链域，当新建一个结点的时候只需要 new LNode()即可，比较方便，当然，也可以使用 es6 的class，代码如下： 123456class LNode &#123; constructor() &#123; this.data = null; this.next = null; &#125;&#125; 由于 typescirpt 用的有一些生疏，以及 class 用的不太熟练，先用 es5 实现那些方法。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function LNode() :void&#123; this.data = null; this.next = null;&#125;function createLink(head: any, n: number): void&#123; let i: number; head.data = n for (i = n; i &gt; 0; i--) &#123; let newNode = new LNode() newNode.data = Math.floor(Math.random() * 10 + 1) newNode.next = head.next head.next = newNode &#125;&#125;function getElem(LinkList: any, i: number): number &#123; if (!LinkList.next) &#123; return &#125; let p: any = LinkList.next let j: number = 1 while (p &amp;&amp; j &lt; i) &#123; p = p.next ++j &#125; if (!p || j &gt; i) &#123; return &#125; return p.data&#125;function getIndexs(LinkList: any, value: number): number[] &#123; if (!LinkList.next) &#123; return &#125; let p: any = LinkList.next let indexs: number[] = new Array() let len = 0 let i: number = 1 while (p) &#123; if (p.data === value) &#123; indexs[len] = i len++ &#125; p = p.next i++ &#125; return indexs&#125;function insertElem(LinkList: any, pos: number, e: number): void &#123; if (!LinkList.next) &#123; return &#125; let p: any = LinkList let i: number = 0 while (p &amp;&amp; i &lt; pos - 1) &#123; p = p.next i++ &#125; if (!p || i &gt; pos - 1) &#123; return &#125; let s = new LNode() s.data = e s.next = p.next p.next = s LinkList.data++&#125;function consAll(LinkList: any): void &#123; let list: String = &#x27;&#x27; let p: any = LinkList.next while (p) &#123; list += p.data + &#x27;, &#x27; p = p.next &#125; console.log(list)&#125;function deleteElem(LinkList: any, i: number): number &#123; if (!LinkList.next) &#123; return &#125; let p: any = LinkList.next let j: number = 1 let e: number let q while (p &amp;&amp; j &lt; i - 1) &#123; p = p.next ++j &#125; if (!p || j &gt; i - 1) &#123; return &#125; q = p.next p.next = q.next // 由于js的垃圾回收机制，不需要手动释放内存 LinkList.data-- return e&#125;function getLenth(LinkList: any): number&#123; if (!LinkList.next) &#123; return 0 &#125; let p = LinkList.next let j = 0 while (p) &#123; p = p.next j++ &#125; return j // 由于我把表长存在头结点的data中，所以可以直接 return LinkList.data&#125;function test(): void &#123; var L = new LNode() createLink(L, 10) consAll(L) console.log(getIndexs(L, 5)) console.log(getElem(L, 4)) insertElem(L, 3, 999) consAll(L) deleteElem(L, 7) consAll(L) console.log(getLenth(L))&#125;test() 结语用 js 实现数据结构比 C/C++更容易，为了更加靠近，我在这里使用了一部分 typescript，最近还学习了 kmp 算法，快排，栈，图，队列，广度优先算法，狄克斯特拉算法等等，将在今后的博客一一列出。 参考资料《数据结构》 严蔚敏 （PS: 这本书。。不好）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://wingsico.github.io/tags/typescript/"}]},{"title":"npm publish发布包","slug":"npm-publish","date":"2017-10-20T16:34:43.000Z","updated":"2020-12-07T05:44:32.065Z","comments":true,"path":"2017/10/21/npm-publish/","link":"","permalink":"https://wingsico.github.io/2017/10/21/npm-publish/","excerpt":"当我们编写完成一个第三方库项目时，我们往往会将包发布供别人使用，那么该如何去发布一个 npm 包呢？","text":"当我们编写完成一个第三方库项目时，我们往往会将包发布供别人使用，那么该如何去发布一个 npm 包呢？ 方法12345cd /home/learning_nodejsnpm init # 初始化package.jsonnpm adduser # 创建一个registry.npm.org的账号...npm publish 在 search.npm.org 上可以搜索找到自己的包，可以在其他计算机中使用 1npm install &quot;包的name&quot; 若遇到 123456npm ERR! publish Failed PUT 403npm ERR! code E403npm ERR! no_perms Private mode enable, only admin can publish this module: wingsicomodulenpm ERR! A complete log of this run can be found in:npm ERR! /User/.... 原因是使用了淘宝镜像，若需要发布则需要更改为原镜像 1npm config set registry http://registry.npmjs.org","categories":[{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"},{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://wingsico.github.io/tags/npm/"}]},{"title":"前端知识梳理 —— this的深入理解","slug":"comp-this","date":"2017-10-20T10:40:04.000Z","updated":"2020-12-07T05:44:32.062Z","comments":true,"path":"2017/10/20/comp-this/","link":"","permalink":"https://wingsico.github.io/2017/10/20/comp-this/","excerpt":"勾起我有想法去写这样一个文章，一是因为我从来没有总结过 this 的用法，也经常对这个概念有些模糊；二是在学习 ES6 的时候，被一个简单的例子给弄懵了，感觉自己之前学的好像是假的？","text":"勾起我有想法去写这样一个文章，一是因为我从来没有总结过 this 的用法，也经常对这个概念有些模糊；二是在学习 ES6 的时候，被一个简单的例子给弄懵了，感觉自己之前学的好像是假的？ 例子如下： 12345678910111213var doSomething = () =&gt; &#123; console.log(this);&#125;;var obj = &#123;&#125;;doSomething(); // 很明显，打印的是Window对象var doAnother = doSomething.bind(obj);doAnother(); // WindowdoSomething.call(obj); // WindowdoSomething.apply(obj); // Window 这下我就很懵逼了，在我之前的认知中 this 是这样的： 在函数内部时，this 指向的是函数运行时所在的上下文，且通过 bind/call/apply 可以改变函数内部的 this 指向，指向其第一个参数(type =&gt; Object). 这让我很慌，于是将代码改成了这样： 12345678910111213var doSomething = function() &#123; console.log(this);&#125;;var obj = &#123;&#125;;doSomething(); // Windowvar doAnother = doSomething.bind(obj);doAnother(); // objdoSomething.call(obj); // objdoSomething.apply(obj); // obj 诶，这个时候又很正常，跟我的理解来看没有偏差，于是认定是箭头函数的关系。 于是去阮一峰看了一下箭头函数的相关描述，又参考了另外几篇博客以及一些例子之后，我觉得自己已经弄得比较明白了，关于上面那题，容我先卖个关子，这篇博客主要目的不在于解决这个问题，而更多的是为了彻底理清 this 在各种情况以及在普通函数和箭头函数之间表现的差别。所以，我们一步步从简单的开始。 理解 this什么是 this 呢？很久以前，大概刚学 js 没多久，我知道 js 不像 c/c++，他是没有指针的，但我记得有人跟我说过，this 就相当于一个指针，且这个指针是根据其所处的执行环境不同而指向不同，且this 永远指向的都是一个对象 这条性质决定了我们如何使用 this，在定义类中，也就是构造器函数中，我们通常使用this.xxx来定义公共实例变量。在使用对象的时候，我们也经常使用obj.xxx来使用其属性，从用法上来看，点操作符一般只存在于对象中，也可以从侧面再说明 this 指向的就是一个对象。我们来举个例子来说明： 123456function Person(name) &#123; this.name = name; console.log(this, typeof this);&#125;var jack = new Person(&quot;jack&quot;); // Person &#123; name: &quot;jack&quot; &#125; &quot;object&quot; 除此之外，还要理解的就是一个概念就是： 在绝大多数情况下，在普通函数内部，this 的指向由函数执行的环境决定。也就是说，this 在函数执行期间才被绑定到调用该函数时所处的上下文中，而不是声明时候所处的上下文。 可能上面这句话还不是特别好理解，那么我来举几个例子： 12345678910function fn() &#123; console.log(this);&#125;function wtf() &#123; fn();&#125;fn(); // Windowwtf(); // Window 可能有人又会有疑问了： 直接调用 fn()很容易理解，因为调用 fn 所处的上下文为 Window 对象，所以打印 Window，但是调用 wtf 时，fn 明明在 wtf 的内部调用的啊，为什么不指向 wtf 呢？ 这很容易理解，我们来把上述函数更改一下 123456function wtf() &#123; console.log(this === window); // true console.log(window.fn === fn); // true window.fn(); // Window fn(); // Window&#125; 这下就很清晰易懂了，在 wtf 函数内部调用 fn()，他的实际执行上下文仍然为 Window 对象。 我们再来看一个例子: 12345678910111213141516171819// 作为普通函数调用时,this必须指向一个对象。那就是全局对象（在浏览器内是Window对象）。var getA = function() &#123; console.log(this.a);&#125;;window.a = 1;getA(); // a// 作为对象属性调用时，this指向的就是该对象var obj = &#123; a: 2, getA: function() &#123; console.log(this.a); &#125;&#125;;obj.getA(); // 2var getOtherA = obj.getA; // 这里将 function() &#123; console.log(this.a) &#125; 赋给了getOtherA，但它的执行环境仍是全局环境中，其this指向WindowgetOtherA(); // 1 根据以上的例子我们可以总结出：在普通函数内部，this 总是指向其执行环境上下文中，即要关注该函数的直接调用位置，再换种说法，即关注函数是如何调用的 那么，我们都有哪些调用方法呢？ 一、函数调用 来看一个简单的例子介绍函数调用： 123456function hello(name) &#123; return &quot;Hello &quot; + name;&#125;var message = hello(&quot;world&quot;);console.log(message); // &quot;hello world&quot; 这样一个函数名加上一个左开括号加上一个逗号分隔的参数表达式再加上一个右开括号，就会执行该函数对象的函数调用。 还有一个高级的是 IIFE，立即调用的函数表达式 1234var message = (function(name) &#123; return &#x27;hello &#x27; + name&#125;)(&#x27;world)console.log(message) // &quot;hello world&quot; IIFE 也是一个函数调用：第一对括号(function(name) {…})是一个表达式，它计算为一个函数对象，后跟一对带括号的’world’参数：(‘world’)。 理解了函数调用，我们再来看一下 this 在函数调用中的指向情况： 12345678function test() &#123; console.log(this === window); this.number = 20; var number = 30;&#125;test();console.log(window.number); // 20 这里的 test()为 js 的函数调用，在执行期间，js 将函数内部的 this 绑定到了全局对象上，即 window 所以我们可以用一句话总结：this 在函数直接调用中总指向全局对象，全局对象是由执行环境决定的，在浏览器里，他是 window 对象 再举个例子，更深的理解这句话： 123456789101112131415var obj = &#123; name: &quot;jack&quot;, action: &quot;hello&quot;, doIt: function() &#123; console.log(this === obj); function strConcat() &#123; console.log(this === obj); return this.action + &quot; &quot; + this.action; &#125; return strConcat(); &#125;&#125;;var msg = obj.doIt(); // true, falseconsole.log(msg); // &quot;hello jack&quot; 调用 obj.doIt 时，由于他是方法调用（在后面会说），显然 doIt 函数的上下文是 obj 对象，strConcat 函数是 doIt 里面定义的，你可能会想它和 doIt 一样，this 也指向 obj。 其实不然，我们在看我们的那句话，函数调用的 this 指向全局对象，而在这里就是 window，即使外部函数 doIt 有着 obj 作为函数对象，在这里也不会影响 strConcat 中 this 的指向。 函数调用的常见陷阱 this 是被认为在内部函数中与外部函数相同。正确的应该是内部函数的上下文仅依赖于调用，而不依赖于外部函数的上下文。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"this","slug":"this","permalink":"https://wingsico.github.io/tags/this/"}]},{"title":"在命令行中用vscode打开文件","slug":"vscode","date":"2017-10-15T02:49:20.000Z","updated":"2020-12-07T05:44:32.071Z","comments":true,"path":"2017/10/15/vscode/","link":"","permalink":"https://wingsico.github.io/2017/10/15/vscode/","excerpt":"基于 zsh 方便地使用 vscode 打开文件","text":"基于 zsh 方便地使用 vscode 打开文件 只需要在~/.zshrc 中添加一行 1234code () &#123; VSCODE_CWD=&quot;$PWD&quot; open -n -b &quot;com.microsoft.VSCode&quot; --args $* ;&#125; 之后只需要在终端输入 code 即可打开 vscode，输入 code path/to/文件名 就可以使用 vscode 来打开相应的文件。","categories":[{"name":"专治懒癌","slug":"专治懒癌","permalink":"https://wingsico.github.io/categories/%E4%B8%93%E6%B2%BB%E6%87%92%E7%99%8C/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"}]},{"title":"wordpress + nginx 修改固定链接","slug":"url-rewrite","date":"2017-10-14T03:18:52.000Z","updated":"2020-12-07T05:44:32.071Z","comments":true,"path":"2017/10/14/url-rewrite/","link":"","permalink":"https://wingsico.github.io/2017/10/14/url-rewrite/","excerpt":"wordpress 固定链接一直都很想改，因为默认的参数格式实在是太丑了。 一开始以为只要更改 wordpress 仪表盘里的固定链接格式，改好格式后点开文章后，？？？404 nginx？？？于是对 wordpress 这个设置一直觉得他是不是出 bug 了（=。=），于是开始在各大搜索引擎上查找。","text":"wordpress 固定链接一直都很想改，因为默认的参数格式实在是太丑了。 一开始以为只要更改 wordpress 仪表盘里的固定链接格式，改好格式后点开文章后，？？？404 nginx？？？于是对 wordpress 这个设置一直觉得他是不是出 bug 了（=。=），于是开始在各大搜索引擎上查找。 原来光 wordpress 里设置是不够的，这个是需要服务器设置 URL rewrite 的。但是 Apache 和 Nginx 之间配置是有一定的差别的，这里只贴出 Apache 的配置方法，就不详细介绍了： Apache 环境下开启 url_rewrite： 开启 apache 的 url_rewrite 模块，也就是在 httpd.conf 中去掉这句话的注释 LoadModule rewrite_module modules/mod_rewrite.so 找到 AllowOverride，把 AllowOverride None 修改成 AllowOverride all 在所需要进行 rewrite 的 web 的主目录下添加.htaccess 文件，添加上一句话：RewriteEngine on 由于我的服务器是由 nginx 来部署的，所以接下来来说说如何在 nginx 中配置 url_rewrite。 Nginx 环境下开启 url_rewrite：打开 wordpress 仪表盘 —&gt; 设置 —&gt; 固定链接，在他的最下面有一个链接，即指向 nginx 配置文档，但是其中的内容对于不熟悉 nginx 的我来说太乱太杂，所以它并没有解决我的问题（可能我太蠢了。。），在自己搜索一番，在服务器配置里翻来翻去（并没有改=。=）之后，还是没有头绪如何去解决，这时候只好请出大佬田花花。 大佬思考了一会，告诉我有三个选择： 服务器换 Apache 装 docker 更改 nginx 配置 一开始说换 Apache，说 php 的后台和 Apache 配合使用比较好一些，但不知道是步骤有些麻烦还是怎么的，并没有选择这个。于是选择了装 docker，据大佬所说，使用 docker 的话修改这个十分的简单，于是开始了装 docker 之旅。 docker首先打开了 github，搜索进入了 docker/compose，应该是一个配合 docker 使用的一个插件？安装好了之后，开始安装 docker。打开 docker 的官网: www.docker.com，找到 centos 安装 docker（一开始还以为自己是 ubuntu），输入命令之后，等待一会会就出现了错误，安装失败，于是大佬觉得可能是 yum 的版本太低了，使用 1sudo yum upgrade 更新了一下 yum，更新完成之后再次安装，结果还是失败，于是查看了一下 centOs 的版本 12cat /etc/system-releaseCentOS release 6.9 (Final) 额。。gg，这个版本是用不了 docker 的。那样的话，也就只能使用第三个选择。 nginx这里我不是特别清楚原理，先直接上如何进行操作吧： 12cd /etc/nginx/conf.d/nano default.d 于是出现如下配置内容: 12345678910111213141516171819202122232425262728293031323334353637server &#123; listen 80; root /usr/share/nginx/html; client_max_body_size 1024M; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / &#123; index index.php index.html index.htm; &#125; #error_page 404 /404.html; #redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; #pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ php.$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 在 location / &#123;&#125; 内添加 123if (!-e $request_filename)&#123; rewrite ^/(.*)$ /index.php/$1 last; &#125; 把 123456location ~ php.$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 改成 123456789location ~ ^.+.php &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; fastcgi_split_path_info ^((?U).+.php)(/?.+)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;&#125; 保存，重启 nginx： 1nginx -s reload 大功告成！刷新博客，很成功～感谢田花花大佬的帮助。","categories":[{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://wingsico.github.io/tags/nginx/"},{"name":"wordpress","slug":"wordpress","permalink":"https://wingsico.github.io/tags/wordpress/"}]},{"title":"前端知识梳理（六）—— iframe","slug":"comb-iframe","date":"2017-10-13T10:39:39.000Z","updated":"2020-12-07T05:44:32.062Z","comments":true,"path":"2017/10/13/comb-iframe/","link":"","permalink":"https://wingsico.github.io/2017/10/13/comb-iframe/","excerpt":"","text":"以前一直觉得这个 iframe 标签特别神秘，因为之前在解决设置 title 时使用document.title = &quot;xxx&quot;在 ios 上的微信端失效，就是使用了一段关于 iframe 的 js 代码完成的，应该是可以称为一种 iframe hack 吧～，代码如下： 123456789101112131415setTimeout(function() &#123; //利用iframe的onload事件刷新页面 document.title = &quot;test&quot;; var iframe = document.createElement(&quot;iframe&quot;); iframe.style.visibility = &quot;hidden&quot;; iframe.style.width = &quot;1px&quot;; iframe.style.height = &quot;1px&quot;; iframe.src = &quot;./favicon&quot;; // 这里是必须的 iframe.onload = function() &#123; setTimeout(function() &#123; document.body.removeChild(iframe); &#125;, 0); &#125;; document.body.appendChild(iframe);&#125;, 0); 不过据考证资料，该 iframe hack 对最新内核已经失效，不过并不影响我学习 iframe，毕竟我现在还没有在做微信，等以后再踩踩这些坑好了。 iframe——内联框架引用一段 www.thoughtco.com 中的一段原文，描述了 iframe。 Inline frames, commonly just referred to as “iframes”, are the only type of frame allowed in HTML5. These frames are essentially a section of your page that you “cut out”. In the space that you have cut out of the page, you can then feed in an external webpage. In essence, an iframe is another browser window set right inside your web page. You see iframes commonly used on websites that need to include external content like a Google map or a video from YouTube. Both of those popular websites use iframes in their embed code. 翻译过来用我的话来说就是：iframe 是一个 HTML5 的框架元素，它允许你在一个网页内引入另一个浏览器窗口（仅作展示和使用)，相当于在一个浏览器窗口内切出了另一个窗口去展现外部网站的内容，比如，在博客内引用 codepen 中的在线代码效果演示，就是使用的 iframe，还有一些视频、音乐和地图之类的的引入也会使用 iframe，总之，iframe 在各大网站均有被使用。 iframe 在 HTML4.01 和 HTML5 中均可使用，其共有四个基本属性： src = &quot;url&quot;: 指定一条 url，表示该框架所指向的外部页面的链接，比如说： 1&lt;iframe src=&quot;http://www.baidu.com&quot;&gt;您的浏览器不支持iframe&lt;/iframe&gt; 这是一个指向百度首页的 iframe width = &quot;&quot; / height = &quot;&quot;: 设置 iframe 的宽高，单位为 px，举个例子： 123&lt;iframe src=&quot;http://www.baidu.com&quot; width=&quot;400&quot; height=&quot;400&quot; &gt;您的浏览器不支持iframe&lt;/iframe&gt; name = &quot;&quot;: 设置 iframe 的名称。 有三种用法： 作为 javascript 的引用元素 1234567891011&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;iframe_a&quot; &gt;您的浏览器不支持iframe&lt;/iframe&gt;&lt;script&gt; var iframe_a = document.getElementsByName(&quot;iframe_a&quot;)[0]; // 同等于 var iframe_a = window.frames[&quot;iframe_a&quot;]; var iWindow = iframe_a.contentWindow; // 拿到iframe_a的window对象 var idoc = iWindow.document; // 获取iframe的document&lt;/script&gt; 作为 a 标签和 form 标签的 target 属性的值 12345&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;iframe_a&quot; &gt;您的浏览器不支持iframe&lt;/iframe&gt;&lt;a href=&quot;https://www.ncuos.com&quot; target=&quot;iframe_a&quot;&gt;将iframe指向云家园&lt;/a&gt; 3. 作为 input 和 button 的 formtarget 的值 12345&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;iframe_a&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;您的浏览器不支持iframe&lt;/iframe&gt;&lt;form action=&quot;form_action.asp&quot; method=&quot;get&quot;&gt; &lt;button type=&quot;submit&quot; formtarget=&quot;iframe_a&quot;&gt;提交数据1&lt;/button&gt; &lt;input type=&quot;submit&quot; formtarget=&quot;iframe_a&quot;&gt;提交数据2&lt;/button&gt;&lt;/form&gt; 点击这两个按钮不会有任何反应，因为 formtarget 的作用就是： **Specifies where to display the response that is received after submitting the form (for type=&quot;submit&quot; and type=&quot;image&quot;)** 翻译过来的意思就是 formtarget 将请求后得到的 response 在 formtarget 的值中展现出来，在这里即是在 iframe 中展示出来。 在新增的 HTML5 中，iframe 又多了 3 个新属性，分别是sandbox,seamless,srcdoc. sandbox首先，先说一下 sandbox 属性，sandbox &lt;=&gt; 沙箱，相信用过杀毒软件的人应该知道，360 就有一个隔离沙箱，所以这个属性就是为了安全性考虑而设计的，用作隔离 iframe 和当前页面。 这个是来自菜鸟教程的一个介绍： 如果指定了空字符串（sandbox=””），该属性对呈现在 iframe 框架中的内容启用一些额外的限制条件。 sandbox 属性的值既可以是一个空字符串（将会启用所有的限制），也可以是用空格分隔的一系列指定的字符串。 HTML 5 通过 sandbox 属性提升 iFrame 的安全性。sandbox 属性可以防止不信任的 Web 页面执行某些操作。 具体用法如下： 1&lt;iframe src=&quot;https://www.baidu.com&quot; sandbox=&quot;value&quot;&gt;沙盒隔离&lt;/iframe&gt; 既然称之为沙盒，那他可以做些什么来提高安全性呢？ 将内容视为来自独特来源 不能发送 ajax 请求 阻止脚本执行 禁用 API（不能使用本地存储等） 阻止链接定位到其他浏览上下文 防止内容使用插件（通过&lt;embed&gt;，&lt;object&gt;，&lt;applet&gt;或其他） 阻止内容导航其顶层浏览上下文 阻止自动触发功能（如自动播放视频或自动对焦表单控件 不能发送表单 具体如何限制 iframe 的操作呢？ 首先，sandbox 的值可以多值组合使用，如同 class 属性一样可以填写许多类名。其次，它的单值共有 7 个： “” (no-value) allow-same-origin allow-top-navigation allow-pointer-lock allow-popups allow-scripts allow-forms 当为空值的时候，即sandbox=&quot;&quot; 或 sandbox 时，所有的限制都将启用； 当为allow-same-origin时，该嵌入的内容将会被当做同源来看待，当使用此属性时，适用于两种情况： 若同一站点的内容被沙盒禁用脚本，但通过设置该值可以允许 Iframe 访问沙盒内容的 DOM 当嵌入的是一个第三方的站点，它可以阻止该站点打开弹窗，弹出广告等等，但不阻止该嵌入的页面回到其原始站点，或使用数据库 API 存储数据等等 当为allow-top-navigation时，允许该嵌入的内容导航到其顶层浏览的上下文处，这是什么意思呢？即是允许 iframe 主导 window.top 进行页面跳转，还不明白？何为 window.top，就是顶层窗口，即是浏览器窗口，就是说 iframe 可以控制浏览器跳转至其他页面，也就是父级（顶级）页面被重定向至其他网页。大概就是这个么意思，还不明白我也木有办法了=。= 当含有allow-pointer-lock时，可以在 iframe 中锁定鼠标 当含有allow-popus时，允许 iframe 中弹出新窗口，比如 window.open.target=&quot;_blank&quot; 当含有allow-scripts时，允许 iframe 执行脚本 当含有allow-forms时，允许提交表单的操作 当然，直接使用一个 sandbox 的空值的很少的情况，我们经常使用如下代码来开放一些特定的权限： 123&lt;iframe sandbox=&quot;allow-scripts allow-same-origin allow-scripts&quot; src=&quot;...&quot; &gt;您的游览器不支持iframe。&lt;/iframe&gt; srcdocsrcdoc 属性制定要在 iframe 内显示的页面的 HTML 内容 举个栗子： 12345678&lt;iframe src=&quot;https://www.baidu.com&quot; width=&quot;200&quot; height=&quot;200&quot; sandbox=&quot;allow-scripts allow-forms allow-same-origin&quot; srcdoc=&quot;&lt;p&gt;hello,srcdoc!&lt;/p&gt;&quot; &gt;您的浏览器不支持iframe&lt;/iframe&gt; seamlessseamless 属性属于逻辑属性。当设置了该属性后，它规定了 iframe 看上去像是包含文档的一部分（无边框或无滚动条) 举个栗子： 123456789101112131415&lt;iframe src=&quot;https://www.baidu.com&quot; width=&quot;200&quot; height=&quot;200&quot; sandbox=&quot;allow-scripts allow-forms allow-same-origin&quot; &gt;您的浏览器不支持iframe&lt;/iframe&gt;&lt;iframe src=&quot;https://www.baidu.com&quot; width=&quot;200&quot; height=&quot;200&quot; sandbox=&quot;allow-scripts allow-forms allow-same-origin&quot; seamless &gt;您的浏览器不支持iframe&lt;/iframe&gt; 效果如下: 您的浏览器不支持 iframe 您的浏览器不支持 iframe ！看起来没有效果，不对啊，Chrome 浏览器不是支持该属性吗！不是很理解这个属性，标记一下！ 内容略多，待跟进，由于 iframe 使用方面略少，以及还有一些安全性的问题的深究，暂且对我目前学习意义不大，待有时间可以学习一下 iframe 跨域以及轮询（感觉 iframe 真是一个很牛掰的东西），有时间再补充吧。 参考资料 https://www.w3.org/TR/2010/WD-html5-20100624/the-iframe-element.html#attr-iframe-sandbox https://segmentfault.com/a/1190000004502619 http://www.w3school.com.cn/tags/tag_iframe.asp https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"},{"name":"iframe","slug":"iframe","permalink":"https://wingsico.github.io/tags/iframe/"}]},{"title":"前端知识梳理（五）—— 语义化的深入剖析","slug":"comb-semanticization","date":"2017-10-11T05:12:07.000Z","updated":"2020-12-07T05:44:32.062Z","comments":true,"path":"2017/10/11/comb-semanticization/","link":"","permalink":"https://wingsico.github.io/2017/10/11/comb-semanticization/","excerpt":"最近代码写的较少了，于是回顾了一下自己以前的代码，看了一看自己第一次写的网页——百度首页，许多标签混用，无意义的 div 标签嵌套，img 无 alt 属性，class 命名（拼音首字母）之类的，极其缺失语义化以及结构化。","text":"最近代码写的较少了，于是回顾了一下自己以前的代码，看了一看自己第一次写的网页——百度首页，许多标签混用，无意义的 div 标签嵌套，img 无 alt 属性，class 命名（拼音首字母）之类的，极其缺失语义化以及结构化。 自己步入前端也有一年了，自己在写代码的时候也总是有意无意的使用 div 标签，甚至心里有一种这样的想法： 标题干嘛要用 h1~h6 啊，我并不想要标题加粗，直接用 p 吧，还省事，不要去设置 css。什么 header、footer 完全没必要啊，又没有加任何特殊的样式。 在之后了解过一些 html 语义化之后才知道之前的这些想法有多么肤浅和愚蠢，但在之前的认知中中，对于语义化的认识也仅仅是这样： 语义化就是为了让标签做他该做的事情，使结构更加清晰，方便代码的阅读和维护。 但在经过一下午的学习过程中，我发现语义化并没有那么的简单。 HTML 语义化历史我们先来说说 HTML 吧，HTML 一般被我们称之为网页，是与网络相关在一起的，当下时代网络是以 World Wide Web （Web， 万维网）为主导的，我们通过一串 URL 来定位到资源，通过特定的协议来访问以获取我们所需要的资源。这样的资源均是(?)通过 HTML 来展示的，所以 HTML 最初的目的就是为了发布 web 的资源内容以及方便人们进行索引。 目前，HTML 主要用来： 发布文档（文本，表格，列表…） 通过超链接获取信息 建立用来访问远程服务的表单 发布 web 应用 但慢慢的随着 Web 规模不断的扩大，信息量之大已经不在人工处理的范围之内了，搜索引擎就应景而生，人们又设计了各种程序来对结构良好，索引好的内容进行处理和挖掘。这时候，为了能让机器更好的读懂 web 上的各种内容，语义化就显得越来越重要了。 最初的 HTML 是有一定的语义化的，比如说 h1~h6 是代指标题，img 表示图片，table 表示表格，p 表示段落等等，但这些更多的只是为了让 UA（User Agent）对这些元素进行更好的处理，并没有明确语义化的重要性，由于现在许多内容是为了网页的可视化设计的，机器对于这些是很难与有用的信息区分开来的，于是现在就提出了两种途径来解决这个问题： 提高技术，让机器越来越能够像人类思考，读懂人能够看懂，读懂的东西。 推广规范，让在编码之初就以一种能让机器读懂的方式来进行编码，即使用被广泛认可的语义信息来描述内容。（很显然，XML 和 HTML5 就是往这个方向上进发） 第一条途径就是横轴，把 AI 的水平提升到人类的水平，第二条途径是纵轴，朝着语义化的方向前进，也就是万维网创始人 Tim Berners-Lee 爵士提出的美好愿景：语义网。 语义网：简单来说就是让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读。 两条路都很艰难，但实际上我们正在以第二条途径进行努力，这也是 HTML5 出现的原因之一，删除了一些纯表现的标签，以及为一些标签丰富了语义，还有增加了许多富有语义的新标签。其实不仅是标签，同样的，许多属性，如 rel，如 role 等等都是为了更好的去促成语义化的实现。 同时，HTML5 并不是语义化规范的唯一依仗，除了 W3C 和 WHATWG 外，还有其他组织在为 web 语义化、标准化作出努力。 例如 microformats 社区以及 http://Schema.org 上都有对 HTML 以及 Microdata（http://www.w3.org/TR/html5/microdata.html） 规范的扩展词汇表，Google、Bing、Yahoo! 等搜索引擎以及各个主流浏览器都不同程度地接纳了其中定义的语义扩展，并应用在了生产中。 作者：顾轶灵 链接：https://www.zhihu.com/question/20455165/answer/15176745 来源：知乎 这些都是语义化的一些背景，那么我们可以从哪些方面来更好的语义化呢？ 更好的语义化 尽量避免无意义的 div 嵌套 123456789&lt;div&gt; &lt;!-- not good --&gt; &lt;div&gt; &lt;p&gt;一段描述性的文字&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;p&gt;一段描述性的文字&lt;/p&gt;&lt;!-- good --&gt; 每一个标签做他该做的事情 123456789101112&lt;style&gt; .head-title &#123; font-weight: bold; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;head-title&quot;&gt;一个标题&lt;/div&gt; &lt;!-- not good --&gt;&lt;/body&gt;&lt;h2 class=&quot;head-title&quot;&gt;一个标题&lt;/h2&gt;&lt;!-- good --&gt; 使用更加有语义化的标签 12345&lt;p&gt;&lt;b&gt;Warning!&lt;/b&gt;There is a meeting...&lt;/p&gt;&lt;!-- not good --&gt;&lt;p&gt;&lt;strong&gt;Warning!&lt;/strong&gt;There is a meeting...&lt;/p&gt;&lt;!-- good --&gt; 清晰的了解每一个标签所代表的具体语义，不随意使用标签 更加清晰的 class，id 命名 关于这一点，这里有个链接，专门说的是 class 的类名在语义化上的使用：http://www.oschina.net/translate/about-html-semantics-front-end-architecture 我自己的理解大概就是： 每一个类名都要有目的，有意义，不取无意义的类名，类名与内容解耦，往往大多数可重用的组件它的类名与内容是没有太大关联的，同时，我们应多使用“多类”模式，使它更有收缩性，以及可维护性，而不是把所有的样式堆积在一个类名上。 总结经过一番学习，我对语义化有了更深层的认识： 语义化在目前来说更多的是为了让机器能读懂网页的内容，使 HTML 更加结构化、规范化，便于搜索引擎的爬虫的抓取，爬虫依赖标记来获取上下文以及关键字的权重，利于 SEO；同时代码更加容易维护，方便他人阅读；在 CSS 加载失败后扔能保持一定的良好的结构，不会造成页面内容缺失等等。 由于现在已经步入 HTML5 的时代，了解新增以及改变的元素的语义显得十分重要，我查阅资料后找到一篇，对每一个语义化的元素都讲述的比较清楚，同时还介绍了目前在语义化比较火的微数据(micro data)，写的很好，这里我就不一一列举语义元素了。 参考资料 https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/semantic-html.html 前端工程师开发手册 https://www.zhihu.com/question/20455165 如何理解 Web 语义化 http://justineo.github.io/slideshows/semantic-html/#/ Semantic HTML","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"},{"name":"语义化","slug":"语义化","permalink":"https://wingsico.github.io/tags/%E8%AF%AD%E4%B9%89%E5%8C%96/"}]},{"title":"前端知识梳理（四）—— DOCTYPE 深入剖析","slug":"comb-doctype","date":"2017-10-09T14:25:50.000Z","updated":"2020-12-07T05:44:32.061Z","comments":true,"path":"2017/10/09/comb-doctype/","link":"","permalink":"https://wingsico.github.io/2017/10/09/comb-doctype/","excerpt":"之前写代码的时候，编辑器曾报了一个很诡异的错误，不知道为什么，总是有各种红色的波浪线遍布代码，那时候一头雾水，完全不知道发生了什么。","text":"之前写代码的时候，编辑器曾报了一个很诡异的错误，不知道为什么，总是有各种红色的波浪线遍布代码，那时候一头雾水，完全不知道发生了什么。 经过一番查找，发现把 &lt;!DOCTYPE html&gt;加上后就正常了，当时也没有细想，反正 bug 解决了（=。=）现在回过头来，觉得需要弄懂这个东西。 那么问题来了，何为 doctype ？在我们搞懂这个之前，我们需要先来了解一下 DTD DTDDTD（ Document Type Definition）意思是文档类型声明或者文档类型定义，诶这都是英译过来的，无关紧要。但说到 DTD，又得延伸一个概念叫做 SGML. SGMLSGML(Standard Generalized Markup Language，SGML），翻译过来是标准通用标记语言，引用来自维基百科的概述： 标准通用标记语言（Standard Generalized Markup Language，SGML）是现时常用的超文本格式的最高层次标准，是可以定义标记语言的元语言，甚至可以定义不必采用&lt; &gt;的常规方式。由于它的复杂，因而难以普及。 虽然 SGML 在翻译上翻译过来是一种语言，但根据我查阅相关资料以及思考觉得，SGML 更像是一个规范或者称为标准。 在之后的翻阅中，又看到了之前忽略的在维基百科上的一句话： 同时它（SGML）也是一个 ISO 标准：”ISO 8879:1986 Information processing – Text and office systems – Standard Generalized Markup Language (SGML)” 至于 ISO 是什么，这里直接引用一段ISO 官网的介绍： ISO is an independent, non-governmental international organization with a membership of 162 national standards bodies. Through its members, it brings together experts to share knowledge and develop voluntary, consensus-based, market relevant International Standards that support innovation and provide solutions to global challenges. 大概意思就是说明 ISO 是一个独立的非政府国际组织，拥有 162 个 国家标准机构。通过其成员汇集专家，分享知识，制定自愿的，基于共识的市场相关的国际标准，支持创新并为全球挑战提供解决方案。说白了就是一个制定标准的一个组织，其制定的标准一般拥有一个编号，像 SGML 就是 ISO 8879。 ISO 不是我们这里介绍的重点，暂且跳过他，继续阐明 SGML 为何物。 下面看一个 SGML 的一个具体的例子： 123&lt;QUOTE TYPE=&quot;example&quot;&gt;typically something like &lt;ITALICS&gt;this&lt;/ITALICS&gt;&lt;/QUOTE&gt; 其实从上面引用的那张图片也可以看出来一些端详。它的结构一般由以下四个部分组成： SGML 声明，设定基本情况； 定义 DTD 文档类型，设定标记语言结构的语法； 描述用于标记的语义规格说明，做出了 DTD 表达的语法限制； 包含数据和标记的文档实例。 像 HTML 的前身就是 SGML，你会发现 HTML 的结构与 SGML 十分相似，SGML 可以规范如何开始一个元素以及元素如何结束（或者称之为闭合），这是 SGML 的一种结构化的特点，至于其他的我就不一一举例，太繁琐，我这里直接给出它的特点的总结： 正式的，能允许验证文档的正确性； 结构化的，能够处理复杂的文档； 可扩充的，能够支持大型信息存储的管理。 像它的可扩充的特点，我们延伸出了 HTML（超文本标记语言），XML （扩展标记语言）。他们其实都是基于 SGML 标准的。 关于 XML，可以这样说： 一方面，虽然 XML 源于 SGML，但它并不是 SGML 的替代物，XML 省去了 SGML 的许多功能，但 XML 可以和 SGML 兼容，使用 SGML 的人可以直接使用 XML 在网络上交换数据，而不必转换已有的 SGML 文档；另一方面，XML 和 HTML 是互相补充的，HTML 关于用户的界面，XML 关于数据链路，动态的 HTML 描述显示界面和用户交互活动，XML 描述信息，所以两者结合，XML 可以向 HTML 文档增加信息，而 HTML 可以显示以 XML 格式表达的信息。一般认为，XML 的目标就是：能在 INTERNET 上直接使用；与 SGML 兼容；支持大范围的应用；XML 文档易于创建、清晰易读、设计简单明了；易于编写处理 XML 文档的软件。XML 立志于在 WEB 内建立真实世界的知识影像，针对 HTML 和 INTERNET 的标准、可扩展、通用的数据格式，灵活地表示各种各样、自我描述的信息。XML 可以向 INTERNET 的数据增加结构，这有助于在 WEB 上实现任何人、任何地方的任何事物的通信。 现在，我们有了 SGML，DTD，XML，HTML 四个（语言？）的一个定义与理解，需要把他们联系在一起了。 。。。联系个毛线，我都不懂自己在写啥玩意了。 一句话解释吧： HTML/XML 的 DOCTYPE 声明引用 DTD，DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容，DTD 概念缘于 SGML，每一份 SGML 文件，均应有相对应的 DTD，SGML 是标记语言的元语言。 在前端日常使用 DOCTYPE 中，目前来说只需要注意标注&lt;!DOCTYPE&gt;即可，这是最新的 HTML5 的 DOCTYPE 规范标准的写法，不会有任何问题（？），由于 HTML4.01 的时代即将过去，关于 HTML4.01 的一些常用的 DOCTYPE 声明我也不一一列举，在下面给出资料链接吧，整篇博客到此结束，我或许一辈子都用不上这 SGML 这玩意，及时打住，好像才是最好的选择。 参考资料 http://www.w3school.com.cn/tags/tag_doctype.asp HTML &lt;!DOCTYPE&gt; 标签 - w3c https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89 维基百科 DTD https://www.iso.org/about-us.html ISO 介绍 http://tech.163.com/04/1103/21/149VOTK30009rt.html 《HTML 的兄弟姐妹们》 https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80/10471466?fromtitle=SGML&amp;fromid=2901416 百度百科 - SGML https://www.w3.org/TR/WD-html40-970708/intro/sgmltut.html 《A brief SGML tutorial》","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"}]},{"title":"Chrome + shadowsocks + SwitchyOmega = 科学上网？","slug":"shadowsocks","date":"2017-10-08T08:56:39.000Z","updated":"2020-12-07T05:44:32.066Z","comments":true,"path":"2017/10/08/shadowsocks/","link":"","permalink":"https://wingsico.github.io/2017/10/08/shadowsocks/","excerpt":"最近不在机房，不能享受自动翻墙的”快感”了，呼幸好手里还有一个 ss 账号，那直接给 ubuntu 来一套科学上网的正确姿势吧～","text":"最近不在机房，不能享受自动翻墙的”快感”了，呼幸好手里还有一个 ss 账号，那直接给 ubuntu 来一套科学上网的正确姿势吧～ 科学上网科学上网一词我是听别人说+看到一本书《程序员的自我修养》里面的一章节，里面介绍了什么是墙，如何翻墙，以及 vpn 相关概念。根据我所了解的来说，科学上网的方式共有两种——VPN &amp; Shadowsocks。那么这两个有什么区别呢？ VPN 在公用网络上建立专用网络，进行加密通讯。原理是在一个国外网络无阻的机器上与本地机器通信。 优点是方便设置，网络速度稳定。 缺点是稳定的服务价格不便宜，且本地流量全部走的是代理。 一看到连本地流量走的都是代理，震惊了，本来价格都是按照流量来算的，如果连国内网站都走代理的话，那不是亏成翔。还好目前有解决办法。 配合 VPN 实现国内外分流访问 “分流”，这个词不知道说的准不准确，意思就是实现对不需要翻墙的网站直接连接，需要翻墙的网站走 VPN 代理。这样国内的网站访问不受影响，又能正常访问国外站点。 实现方式就是修改系统的路由表，网络上有这样的开源项目，专门收集国内被“墙”的网站。利用这些数据，让 vpn 客户端在进行连接的时候自动执行. 通过这些路由脚本, 可以让用户在使用 vpn 作为默认网络网关的时候, 不使用 vpn 进行对中国国内 ip 的访问, 从而减轻 vpn 的负担, 和增加访问国内网站的速度. 关于各个系统实现的方式我就不在这里赘述，详情请看这里 科学上网 Shadowsocks这是另一种科学上网的姿势，我选择他！因为 vpn 的缺点他都没有～这也是我接下来要讲的，如标题一般，那么我们就以 shadowsocks 开始吧。 步骤首先，我们需要下载安装 Shadowsocks，在 linux Ubuntu16.04 中，我们使用 pip 安装。 安装 pip 1apt-get install python-pip 安装 shadowsocks 1pip install shadowsocks 使用这里介绍两种使用方法，但推荐第二种方法。 1.无配置文件，一行命令搞定 1sslocal -s server_ip -p server_port -l 1080 -k password -t 600 -m aes-256-cfb server_ip 请替换成对应的服务 ip， server_port 替换成对应的服务端口号， -l 是本地端口（默认 1080）， -k 后面填写密码（password）需要加双引号(“”) 如密码是 123456，则应写成 -k &quot;123456&quot; ， -t 是默认超时时间， -m 是加密方法，这个会由服务端给出，默认值为 aes-256-cfb。 可以简单的写为： 1sslocal -s ip -p port -k &quot;password&quot; 只使用-s -p -k 这三个参数，其他的使用默认值（注意要与服务端匹配才能省略） 缺点：每次输入命令都要手动填写相关信息，比较麻烦。所以我推荐第二种。 2.添加配置文件，更加简短的命令。 1sslocal -c path/to/ss.json 怎么样，是不是更加简短了呢？这里，我们将使用到一个配置文件，这个是由我们自己来创建，不知道放在哪里好，我自己就放在/home 目录下。 方法：选择一个目录，创建一个 json 格式的文件，名字自己定义，打开后，如下填入 ss 的相关信息. 12345678910&#123; &quot;server&quot;: &quot;server_ip&quot;, &quot;server_port&quot;: server_port, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: 1080, &quot;password&quot;: &quot;password&quot;, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 注意：上面打了双引号的在实际使用的时候也需要双引号。保存之后，在命令行里使用上面那条命令就可以启动 ss 了。 这样就行了吗？还不行呢，使用 Shadowsocks 我们还需要设置一下浏览器端的代理设置。这里仅介绍 chrome 浏览器下的方法。 SwitchyOmega这个是 Chrome 的一个插件，非常好用。之前一直在搜索如何下载 SwitchyOmega ，我靠竟然还有叫人去谷歌商店下载的。。我还没翻墙呢怎么去谷歌商店，坑爹呢这是。想想这么好的东西可能开源了吧，于是就到 github 上去找找，嘿;-)果然被我找到了，放一下下载地址～ https://github.com/FelisCatus/SwitchyOmega/releases/ 下载好了之后打开谷歌浏览器，输入chrome://extensions，将刚刚下载好的拖入就可以安装了。那么安装好了如何使用呢？ 使用 SwitchyOmega废话少说，直接上操作： 新建情景模式 填写名称（自定义），选择第一个代理服务器，点击创建 进入刚创建的情景模式，将代理协议选择至 SOCKS5，代理服务器处填写：127.0.0.1，代理端口填写 1080 保存，并在浏览器右上角选择到刚刚创建的情景模式。 OK，这时候你就会发现谷歌能上了，youtube 能看了，世界突然变美好了（滑稽）","categories":[{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"},{"name":"专治懒癌","slug":"专治懒癌","permalink":"https://wingsico.github.io/categories/%E4%B8%93%E6%B2%BB%E6%87%92%E7%99%8C/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"},{"name":"vpn","slug":"vpn","permalink":"https://wingsico.github.io/tags/vpn/"}]},{"title":"前端知识梳理（三）—— lang","slug":"comb-lang","date":"2017-09-29T14:08:40.000Z","updated":"2020-12-07T05:44:32.062Z","comments":true,"path":"2017/09/29/comb-lang/","link":"","permalink":"https://wingsico.github.io/2017/09/29/comb-lang/","excerpt":"","text":"对 html 中 lang 属性做简单的梳理 lang 是什么lang 是元素的一个属性，它相当于 language（语言）的意思。 lang 有什么用lang 属性规定元素内容的语言。比如谷歌浏览器根据你的代码&lt;html lang=&quot;en&quot;&gt;就会知道你的网页是英文的，就会问你是否需要翻译成中文。 总之，lang 是给搜素引擎使用的，并不影响页面内容，因此设置了&lt;html lang=&quot;en&quot;&gt;你的页面还是能够显示各种语言，但是我们仍应该遵守标准，毕竟这个属性对浏览器和搜索引擎还是有作用的。 为什么要设计 lang 属性引用于另一篇博客： 设计 lang 属性是为了向用户提供语言特有的显示，尽管它对主要的浏览器具有较小的影响。使用 lang 属性后，真正受益的是搜索引擎(搜索引擎利用它能够告诉用户采用哪一种语言编写文档)、屏幕阅读器(屏幕阅读器利用它能够以不同的方式发音不同的语言)以及一些应用程序(应用程序能够在它们不支持所提供的语言或者该语言与它们的默认语言不同时向用户发出警报)。当 lang 属性用于 &lt;html&gt; 元素中时，它将作用于整个文档；而在用于其他元素中时，它将仅作用于这些元素的内容。 如何使用 lang 属性1&lt;element lang=&quot;language_code&quot;&gt;&lt;/element&gt; 其中 element 代指元素名称，language_code 代表语言编码，如 en 表示英语，zh-CN 表示简体中文等等。 总结一个看似不起眼的小属性其实涵盖了国际语言规范的许多东西，在这里 mark 一下，以便以后需要用到的时候再使用。 参考资料 网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？ ——来自知乎 **Language tags in HTML and XML **——来自 w3c 语种名称代码——来自阮一峰","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"}]},{"title":"前端知识梳理（二）—— base","slug":"comb-base","date":"2017-09-29T09:43:31.000Z","updated":"2020-12-07T05:44:32.061Z","comments":true,"path":"2017/09/29/comb-base/","link":"","permalink":"https://wingsico.github.io/2017/09/29/comb-base/","excerpt":"何为 base？","text":"何为 base？ &lt;base&gt; 是一个标签，必须写在 &lt;head&gt;&lt;/head&gt; 内 有什么用？ 引用 w3school 的原话： &lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标。 通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。 使用 &lt;base&gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt; 标签中的 URL。 也就是说，假如我们有一张图片，文件名为 demo.jpg，处于与 html 的同级目录，我们在 html 文件内这样引入 &lt;img src=&quot;./demo.jpg&quot;&gt;，在未设置&lt;base&gt;的时候，浏览器自动帮我们解析成绝对路径，假设域名为: blog.wingsico.org, html 文件处于 blog.wingsico.org/index.html, 则我们在 html 内部引用的图片的路径被自动补充为 blog.wingsico.org/demo.jpg。但是当我们设置&lt;base href=&quot;www.w3school.com.cn/i/&quot; /&gt; 则 html 文件内的图片路径被自动补充为 www.w3school.com.cn/i/demo.jpg。 怎么用属性href(required) 其值为一个 URL，用于规定页面中所有相对链接的基准 URL。 target(可选) 其值与锚标签中的一致，有 _blank _parent _self _top 规定在何处打开页面中所有的链接。 总结之前没有见过这个标签，所以就专门去查看了一番，不过也是一个不常用的标签，使用不当容易造成一些路径丢失，资源无法找到的一些情况。 参考资料 w3school , 相关链接：http://www.w3school.com.cn/tags/tag_base.asp","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"}]},{"title":"前端知识梳理（一）—— 实体符号","slug":"comb-entity","date":"2017-09-29T09:21:35.000Z","updated":"2020-12-07T05:44:32.061Z","comments":true,"path":"2017/09/29/comb-entity/","link":"","permalink":"https://wingsico.github.io/2017/09/29/comb-entity/","excerpt":"关于 HTML 中实体符号的梳理","text":"关于 HTML 中实体符号的梳理 什么是实体符号实体符号被用作实现一些保留字符如(&lt;)(&gt;)或表达键盘一些无法输入的字符，在 HTML 中他们会被误认为标签。如果希望正确的显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 实体符号举例字符实体类似这样： 1&amp;entity_name; 或者 1&amp;#entity_number; 如 &amp;copy; 或 &amp;#169; 小提示 使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。 HTML 中的常用字符实体是不间断空格 &amp;nbsp; 。浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &amp;nbsp; 字符实体。 实体名称对大小写敏感。 总结之前对实体符号的认识仅限于 &amp;nbsp; 虽然实体符号用的地方不多，但是我觉得还是需要了解，留作此片博客，以便需要用到的时候翻阅。 参考资料 w3cschool——字符实体，地址：http://www.w3school.com.cn/tags/html_ref_entities.html HTML 实体字符，地址：https://www.waitig.com/html%E5%AE%9E%E4%BD%93%E7%AC%A6%E5%8F%B7%E4%BB%A3%E7%A0%81.html","categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"}]},{"title":"初探Vue-cli——目录结构探秘","slug":"vue-cli-1","date":"2017-08-04T09:15:49.000Z","updated":"2020-12-07T05:44:32.072Z","comments":true,"path":"2017/08/04/vue-cli-1/","link":"","permalink":"https://wingsico.github.io/2017/08/04/vue-cli-1/","excerpt":"前言这里先说一下使用 vue-cli 之前的事情。 由于刚刚接触 Vue 不久，就接到了一个移动端项目，于是打算使用 vue 来进行一次尝试，所以按照练习时候的样子，emmm 先把 vue.js 引入网页里来，emmm 自己的外联 main.css 样式引进来，还有自己的 main.js 文件，还有一些图片布拉布拉的.","text":"前言这里先说一下使用 vue-cli 之前的事情。 由于刚刚接触 Vue 不久，就接到了一个移动端项目，于是打算使用 vue 来进行一次尝试，所以按照练习时候的样子，emmm 先把 vue.js 引入网页里来，emmm 自己的外联 main.css 样式引进来，还有自己的 main.js 文件，还有一些图片布拉布拉的. 所以我整个项目的结构如下：（捂脸） 1234├── css├── images├── index.html└── js 由于之前我连路由，组件什么的都不会用，所以项目效果可想而知，连点击文章标题显示文章都是用弹窗来实现的（捂脸），一按返回就退出了整个网页有木有，体验效果极其糟糕，于是自己强行加了几个“返回”按钮，（实际就是 v-show 的切换 emmmm），各种栏目的切换也是通过这个，然后。。。产品就要求我改了，啊啊没办法，只好重写咯，这时学长推荐了使用 vue-cli 来快速开发，于是就开始了 vue-cli 的尝试之旅。 Vue-cli 安装以及目录说明之前看 Vue 官方文档的安装的时候，在命令行工具那里看见了 vue-cli 的安装，也尝试过，不过也就是初始化了一个项目，然后看见哇竟然自动在本地 localhost:8080 跑起来了，觉得很神奇，然后。。就没管它了，感觉自己像个智障，然后之前初始化的也找不到了，然后就重新初始化了一个项目，命令如下 12345678910# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev 没错，我就是直接从官网复制粘贴过来的，不过把 my-project 改成了 campusnews，emmm..在 VSCode 上把文件夹打开一看，我屮艸芔茻，这些都是什么玩意，这么一大堆东西，鬼都看不懂哦，不说了，放上来体会一下： …….算了，本来打算用 tree 生成一下所有的结构树，还是就展示一下主目录吧～ 123456789├── build├── config├── index.html├── node\\_modules├── package.json├── package-lock.json├── README.md├── src└── static 看不懂哦，只好去找找资料了，以下是我经过查找资料和自己的理解来讲述的，如有错误希望指正～ build这里主要是放 webpack 的一些配置，webpack 是前端网站的一种构建集成工具 目录结构：123456789├── build.js├── check-versions.js├── dev-client.js├── dev-server.js├── utils.js├── vue-loader.conf.js├── webpack.base.conf.js├── webpack.dev.conf.js└── webpack.prod.conf.js build.jsbuild 文件夹里有一个 build.js ，是我们完成项目之后需要运行的， 可以将我们的项目文件打包成 静态文件，存放在项目根目录的 dist 文件夹中（现在目录里还没有这个文件夹，build 的时候会自动生成），当然你可以自己设置路径，是在。。应该是在 config 文件夹中的 index.js 中改，可以指定主页，默认是 index.html。 check-versions.js主要是检查一些所依赖的工具的版本是否适用，如 nodejs、npm，若版本太低则会提示出来。 dev-client.js应该是本地客户端开发中有关热更新的吧～ dev-server.js是一个用作服务器端的东西，涵盖了 express 和它的一些模块，为了在本地服务器上把我们的项目跑起来的一个文件，引入了反向代理的模块，我们可以用来发起跨域请求。 utils.js（是一个功能模块？）里面引入了一些 css-loader，以便于解析各种格式的 css，如 less，sass 什么的。 vue-loader.conf.js它把上面的 utils.js 引入了，应该是用于切换 开发模式和 生产模式的文件吧，以便于用不同模式来解析 css。 下面那三个我只知道是 webpack 的一些打包的设置，比如指定入口文件啊，依赖安装路径啊，对不同后缀的文件用不同的 loader 去解析呀什么的。目前不了解这个也对我们开发项目影响不大～ config不知道干啥的，应该是配置文件 node_modules依赖所存在的文件，就是我们一开始使用 npm install 安装的东西，都在里面，以后我们要添加依赖也是放在这个里面，可能有人会又疑问，你 npm install 后面啥也没加啊，你安装了啥。一看就是不了解 npm 的人（虽然我也不了解（捂脸）），npm install 可以从当前根目录中的 package.json 文件中读取所要安装的模块的名称和版本，然后一次性安装所有的依赖。 src终于到了最重要的部分，src 目录就是一般我们需要写的地方了。 目录结构12345├── App.vue├── assets├── components├── main.js└── router App.vue是我们的主组件，也是我们所有组件和路由的出口，之后他会被渲染到我们项目根目录的 index.html 中显示出来，我们可以在这里写一些适合全局的 css 样式，比如说 css reset，字号，字体什么的。 assets是我们放一些静态图片资源的目录，虽然我没有放图片在里面。 components这里存放的是我们写的各种组件，各个组件联系在一起组成一个完整的项目 router我们定义路由的地方，虽然也可以直接在 main.js 中直接定义，但是分开的话结构更加清晰，路由的定义我们下次再说～ main.js入口文件，引入了 vue 模块 和 app.vue 组件 以及 路由 router，我们需要在全局使用的一些东西也可以定义在这里面。 static用于存放我们需要使用的一些外部的 js、css 文件，需要使用的时候从这里引到文件内。 总结好了，至此整个 vue-cli 的目录我们都过了一遍，虽然我写的不是很详细，甚至有错误，待我慢慢学习并更新咯，希望各位看官老爷能指出，谢谢。","categories":[{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://wingsico.github.io/tags/vue/"}]}],"categories":[{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"深入理解","slug":"深入理解","permalink":"https://wingsico.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"},{"name":"技术杂文","slug":"技术杂文","permalink":"https://wingsico.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://wingsico.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"专治懒癌","slug":"专治懒癌","permalink":"https://wingsico.github.io/categories/%E4%B8%93%E6%B2%BB%E6%87%92%E7%99%8C/"}],"tags":[{"name":"念","slug":"念","permalink":"https://wingsico.github.io/tags/%E5%BF%B5/"},{"name":"javascript","slug":"javascript","permalink":"https://wingsico.github.io/tags/javascript/"},{"name":"规范","slug":"规范","permalink":"https://wingsico.github.io/tags/%E8%A7%84%E8%8C%83/"},{"name":"unicode","slug":"unicode","permalink":"https://wingsico.github.io/tags/unicode/"},{"name":"总结","slug":"总结","permalink":"https://wingsico.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"规划","slug":"规划","permalink":"https://wingsico.github.io/tags/%E8%A7%84%E5%88%92/"},{"name":"mysql","slug":"mysql","permalink":"https://wingsico.github.io/tags/mysql/"},{"name":"vue","slug":"vue","permalink":"https://wingsico.github.io/tags/vue/"},{"name":"函数式","slug":"函数式","permalink":"https://wingsico.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"},{"name":"es6","slug":"es6","permalink":"https://wingsico.github.io/tags/es6/"},{"name":"linux","slug":"linux","permalink":"https://wingsico.github.io/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://wingsico.github.io/tags/nginx/"},{"name":"服务器","slug":"服务器","permalink":"https://wingsico.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"webpack","slug":"webpack","permalink":"https://wingsico.github.io/tags/webpack/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wingsico.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++","slug":"c","permalink":"https://wingsico.github.io/tags/c/"},{"name":"html","slug":"html","permalink":"https://wingsico.github.io/tags/html/"},{"name":"你所不知道的HTML","slug":"你所不知道的HTML","permalink":"https://wingsico.github.io/tags/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84HTML/"},{"name":"移动端","slug":"移动端","permalink":"https://wingsico.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"随笔","slug":"随笔","permalink":"https://wingsico.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"项目总结","slug":"项目总结","permalink":"https://wingsico.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"host","slug":"host","permalink":"https://wingsico.github.io/tags/host/"},{"name":"C++","slug":"C","permalink":"https://wingsico.github.io/tags/C/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wingsico.github.io/tags/nodejs/"},{"name":"typescript","slug":"typescript","permalink":"https://wingsico.github.io/tags/typescript/"},{"name":"npm","slug":"npm","permalink":"https://wingsico.github.io/tags/npm/"},{"name":"this","slug":"this","permalink":"https://wingsico.github.io/tags/this/"},{"name":"wordpress","slug":"wordpress","permalink":"https://wingsico.github.io/tags/wordpress/"},{"name":"知识梳理","slug":"知识梳理","permalink":"https://wingsico.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"},{"name":"iframe","slug":"iframe","permalink":"https://wingsico.github.io/tags/iframe/"},{"name":"语义化","slug":"语义化","permalink":"https://wingsico.github.io/tags/%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"name":"vpn","slug":"vpn","permalink":"https://wingsico.github.io/tags/vpn/"}]}