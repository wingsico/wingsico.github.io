<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="wingsico的编程世界"><title>基于栈结构的中缀表达式求值 | wingsico</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><!-- hexo injector head_end start -->
<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基于栈结构的中缀表达式求值</h1><a id="logo" href="/.">wingsico</a><p class="description">真正的大师，永远都怀着一颗学徒的心</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> Tags</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">基于栈结构的中缀表达式求值</h1><div class="post-meta">12-16-2017<span> | </span><span class="category"><a href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 9.3k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 37</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2017/12/16/stack-calc/#vcomment"><span class="valine-comment-count" data-xid="/2017/12/16/stack-calc/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">2.</span> <span class="toc-text">思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">中缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">前缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">算符优先算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coding"><span class="toc-number">4.</span> <span class="toc-text">Coding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">如何实现算符优先算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%84%E5%AD%98%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">如何寄存运算符和运算数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="toc-number">4.3.</span> <span class="toc-text">如何判断一个字符是否为数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BD%8D%E6%95%B0%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%B0%8F%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">4.4.</span> <span class="toc-text">如何实现多位数字以及小数的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.5.</span> <span class="toc-text">如何使用算符优先级表判断运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E5%90%97"><span class="toc-number">5.</span> <span class="toc-text">结束吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">深入与思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>关于中缀表达式的 C++实现和原理介绍</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>栈这个东西，说简单也简单，就是一种数据结构，只是与顺序表，链表什么的不同，它遵循的是<strong>LIFO(后进先出)原则</strong>，阿这不是很简单么，只要时刻记住这一点就好了，<strong>只能从结构的一端进入和同一端出来</strong>就好了，这两个操作分别称为<strong>入栈</strong>和<strong>出栈</strong>。可以把它比喻成一筒可比克薯片，它是只有一边有盖子，称之为栈顶，它有一个金属的底部，防止薯片从底下漏出来了，称之为栈底。如果底部破了，薯片从底部漏了出来，称之为<strong>栈下溢</strong>；如果薯片装的过满了从顶部溢出来掉地上了，称之为<strong>栈上溢</strong>。关于这两个概念应该很好理解，但是这不是今天的重点，暂且不理它。 关于栈的概念应该大致清楚了，因为标题的缘故我再稍稍提一下<strong>队列</strong>。队列很好理解，从字面意思上我们就好理解了，就像排队一样，比如坐火车前去自动取票机取票，你得等你前面的人取完票你才能取票，当然队列里的数据元素都是遵纪守法的好公民，不存在插队现象（特意去搜了一下，栈应该是不存在自身插队的问题的），这就是<strong>FIFO(先进先出)原则</strong>，队列在遵循这个原则产生了多种变种比如<strong>双端队列、链队列、循环队列等</strong>。诶又扯远了，现在就正式开始吧。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本次应用实例是一个 <code>基于栈结构</code>的中缀表达式求值的一个程序，先不提实验本身，先搞清楚什么是<strong>中缀表达式</strong>，以及<strong>前缀和后缀表达式</strong>才是当务之急。 在表达式表示中，我们依照运算符相对运算数的位置不同，把这三个表达式分为：</p>
<ul>
<li><strong>中缀表达式</strong></li>
<li><strong>前缀表达式（波兰式）</strong></li>
<li><strong>后缀表达式（逆波兰式）</strong></li>
</ul>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span> + <span class="number">4</span>) * <span class="number">5</span> - <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>概念：中缀表达式的运算符以中缀形式处于运算数的中间。</p>
<h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- * + <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>概念：前缀表达式的运算符位于运算数之前。</p>
<h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> + <span class="number">5</span> * <span class="number">6</span> -</span><br></pre></td></tr></table></figure>

<p>概念：后缀表达式的运算符位于运算数之间。 对于<strong>中缀表达式</strong>，不用过多的解释，这个是我们日常使用的表达方式，一眼就能看出答案为 29。但是对于不了解的人来说，后面两个可能就不太看得懂了，其实，根据概念我们就可以大概猜出来了。由于加减乘除都是<strong>双运算数运算符</strong>，我们对于一个运算符要找出两个运算数与之搭配。先来看更简单易懂的<strong>后缀表达式（逆波兰式）</strong>求值，始终记住<strong>双运算数运算符</strong>。</p>
<ol>
<li>从左到右取出第一个运算符前两个运算数 <code>3 4</code></li>
<li>取出该运算符 <code>+</code></li>
<li>将两个运算数和运算符按照中缀表达式结合 <code>3 + 4</code></li>
<li>将使用了的运算符和运算数去除，将得到的结果放回原表达式 <code>7 5 * 6 -</code></li>
<li>重复 1 ～ 4，扫描的起始位置更改为之前运算符<code>+</code>所在位置</li>
<li>直到表达式中运算符被使用完毕，最后的到的运算数就是最终的值 <code>29</code></li>
</ol>
<p>接下来看稍微复杂一点的<strong>前缀表达式（波兰式）</strong>，由于部分复杂，我将采用图示法。</p>
<ol>
<li><p>表达式从右向左扫描，遇到数字则把数字压入栈中，直到遇到非数字的运算符 <code>+</code>, 得到一个数字栈 <code>3 4 5 6</code></p>
<p><img src="http://wingsico.org/images/1.png" alt="示意图1-w400"></p>
</li>
<li><p>将栈顶元素出栈作为第一个运算数 a <code>a = 3</code>, 再执行一次出栈操作拿到栈顶元素作为第二个运算数 b <code>b = 4</code>，用～代表之前拿到的第一个运算符<code>+</code>，执行式子 <code>a ~ b = 3 + 4 = 7</code><br><img src="http://wingsico.org/images/2.png" alt="示意图2-w400"></p>
</li>
<li><p>将运算结果<code>7</code>再次压栈，将～ <code>+</code>丢弃，从之前<code>+</code>所在的位置继续向左扫描</p>
<p><img src="http://wingsico.org/images/3.png" alt="示意图3-w400"></p>
</li>
<li><p>重复 1-3 步骤，直到扫描到最左边无运算符，停止运算，最后栈中剩下的数字就是求值的最后结果 <code>29</code></p>
</li>
</ol>
<p>通过我以上的描述，应该可以较明确的解释前缀、中缀、后缀表达式如何计算它们，下面给出一个更加复杂的前中后缀表达式，应该也很好计算。</p>
<blockquote>
<p>中缀：1 + ( ( 2 + 3 ) × 4 ) - 5<br>前缀：- + 1 × + 2 3 4 5<br>后缀：1 2 3 + 4 × + 5 -</p>
</blockquote>
<p>答案均为 <code>16</code> 经过上面的解释，不难看出，中缀和后缀表达式是比较好被计算机来解析并运算的，虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。 <strong>但是！</strong>我们先把转换表达式的方法放到最后来说，我们这里使用另一种简单直观、广为使用的方法来求解中缀表达式——<strong>算符优先算法</strong></p>
<h2 id="算符优先算法"><a href="#算符优先算法" class="headerlink" title="算符优先算法"></a>算符优先算法</h2><p>什么是算符优先算法呢？简单来说：</p>
<blockquote>
<p>算符优先算法是根据运算优先关系的规定来实现对表达式的编译或解释执行的</p>
</blockquote>
<p>举个例子，我们从小学就学过了四则运算的规则：</p>
<ol>
<li>先乘除后加减</li>
<li>从左算到右</li>
<li>先算括号内再算括号外</li>
</ol>
<p>所以对于以下式子，我们可以很快给出计算顺序然后得出正确的答案：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 + 2 * 3 - 10 / 5</span><br><span class="line"></span><br><span class="line">(1) 4 + 2 * 3 - 10 / 5</span><br><span class="line">(2) 2 * 3 = 6</span><br><span class="line">(3) 4 + 6 - 10 / 5</span><br><span class="line">(4) 10 - 10 / 5</span><br><span class="line">(5) 10 / 5 = 2</span><br><span class="line">(6) 10 - 2</span><br><span class="line">(7) 8</span><br></pre></td></tr></table></figure>

<p>为了下面更好的理解一些术语词，先放上一段术语介绍：</p>
<p><strong>任何一个表达式都是由操作数、运算符和界限符组成的，我们称它们为单词。一般地，操作数既可以是常数也可以是被说明为变量或常量标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有左右括号和表达式结束符等等。</strong> <strong>我们把运算符和界限符统称为算符，它们构成的集合命名为 OP</strong></p>
<p>容易看出，像 <code>+ - * /</code> 为运算符， <code># ( )</code> 为界限符**(#为表达式结束符)**，则 OP 为这样一个集合 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;]</code></p>
<p>那么我们如何让计算机在运算中判断两个相继出现的算符 ß1 和 ß2 之间的优先关系呢？</p>
<p>通过<strong>算符优先级表</strong>！</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/zabery/WindowsLiveWriter/8cb80e0d0c2b_11913/untitled.png" alt="运算优先级表"></p>
<p>PS: 纵轴符号为运算符 ß1，横轴符号为运算符 ß2 ß1 代表<strong>运算符栈顶元素</strong>，ß2 代表<strong>输入的算符</strong> <code>&gt;</code> 代表 ß1 优先级高于 ß2 <code>=</code> 代表 ß1 优先级等于 ß2 <code>&lt;</code> 代表 ß1 优先级低于 ß2</p>
<p>可以看到，表中有内容为空的单元格，这是因为表达式中不允许他们相继出现，一旦有这种情况，我们可以把它当作出现了错误的表达式，在下面的讨论中我们假定所输入的表达式不会出现语法错误，关于这个表的具体使用方法，我们在下面的讨论中会提到。</p>
<p>磨刀不误砍柴功，在我们正式开始编码之前，举出一些问题并想到解决办法会让我们的编程思路更加清晰。</p>
<ul>
<li>如何读取输入的中缀表达式</li>
<li>如何实现算符优先算法<ul>
<li>如何寄存运算数和运算符</li>
<li>如何使用算符优先级表判断运算符优先级</li>
<li>如何实现多位数字和小数的存储</li>
<li>如何判断输入的字符是否为数字</li>
<li>…</li>
</ul>
</li>
</ul>
<p>有一些问题需要随着我们深入编码才会逐渐浮现出来，所以在下面再提出并解决吧～现在，就来正式开始编码之旅</p>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p>先来解决上面已经列出来的问题吧！</p>
<blockquote>
<p>如何读取输入的中缀表达式？</p>
</blockquote>
<p>针对这个问题，书上给出了一种方式，使用<code>getchar()</code>，一开始我也确实是使用这种方法的，但后面暴露了一些问题：</p>
<ul>
<li>每次只能读取一位字符，比如输入 10 只能分开读取为 1，0，导致难以判断是多位数字还是个位数字</li>
<li>还有一个问题到后面再提，这里先<code>mark</code>一下</li>
</ul>
<p>于是我放弃了使用<code>getchar()</code>，决定使用一个字符数组来存储我所输入的中缀表达式，初始代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> express[STACK_INIT_SIZE]; <span class="comment">// 存储中缀表达式</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// 存储运算结果</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入中缀运算式: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; express; <span class="comment">// 直接用cin读取中缀表达式</span></span><br><span class="line">    result = MidExpression_Eval(express); <span class="comment">// 这是定义的解析中缀表达式的函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出等式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>STACK_INIT_SIZE</code>是我一开始在程序头部定义的一个常数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_INIT_SIZE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>用途除了<strong>初始化存储中缀表达式的数组的内存空间</strong>、还用于<strong>初始化栈</strong>，会在下面说到。 针对这个问题，以上代码其实很明显的暴露了一些问题：</p>
<ul>
<li>运算中免不了有除法，所以会出现有小数的情况</li>
<li>每次输入运算符都要自己手动在末尾加入运算结束符<code>#</code>，很麻烦</li>
<li>在输出等式的时候，会将运算结束符也输出，即会出现<code>1+3*2/5#=2.2</code>的情况</li>
</ul>
<p>解决方法很简单：</p>
<ol>
<li><p> <code>int result</code> 写成 <code>float result</code>，实在不放心还能写成 <code>double result</code></p>
</li>
<li><p>在输入的时候不输入 <code>#</code>，在代码中将 <code>#</code> 添加到字符数组的最后面</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">express[<span class="built_in">strlen</span>(express)] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 一定要放在下一句的前面</span></span><br><span class="line">result = MidExpression_Eval(express);</span><br></pre></td></tr></table></figure>

<p> <code>strlen()</code> 的功能就是返回数组内实际所占的长度，不记录<code>\0</code>，这里 就不过多的描述了。 举个例子就明白了：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> test[<span class="number">100</span>] = &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(test); <span class="comment">// 5</span></span><br><span class="line">test[<span class="built_in">strlen</span>(test)] = <span class="string">&#x27;#&#x27;</span> <span class="comment">// 相当于 test[5] = &#x27;#&#x27;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test; <span class="comment">// 2+3*4#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上面的方法，我们免去了输入中缀表达式的结束符<code>#</code>，但是我们实际上<code>express</code>的内容仍带有 <code>#</code>，所以，我们在输出等式之前，可以先把结束符去除:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = MidExpression_Eval(express);</span><br><span class="line">express[<span class="built_in">strlen</span>(express) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 必须放在上面那个式子的后面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p> 解释一下，由于在解决 2 里面将 <code>#</code> 加了 express 内，会使<code>expresss</code> 的长度增加 1，也就是<code>strlen(express)</code> 的值会比原来大 1，因此 <code>#</code> 的位置就在 <code>express[strlen(express) - 1]</code>，把这个位置的字符替换成 <code>\0</code>，因为 <code>cout</code> 在输出字符数组的时候会截止于 <code>\0</code></p>
</li>
</ol>
<p>三个问题都解决了，最后代码清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> express[STACK_INIT_SIZE]; <span class="comment">// 存储中缀表达式</span></span><br><span class="line">    <span class="keyword">float</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入中缀运算式: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; express;</span><br><span class="line">    express[<span class="built_in">strlen</span>(express)] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    result = MidExpression_Eval(express);</span><br><span class="line">    express[<span class="built_in">strlen</span>(express) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样真的好了吗? (😏 笑) 其实上面还有一个问题，暂时还没有暴露出来。在这里就提前说了吧！ 注意到我们的中缀表达式字符数组只是定义了但没有初始化，一开始我也觉得应该没有什么问题，但直到我把所有程序完成执行输出的时候这个问题才暴露了出来： <code>cout &lt;&lt; express</code> 并没有在预期的位置(设置’\0’的地方)停止输出，而是在后面的一些的位置停止，导致输出了一些乱码。这是为什么呢？ 在数组初始化之前，数组里的每一个数据单元的内容都是不确定的，如果我们不进行初始化的话，就会导致数组未赋值的区域内容不确定，就有可能出现上述情况，因此，我们做出一个改进，即初始化<code>express</code>数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> express[STACK_INIT_SIZE] = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就解决了不在预期停止输出的 bug。 好了，接下去下一个大问题。</p>
<h3 id="如何实现算符优先算法"><a href="#如何实现算符优先算法" class="headerlink" title="如何实现算符优先算法"></a>如何实现算符优先算法</h3><p><strong>算法思想</strong>：</p>
<ol>
<li>首先置运算数栈为空栈，表达式起始符 <code>#</code> 作为运算符栈的栈底元素</li>
<li>依次读入表达式中的每一个字符，若是运算数则进运算数栈，若是运算符则和运算符栈中的栈顶运算符比较优先级后作相应操作，直至整个表达式求值完毕（即运算符栈的栈顶元素和当前读入的字符均为 <code>#</code></li>
</ol>
<h3 id="如何寄存运算符和运算数"><a href="#如何寄存运算符和运算数" class="headerlink" title="如何寄存运算符和运算数"></a>如何寄存运算符和运算数</h3><p>我的自我对算符优先的认识（没有具体考证，待指正。）： <strong>算符优先算法的求解过程跟后缀表达式求值过程十分相似，均是使用 <em>压栈_， _入栈_， _栈外运算</em> 等操作完成的。</strong> 因此，我们需要使用 <strong>栈</strong> 来存储我们的<strong>运算数</strong>和<strong>运算符</strong>，因此我们需要声明、定义和初始化栈，版本 1 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Sqstack</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base, *top; <span class="comment">// 栈顶和栈底指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize; <span class="comment">// 栈的内存大小</span></span><br><span class="line">&#125; Sqstack0, Sqstack1; <span class="comment">// 运算数栈1 ／ 运算符栈0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在某个函数内</span></span><br><span class="line">Sqstack0 OPTR; <span class="comment">// 运算符栈</span></span><br><span class="line">Sqstack1 OPND; <span class="comment">// 运算数栈</span></span><br></pre></td></tr></table></figure>

<p>只声明了一个栈类型，但定义了两个结构体变量，分别用来存储运算数和运算符，这样做有一个好处：</p>
<ul>
<li>只需要写一个初始化栈、入栈、出栈、获取栈顶元素函数</li>
</ul>
<p>但是相比于它所带来的缺点，这个优点可以忽略了：</p>
<ul>
<li>运算符和运算数都用同一个类型的栈，其内部的指针均为字符类型，对于运算数会产生许多麻烦的事情，比如：<ul>
<li>对于多位数字，无法存入数字类型，且作为字符也只能一个个存，且转换成数字很麻烦</li>
<li>从运算数数栈中取出的是字符，无法直接参与运算</li>
</ul>
</li>
</ul>
<p>解决的话可以使用两个不同的栈分别存储运算数和运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算符栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算数栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack1;</span><br></pre></td></tr></table></figure>

<p>上面对于不同的栈指定了不同的指针类型，但运算数栈的指针类型真的正确吗？想一想看，这个栈是用来寄存运算数的，而在运算过程中可能会产生浮点类型的数字，因此我们要改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算数栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack1;</span><br></pre></td></tr></table></figure>

<h3 id="如何判断一个字符是否为数字"><a href="#如何判断一个字符是否为数字" class="headerlink" title="如何判断一个字符是否为数字"></a>如何判断一个字符是否为数字</h3><p>答: ASCII 码 众所周知，字符在内部是以 <code>ASCII码</code> 来存储的，数字 0 ～ 9 都是使用连续的 <code>ASCII码</code> 表示的，且有一个更重要的是，<strong>字符之间是可以比较大小的，比较的就是 <code>ASCII码</code> 的大小</strong>，因此，我们可以据此实现判断一个字符是否为数字的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>); <span class="comment">// 是数字返回 true，不是则返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现多位数字以及小数的存储"><a href="#如何实现多位数字以及小数的存储" class="headerlink" title="如何实现多位数字以及小数的存储"></a>如何实现多位数字以及小数的存储</h3><p>来看一个式子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> + <span class="number">12</span> * <span class="number">3</span> / <span class="number">9</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>按照我们的算法思想，首先先使用上面写的 <code>isNumber(char c)</code> 函数，判断该字符是否为一个数字，如果是，我们需要先把它转换成真正的数字，比如说第一个遇到了字符 <code>&#39;6&#39;</code>，我们可以这样把它转换成数字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = c - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// num 为 6</span></span><br></pre></td></tr></table></figure>

<p>记住，字符也是可以进行运算的（用 ASCII 码），查 <code>ASCII码表</code> 就可以知道，字符 <code>&#39;6&#39;</code> 的 <code>ASCII码</code> 为 64，<code>&#39;0&#39;</code> 的 <code>ASCII码</code> 为 48，则两个字符相减刚好为数字 <code>6</code>， 这样就将字符转换成了数字。 但是，当我们遇到 <code>12</code> 的时候又会出现什么问题呢，<code>12</code> 会被拆分成 <code>&#39;1&#39;, &#39;2&#39;</code>，如果我们不经过任何处理就压入运算数栈的话是会出问题的，那么该如何解决呢？代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">theChar = express[i]; <span class="comment">// 拿到表达式的第一个值</span></span><br><span class="line"><span class="keyword">while</span> (theChar != <span class="string">&#x27;#&#x27;</span> || GetTop(Op_char) != <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 判断表达式是否结束</span></span><br><span class="line">    <span class="keyword">char</span> numbers[<span class="number">20</span>]; <span class="comment">// 用于存储多位数字</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度</span></span><br><span class="line">    <span class="keyword">while</span> (isNumber(theChar)) &#123; <span class="comment">// 若是数字，则循环读取</span></span><br><span class="line">        numbers[j] = theChar;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        theChar = express[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈</span></span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">            sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k); <span class="comment">// 将字符转换成对应的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        Push1(Op_float, sum);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123; ... &#125;; <span class="comment">// 若不是数字则执行else里的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于除了处理多位数字的代码，上面都有详细的注释，这里着重解释多位数字的存储。 首先我们定义了字符数组，分配了 20 个内存单元，因为我们读入的数字不管是 <code>int</code>类型还是 <code>float</code> 类型进行四则运算一般不超过这个长度；同时，使用一个变量 <code>j</code> 来存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度，还能通过判断是否为 0 来辨别是运算数还是运算符。 若扫描到某一位为数字，不会直接将其压入运算符栈中，而是会继续获取下一位，直到获取到非数字时，<code>while</code> 才会跳出循环，进行数字位数(<code>j</code>)的判断。若是多位数字，则循环遍历存储着多位数字的数组 <code>numbers[]</code>，将其转换成真正的数字。 <code>for</code> 循环里面的那句语句如何理解呢？举个例子，假设：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> numbers[<span class="number">20</span>] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这是一个三位数字，值为<code>123</code>，那么如何根据其下标转换成数字呢？ 我们上面提到了如何将单个字符转换成单个数字，所以 <code>numbers[k] - &#39;0&#39;</code>就很好理解，<code>pow()</code> 函数是一个求次方的函数， <code>pow(10, 2)</code> 是求 10 的二次方，观察我假设的这个字符数组，我们可以获得三个信息：</p>
<ol>
<li>长度<code>j</code>为 3</li>
<li>对应下标<code>k</code>为 0, 1, 2</li>
<li>值为 <code>123</code></li>
</ol>
<p>其次，<code>123</code> 可以拆分成 <code>1 * 10^2 + 2 * 10^1 + 3 * 10^0</code>，所以答案一目了然，<code>10</code> 的幂可以由公式 <code>j - k - 1</code>（数组长度 - 当前数字字符下标 - 1）求出， 所以转换公式为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k)</span><br></pre></td></tr></table></figure>

<p>运算结束后，将累加得到的数字 <code>sum</code> 压入运算数栈，大功告成。 且慢，如果数字是小数怎么办？同样的思路，我们来将之前的代码改进一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">theChar = express[i]; <span class="comment">// 拿到表达式的第一个值</span></span><br><span class="line"><span class="keyword">while</span> (theChar != <span class="string">&#x27;#&#x27;</span> || GetTop(Op_char) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> numbers[<span class="number">10</span>]; <span class="comment">// 用于存储多位数字</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度</span></span><br><span class="line">    <span class="keyword">while</span> (isNumber(theChar) || theChar == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 若是数字或小数点，则循环读取</span></span><br><span class="line">        numbers[j] = theChar;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        theChar = express[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈</span></span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dot = getIndex(numbers, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 若无小数点则返回-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[k] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dot != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; dot) &#123;</span><br><span class="line">                    sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k - dot - <span class="number">1</span>); <span class="comment">// 将字符转换成对应的多位数字</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; dot) &#123; <span class="comment">// 若没有小数点，这个块不执行</span></span><br><span class="line">                    sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, dot - k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Push1(Op_float, sum);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">// 若不是数字则执行else里的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小数转换的思路就不多说了，和上面是一样的，用<strong>小数点所在的位置</strong>减去<strong>小数点后面的数字的位置</strong>得到的就是其<code>10</code>的幂的值。 但是，这里面还是有一些要小心的陷阱：</p>
<ul>
<li><code>j</code> 会因为含有小数点而增加长度，因此不能再使用 <code>j - 1 - k</code> 来确定整数部分乘以<code>10</code>的幂的值了, 应该将长度<code>j</code>减去小数点占的一个元素再减去小数点所在的下标<code>dot</code>。</li>
<li>区分小数点前后的转换规则，若 <code>k &lt; dot</code> 执行整数部分转换， 若 <code>k &gt; dot</code> 执行小数部分转换</li>
</ul>
<p>除此之外，里面增加了一个新的函数 <code>getIndex(numbers, &#39;.&#39;)</code>，是为了寻找小数点，找到了则返回小数点的下标，没有找到则返回 <code>-1</code>，根据下标是否等于 <code>-1</code> 判断是否是一个小数。来看这个函数的内部实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ops[], <span class="keyword">char</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == ops[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，这个问题也解决了，下面解决最让人疑惑的部分。</p>
<h3 id="如何使用算符优先级表判断运算符优先级"><a href="#如何使用算符优先级表判断运算符优先级" class="headerlink" title="如何使用算符优先级表判断运算符优先级"></a>如何使用算符优先级表判断运算符优先级</h3><p>算符优先级表我之前已经给出了，对于这样一个表，第一反应就是将它转换成二维数组，行代表输入的字符，列代表运算符栈顶元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// +</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// -</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// *</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// /</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;, <span class="comment">// (</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// )</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;=&#x27;</span>&#125;  <span class="comment">// #</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于这张表，我们需要做什么呢，在上面介绍这张表的时候，已经给出了一些关于 <code>&#39;&gt;&#39;, &#39;=&#39;, &#39;&lt;&#39;</code> 的具体含义，我们要做的就是根据<strong>输入的字符</strong>和<strong>运算符栈顶元素</strong>来从这张表中获取它们的优先级比较。 <strong>具体做法：</strong> 我们先创建一个运算符全集数组，用来对应优先级表的第一行和第一列的元素符元素（看之前的那张图）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与比较符号优先级二维数组对应的操作符全集</span></span><br><span class="line"><span class="keyword">char</span> OP[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>有了这个，我们只需要找出<strong>输入的字符在这个数组中对应的下标 <code>i</code>**以及</strong>运算符栈顶元素在这个数组中对应的下标 <code>j</code><strong>，就可以通过 <code>priority[i][j]</code> 来获取 **运算符栈顶元素</strong> 和 <strong>输入的算符</strong> 之间的优先关系。用一个十分精简的函数 <code>Precede</code> 实现获取其优先关系:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> top, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// top 为运算符栈顶元素，c为输入的算符</span></span><br><span class="line">    <span class="keyword">return</span> priority[getIndex(OP, top)][getIndex(OP, c)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用了 <code>getIndex()</code> 辅助函数。 这个函数我们有三个可能的返回值：</p>
<ul>
<li><p><code>&lt;</code> 栈顶元素优先级低，将输入的算符压入运算符栈，因为栈的<code>LIFO原则</code>，越靠近栈顶的元素会有更高的优先级去进行运算，之后继续读取下一个字符。</p>
</li>
<li><p><code>=</code> 优先级相等，除了 <code>&#39;#&#39;</code> 与 <code>&#39;#&#39;</code>之间，就只有 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code>了，但是 <code>&#39;#&#39;</code> 是不可能出现在这一层函数的，它会在最外部的 <code>while</code> 循环中判断。所以这里的作用就是将运算符栈处于栈顶位置的 <code>&#39;(&#39;</code>脱去，并读取下一个字符，以便其他算符的运算</p>
</li>
<li><p>‘&gt;’ 栈顶元素优先级高，将优先处理栈顶元素：将运算符栈顶元素取出，同时取出两次运算数栈顶元素，将其组合成中缀表达式进行运算，将运算结果再重新压入运算数栈内，达到优先运算的预期要求<strong>（此时无需读取下一个字符，因为输入的字符还未使用）</strong>。</p>
</li>
</ul>
<p>实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (Precede(GetTop(Op_char), theChar)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="comment">// 栈顶元素优先级比此时的取值更低</span></span><br><span class="line">        Push(Op_char, theChar); <span class="comment">// 压入运算符栈</span></span><br><span class="line">        theChar = express[++i]; <span class="comment">// 使读取的位置后移，并取到下一个字符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">        <span class="keyword">char</span> x;</span><br><span class="line">        Pop(Op_char, x); <span class="comment">// 脱括号并读取下一个字符</span></span><br><span class="line">        theChar = express[++i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: <span class="comment">// 出栈并将运算结果入栈</span></span><br><span class="line">        <span class="keyword">char</span> theta;</span><br><span class="line">        <span class="keyword">float</span> a, b;</span><br><span class="line">        Pop(Op_char, theta);</span><br><span class="line">        Pop1(Op_float, b);</span><br><span class="line">        Pop1(Op_float, a);</span><br><span class="line">        Push1(Op_float, Operate(a, theta, b));</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>theChar</code> 来用保存当前读取的字符，<code>Op_char</code> 是定义并经过初始化的运算符栈， <code>Op_float</code> 是定义并经过初始化的运算数栈，<code>Push</code> 和 <code>Pop</code> 是对<strong>运算符栈</strong>的<strong>入栈</strong>和<strong>出栈</strong>， <code>Push1</code> 和 <code>Pop1</code> 是对<strong>运算数栈</strong>的<strong>入栈</strong>和<strong>出栈</strong>。它们对应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">SqStack Op_char; <span class="comment">// 声明运算符栈</span></span><br><span class="line">SqStack1 Op_float; <span class="comment">// 声明运算数栈</span></span><br><span class="line"><span class="keyword">char</span> theChar; <span class="comment">// 记录目前读取表达式的字符</span></span><br><span class="line"></span><br><span class="line">InitStack(Op_char); <span class="comment">// 初始化运算符栈</span></span><br><span class="line">Push(Op_char, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 将最低优先级的&#x27;#&#x27;起始符压入操作数栈</span></span><br><span class="line"></span><br><span class="line">InitStack1(Op_float); <span class="comment">// 初始化运算数栈</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> e)</span> </span>&#123; <span class="comment">// 将运算符压入运算符栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算符栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack1</span><span class="params">(SqStack1 &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">float</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> e)</span> </span>&#123; <span class="comment">// 将运算数压入运算数栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">float</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算数栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这上面的代码都是对栈的基本操作，就不详细解释了。 除此之外，之前的代码里还有一个 <code>Operate()</code> 函数，其作用就是实现双操作符的运算的，返回的是运算的结果，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operate</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> x, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result = a + b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result = a * b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result = a - b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            result = a / b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于代码简单，没有什么技术含量，也不详细解释了。 = 至此，我们已经把提出的所有的问题解决了，下面附上源代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 定义栈类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算符栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 运算数栈 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> *base, *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义所使用的常量集</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_INIT_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_INCREMENT = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/* 用于比较符号优先级的全局二维数组 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// +</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// -</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// *</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// /</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;, <span class="comment">// (</span></span><br><span class="line">        &#123;<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;, <span class="comment">// )</span></span><br><span class="line">        &#123;<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;=&#x27;</span>&#125;  <span class="comment">// #</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 与比较符号优先级二维数组对应的操作符全集</span></span><br><span class="line"><span class="keyword">char</span> OP[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数预定义</span></span><br><span class="line"><span class="comment">// 操作结果：初始化运算符栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：得到运算符栈的栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算符栈进行压栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算符栈进行出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：初始化运算数栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack1</span><span class="params">(SqStack1 &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：得到运算数栈的栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTop1</span><span class="params">(SqStack1 &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算数栈进行压栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：对运算数栈进行出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：判断一个字符是否是数字</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：计算中缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MidExpression_Eval</span><span class="params">(<span class="keyword">char</span> Express[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：计算表达式axb，并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operate</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> x, <span class="keyword">float</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作结果：获取操作符在全集操作符中的位置，并返回下标，此函数为辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ops[], <span class="keyword">char</span> e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> top, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 操作结果：获取算符优先级关系，并返回具体优先级符号，如&#x27;&lt;&#x27;,&#x27;&gt;&#x27;等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> express[STACK_INIT_SIZE] = &#123;&#125;; <span class="comment">// 存储中缀表达式</span></span><br><span class="line">    <span class="keyword">float</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入中缀运算式: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; express;</span><br><span class="line">    express[<span class="built_in">strlen</span>(express)] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    result = MidExpression_Eval(express);</span><br><span class="line">    express[<span class="built_in">strlen</span>(express) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; express &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;s)</span> </span>&#123; <span class="comment">// 获取运算符栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(s.top - <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> e)</span> </span>&#123; <span class="comment">// 将运算符压入运算符栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;s, <span class="keyword">char</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算符栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack1</span><span class="params">(SqStack1 &amp;s)</span> </span>&#123; <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    s.base = (<span class="keyword">float</span> *) <span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTop1</span><span class="params">(SqStack1 &amp;s)</span> </span>&#123; <span class="comment">// 获取运算数栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(s.top - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> e)</span> </span>&#123; <span class="comment">// 将运算数压入运算数栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base &gt;= s.stacksize) &#123;</span><br><span class="line">        s.base = (<span class="keyword">float</span> *) <span class="built_in">realloc</span>(s.base, (s.stacksize + STACK_INCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop1</span><span class="params">(SqStack1 &amp;s, <span class="keyword">float</span> &amp;e)</span> </span>&#123; <span class="comment">// 将运算数栈顶元素出栈</span></span><br><span class="line">    <span class="keyword">if</span> (s.top != s.base)</span><br><span class="line">        e = *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operate</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> x, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result = a + b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result = a * b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result = a - b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            result = a / b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ops[], <span class="keyword">char</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == ops[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> top, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority[getIndex(OP, top)][getIndex(OP, c)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MidExpression_Eval</span><span class="params">(<span class="keyword">char</span> express[])</span> </span>&#123;</span><br><span class="line">    SqStack Op_char; <span class="comment">// 声明运算符栈</span></span><br><span class="line">    SqStack1 Op_float; <span class="comment">// 声明运算数栈</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 记录表达式读取位置</span></span><br><span class="line">    <span class="keyword">char</span> theChar; <span class="comment">// 记录目前读取表达式的字符</span></span><br><span class="line"></span><br><span class="line">    InitStack(Op_char); <span class="comment">// 初始化运算符栈</span></span><br><span class="line">    Push(Op_char, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 将最低优先级的&#x27;#&#x27;起始符压入操作数栈</span></span><br><span class="line"></span><br><span class="line">    InitStack1(Op_float); <span class="comment">// 初始化运算数栈</span></span><br><span class="line">    theChar = express[i]; <span class="comment">// 拿到表达式的第一个值</span></span><br><span class="line">    <span class="keyword">while</span> (theChar != <span class="string">&#x27;#&#x27;</span> || GetTop(Op_char) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> numbers[<span class="number">10</span>]; <span class="comment">// 用于存储多位数字</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 用于存储数字数组下标，方便增加位数, 同时也可以记录数字数组的长度</span></span><br><span class="line">        <span class="keyword">while</span> (isNumber(theChar) || theChar == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 若是数字或小数点，则循环读取</span></span><br><span class="line">            numbers[j] = theChar;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            theChar = express[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 若数字数组长度大于0，则循环数组求多位数字的值并压入运算数栈</span></span><br><span class="line">            <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> dot = getIndex(numbers, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 若无小数点则返回-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[k] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dot != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; dot) &#123;</span><br><span class="line">                        sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k - dot - <span class="number">1</span>); <span class="comment">// 将字符转换成对应的多位数字</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; dot) &#123; <span class="comment">// 若没有小数点，这个块不执行</span></span><br><span class="line">                        sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, dot - k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum += (numbers[k] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span> - k);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            Push1(Op_float, sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (Precede(GetTop(Op_char), theChar)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="comment">// 栈顶元素优先级比此时的取值更低</span></span><br><span class="line">                    Push(Op_char, theChar); <span class="comment">// 压入运算符栈</span></span><br><span class="line">                    theChar = express[++i]; <span class="comment">// 使读取的位置后移，并取到下一个字符</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                    <span class="keyword">char</span> x;</span><br><span class="line">                    Pop(Op_char, x);</span><br><span class="line">                    theChar = express[++i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">char</span> theta;</span><br><span class="line">                    <span class="keyword">float</span> a, b;</span><br><span class="line">                    Pop(Op_char, theta);</span><br><span class="line">                    Pop1(Op_float, b);</span><br><span class="line">                    Pop1(Op_float, a);</span><br><span class="line">                    Push1(Op_float, Operate(a, theta, b));</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GetTop1(Op_float);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结束吗"><a href="#结束吗" class="headerlink" title="结束吗"></a>结束吗</h2><p>看上去我们的代码已经很完善了，其实我们还有一些东西没有处理：</p>
<ul>
<li>如果输入了错误的中缀表达式？</li>
<li>某些地方的代码可以更加优雅？</li>
<li>大量的中缀表达式验证正确性？</li>
</ul>
<p>对于第一点，我是假设于使用程序的人都会输入正确的中缀表达式，并没有对错误的中缀表达式进行处理和反馈提示，因此对用户有一些不友好，待改进；其次，像一些 for 循环，if else 语句可以更加精简、优雅，没有对代码进行多次提炼，待改进；这个应用程序没有经过大量、多样的测试来验证其准确性，所以并不能保证其完全正确，待改进。</p>
<h2 id="深入与思考"><a href="#深入与思考" class="headerlink" title="深入与思考"></a>深入与思考</h2><blockquote>
<p>如何求后缀表达式的值，以及中缀表达式如何转换为后缀表达式？</p>
</blockquote>
<p>对于前一个问题，我在 Thinking 里已经描述过了，这里就不再再次阐述，对于后一个问题，有了上面的基础，也是很容易实现的，这里就不用代码描述了，就用文字描述一下大概的思路：</p>
<ol>
<li>初始化两个栈：运算符栈 S1 和储存中间结果的栈 S2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压入 S2；</li>
<li>遇到运算符时，比较其与 S1 栈顶运算符的优先级：<ol>
<li>如果 S1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入 S1；</li>
<li>否则，将 S1 栈顶的运算符弹出并压入到 S2 中，再次转到<code>4-i</code>与 S1 中新的栈顶运算符相比较；</li>
</ol>
</li>
<li>遇到括号时：<ol>
<li>如果是左括号“(”，则直接压入 S1；</li>
<li>如果是右括号“)”，则依次弹出 S1 栈顶的运算符，并压入 S2，直到遇到左括号为止，此时将这一对括号丢弃；</li>
</ol>
</li>
<li>重复步骤<code>2</code> 至 <code>5</code>，直到表达式的最右边；</li>
<li>将 S1 中剩余的运算符依次弹出并压入 S2；</li>
<li>依次弹出 S2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次的程序和记录总结，我学到了很多，其中最值得一提的就是编码方式。 在编写程序的时候，我可以先不管各个功能的具体实现（比如<code>Operate()</code>啊，<code>Pop()</code>啊什么的）， 我只需要关注完成这个程序需要什么功能，先写下来，完成一个主函数的逻辑，到后面再去分别实现一个个的辅助函数的逻辑，领悟了这一点对我来说是非常有帮助的，这可以大大的提高我函数式编程的思维。 除此之外，实现一些辅助函数的辅助函数的时候也对我的思维进行了锻炼，比如说精简的<code>Precede()</code>，对多位数字和小数的处理，以及整个中缀表达式求值思维得到了巩固和拓展，对于克服种种难题有满满的成就感。 好了，就这样吧，这应该是我写的最认真的一篇记录了，加油。</p>
</div><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>数据结构</a><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div class="post-nav"><a class="pre" href="/2017/12/16/pattern-match/">串的模式匹配应用之文本编辑</a><a class="next" href="/2017/11/13/linux-crontab/">自动签到续篇 —— Linux定时服务</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yd3glld8hGV5qBsgdj1wd0PN-gzGzoHsz',
  appKey:'6QgBEkctVPSnQKMI7G1n2EO2',
  placeholder:'if you have some questions, please comment',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E6%B2%BB%E6%87%92%E7%99%8C/">专治懒癌</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/">技术杂文</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">深入理解</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/">疑难杂症</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">21</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/07/202011-summary/">十一月碎语</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/some-of-leave/">临别有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/catch-me-if-you-can/">《猫鼠游戏》有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/js-number-scope/">JavaScript 中 Number 有多少个?</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/unicode-intro/">Unicode 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/js-spec-types/">JavaScript 规范类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/byteDance-intervies/">2019.6月 头条前端三面 面经</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/2019-plan-1/">2019年-2020年目标规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/mysql-password-reset/">Mac OS 重置MySQL密码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/vue-router-404/">vue-router 非定义路由的访问</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.lxxyx.cn/" title="繁易的前端乐园" target="_blank">繁易的前端乐园</a><ul></ul><a href="https://www.xiaohuochai.cc/" title="小火柴的前端小站" target="_blank">小火柴的前端小站</a><ul></ul><a href="https://www.haomwei.com/" title="屠夫9941" target="_blank">屠夫9941</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">wingsico.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.1"><script type="text/javascript" src="/js/search.js?v=0.0.1"></script><script>var search_path = '';
var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>